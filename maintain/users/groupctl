#!/bin/bash
# Author: Î¨-4ndr0666
# Designation: GROUPCTL v2.0 (Sovereign Edition)
set -euo pipefail
IFS=$'\n\t'

# ======================== // GROUPCTL //
## Description: A minimalistic yet powerful tool for managing user groups, 
#             including creation, deletion, adding/removing users to/from 
#             groups, and applying standard group presets.
# -----------------------------------

## Constants
LOG_FILE="/var/log/groupctl.log"
VERBOSE=false
DRY_RUN=false
PACKAGER=""
USER_TO_MANAGE=()

## Colors
RC='\033[0m'
RED='\033[31m'
YELLOW='\033[33m'
CYAN="\033[38;2;21;255;255m"
GREEN='\033[32m'

## Auto-escalate
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        printf "%b\n" "${RED}[!] Re-running with root privileges...${RC}"
        sudo "$0" "$@"
        exit $?
    fi
}

## Logging 
init_logging() {
    # Ensure directory exists if custom path used, otherwise /var/log should exist
    if [ ! -f "$LOG_FILE" ]; then
        touch "$LOG_FILE"
        chmod 600 "$LOG_FILE"
    fi
    # Ensure log is writable
    if [ ! -w "$LOG_FILE" ]; then
        printf "%b\n" "${RED}[!] Cannot write to log file $LOG_FILE. Exiting.${RC}"
        exit 1
    fi
}

log() {
    local MESSAGE="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') $MESSAGE" >> "$LOG_FILE"
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        local MESSAGE="$1"
        echo -e "$(date '+%Y-%m-%d %H:%M:%S') $MESSAGE" >> "$LOG_FILE"
    fi
}

## Validate 
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

## TRAP
terminate_script() {
    log "${RED}[!] Script terminated prematurely.${RC}"
    echo -e "\n${RED}[!] Script terminated by user.${RC}"
    exit 1
}
trap terminate_script SIGINT SIGTERM

## Package Manager Detection
determine_package_manager() {
    PACKAGERS=('pacman' 'apt-get' 'dnf' 'zypper')
    for pgm in "${PACKAGERS[@]}"; do
        if command_exists "$pgm"; then
            PACKAGER=$pgm
            log_verbose "${CYAN}Using $pgm as package manager.${RC}"
            return 0
        fi
    done

    printf "%b\n" "${RED}[!] No supported package manager found. Dependencies cannot be installed automatically.${RC}"
    exit 1
}

## Install
install_package() {
    local PKG="$1"
    printf "%b\n" "${YELLOW}[*] Installing $PKG...${RC}"
    if [ "$DRY_RUN" = false ]; then
        case "$PACKAGER" in
            pacman)
                pacman -S --noconfirm "$PKG" >> "$LOG_FILE" 2>&1
                ;;
            apt-get)
                # apt-get update is usually needed before install if cache is old
                apt-get update >> "$LOG_FILE" 2>&1
                apt-get install -y "$PKG" >> "$LOG_FILE" 2>&1
                ;;
            dnf)
                dnf install -y "$PKG" >> "$LOG_FILE" 2>&1
                ;;
            zypper)
                zypper install -y "$PKG" >> "$LOG_FILE" 2>&1
                ;;
            *)
                printf "%b\n" "${RED}[!] Automatic installation not supported. Please install $PKG manually.${RC}"
                exit 1
                ;;
        esac
        
        if command_exists "$PKG"; then
            printf "%b\n" "${GREEN}[+] Installed $PKG.${RC}"
            log "Installed dependency: $PKG"
        else
             # Some packages (like polkit) have different binary names than package names
             printf "%b\n" "${GREEN}[+] Installation command for $PKG finished.${RC}"
        fi
    else
        printf "%b\n" "${YELLOW}[Dry Run] Would install $PKG.${RC}"
    fi
}

## Polkit Check
is_polkit_installed() {
    case "$PACKAGER" in
        pacman) pacman -Qs polkit &>/dev/null ;;
        apt-get) dpkg -l policykit-1 &>/dev/null || dpkg -l polkitd &>/dev/null ;;
        dnf) dnf list installed polkit &>/dev/null ;;
        zypper) zypper se -i polkit &>/dev/null ;;
        *) return 1 ;;
    esac
}

## Deps
check_dependencies() {
    log_verbose "[*] Checking dependencies..."
    # Core utils usually present, but fzf is critical for the menu interface
    local DEPENDENCIES=('fzf' 'openssl') 
    
    # Check for package manager first
    determine_package_manager

    for PKG in "${DEPENDENCIES[@]}"; do
        if ! command_exists "$PKG"; then
            printf "%b\n" "${YELLOW}[!] $PKG is not installed. Attempting installation...${RC}"
            install_package "$PKG"
        fi
    done

    # Polkit special handling
    if ! is_polkit_installed; then
         printf "%b\n" "${YELLOW}[!] Polkit not detected. Attempting installation...${RC}"
         install_package "polkit"
    fi
}

## Help
show_help() {
    printf "%b\n" "${CYAN}Usage: $0 [options]${RC}"
    echo ""
    printf "%b\n" "Options:"
    printf "%b\n" "  -h, --help        Show this help message and exit."
    printf "%b\n" "  -v, --verbose     Enable verbose logging."
    printf "%b\n" "  -d, --dry-run     Perform a trial run with no changes made."
    echo ""
    exit 0
}

## Cli args
parse_arguments() {
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                ;;
            -v|--verbose)
                VERBOSE=true
                ;;
            -d|--dry-run)
                DRY_RUN=true
                ;;
            *)
                # Collect loose arguments as users
                USER_TO_MANAGE+=("$1")
                ;;
        esac
        shift
    done
}

## Perms 
correct_permissions() {
    local FILE="$1"
    local PERM="$2"
    local OWNER="$3"
    local GROUP="$4"

    if [ -e "$FILE" ]; then
        local CURRENT_PERM CURRENT_OWNER CURRENT_GROUP FILE_ATTR
        CURRENT_PERM=$(stat -c "%a" "$FILE")
        CURRENT_OWNER=$(stat -c "%U" "$FILE")
        CURRENT_GROUP=$(stat -c "%G" "$FILE")
        
        # Check for lsattr/chattr availability
        if command_exists lsattr; then
            FILE_ATTR=$(lsattr "$FILE" | awk '{print $1}')
        else
            FILE_ATTR=""
        fi

        if [[ "$CURRENT_PERM" != "$PERM" || "$CURRENT_OWNER" != "$OWNER" || "$CURRENT_GROUP" != "$GROUP" ]]; then
            log "${CYAN}[*] Correcting permissions for $FILE...${RC}"
            if [ "$DRY_RUN" = false ]; then
                chmod "$PERM" "$FILE" && chown "$OWNER":"$GROUP" "$FILE"
                log "${CYAN}[+] Permissions and ownership corrected for $FILE.${RC}"
            else
                log_verbose "${YELLOW}[Dry Run] Would chmod $PERM and chown $OWNER:$GROUP $FILE.${RC}"
            fi
        fi

        # Remove immutable bit if present to allow editing
        if [[ "$FILE_ATTR" == *"i"* ]]; then
            log "${YELLOW}[!] $FILE has immutable attribute set. Removing...${RC}"
            if [ "$DRY_RUN" = false ]; then
                if command_exists chattr; then
                    chattr -i "$FILE"
                    log "${CYAN}[+] Immutable attribute removed from $FILE.${RC}"
                else
                    log "${RED}[!] chattr not found. Cannot remove immutable bit.${RC}"
                fi
            else
                log_verbose "${YELLOW}[Dry Run] Would remove immutable attribute from $FILE.${RC}"
            fi
        fi
    fi
}

apply_permissions() {
    log_verbose "[*] Applying correct permissions to critical files..."
    declare -A FILES
    FILES["/etc/group"]="644 root root"
    FILES["/etc/gshadow"]="640 root root"
    FILES["/etc/sudoers"]="440 root root"
    FILES["/etc/sudoers.d"]="755 root root"

    for FILE in "${!FILES[@]}"; do
        local PERM OWNER GROUP
        PERM=$(echo "${FILES[$FILE]}" | awk '{print $1}')
        OWNER=$(echo "${FILES[$FILE]}" | awk '{print $2}')
        GROUP=$(echo "${FILES[$FILE]}" | awk '{print $3}')
        correct_permissions "$FILE" "$PERM" "$OWNER" "$GROUP"
    done
}

## Lockfile
remove_lock_files() {
    log_verbose "[*] Checking for lock files..."
    local LOCK_FILES=('/etc/group.lock' '/etc/gshadow.lock' '/etc/sudoers.lock' '/etc/sudoers.d.lock')
    for LOCK in "${LOCK_FILES[@]}"; do
        if [ -f "$LOCK" ]; then
            log "${YELLOW}[!] Lock file found: $LOCK${RC}"
            if [ "$DRY_RUN" = false ]; then
                rm -f "$LOCK"
                log "${CYAN}[+] Removed lock file: $LOCK${RC}"
            else
                log_verbose "${YELLOW}[Dry Run] Would remove lock file: $LOCK.${RC}"
            fi
        fi
    done
}

## Make group 
create_group() {
    local GROUP="$1"
    if ! grep -q "^$GROUP:" /etc/group; then
        log "${CYAN}[+] Creating group: $GROUP.${RC}"
        if [ "$DRY_RUN" = false ]; then
            groupadd "$GROUP" && log "${CYAN}[+] Group $GROUP created successfully.${RC}"
        else
            log_verbose "${YELLOW}[Dry Run] Would create group: $GROUP.${RC}"
        fi
    else
        log_verbose "${YELLOW}[-] Group $GROUP already exists.${RC}"
        printf "%b\n" "${YELLOW}[-] Group $GROUP already exists.${RC}"
    fi
}

## Delete group
delete_group() {
    local GROUP="$1"
    if grep -q "^$GROUP:" /etc/group; then
        log "${CYAN}[+] Deleting group: $GROUP.${RC}"
        if [ "$DRY_RUN" = false ]; then
            groupdel "$GROUP" && log "${CYAN}[+] Group $GROUP deleted successfully.${RC}"
        else
            log_verbose "${YELLOW}[Dry Run] Would delete group: $GROUP.${RC}"
        fi
    else
        log_verbose "${YELLOW}[-] Group $GROUP does not exist.${RC}"
        printf "%b\n" "${YELLOW}[-] Group $GROUP does not exist.${RC}"
    fi
}

## Current groups
view_user_groups() {
    local USER="$1"
    if id "$USER" &>/dev/null; then
        local USER_GROUPS
        USER_GROUPS=$(id -nG "$USER")
        printf "%b\n" "${CYAN}Groups for user '$USER':${RC} $USER_GROUPS"
    else
        printf "%b\n" "${RED}[!] User '$USER' does not exist.${RC}"
    fi
}

## Add user to group
add_user_to_groups() {
    local USER="$1"
    shift
    local GROUPS_LIST=("$@")
    for GROUP in "${GROUPS_LIST[@]}"; do
        create_group "$GROUP"
        log "${CYAN}[+] Adding user '$USER' to group '$GROUP'.${RC}"
        if [ "$DRY_RUN" = false ]; then
            usermod -aG "$GROUP" "$USER" && log "${CYAN}[+] User '$USER' added to group '$GROUP'.${RC}"
        else
            log_verbose "${YELLOW}[Dry Run] Would add user '$USER' to group '$GROUP'.${RC}"
        fi
    done
}

## Rm user from group 
remove_user_from_groups() {
    local USER="$1"
    shift
    local GROUPS_LIST=("$@")
    for GROUP in "${GROUPS_LIST[@]}"; do
        if id -nG "$USER" | grep -qw "$GROUP"; then
            log "${CYAN}[+] Removing user '$USER' from group '$GROUP'.${RC}"
            if [ "$DRY_RUN" = false ]; then
                # gpasswd is safer for removal than usermod -G
                if command_exists gpasswd; then
                    gpasswd -d "$USER" "$GROUP" && log "${CYAN}[+] User '$USER' removed from group '$GROUP'.${RC}"
                else
                    log "${RED}[!] gpasswd not found. Cannot remove user from group safely.${RC}"
                fi
            else
                log_verbose "${YELLOW}[Dry Run] Would remove user '$USER' from group '$GROUP'.${RC}"
            fi
        else
            log_verbose "${YELLOW}[-] User '$USER' is not a member of group '$GROUP'.${RC}"
        fi
    done
}

## Presets
apply_standard_preset() {
    local USER="$1"
    local STANDARD_GROUPS=("adm" "users" "disk" "wheel" "cdrom" "audio" "video" "usb" "optical" "storage" "scanner" "lp" "network" "power" "docker")
    log "${CYAN}[*] Applying standard preset groups to user '$USER'...${RC}"
    for GROUP in "${STANDARD_GROUPS[@]}"; do
        # Only try to add if group exists on system to avoid spamming creation of distro-specific groups
        if grep -q "^$GROUP:" /etc/group; then
            log "${CYAN}[+] Adding user '$USER' to group '$GROUP'.${RC}"
            if [ "$DRY_RUN" = false ]; then
                usermod -aG "$GROUP" "$USER" && log "${CYAN}[+] User '$USER' added to group '$GROUP'.${RC}"
            else
                log_verbose "${YELLOW}[Dry Run] Would add user '$USER' to group '$GROUP'.${RC}"
            fi
        else
            log_verbose "${YELLOW}[-] Group '$GROUP' not found on system. Skipping.${RC}"
        fi
    done
    printf "%b\n" "${CYAN}[+] Standard preset applied to user '$USER'.${RC}"
}

## Sudoers
enable_group_in_sudoers() {
    local GROUP="$1"
    local SUDOERS_FILE="/etc/sudoers.d/${GROUP}-sudo"
    
    # Validation
    if ! grep -q "^$GROUP:" /etc/group; then
        printf "%b\n" "${RED}[!] Group '$GROUP' does not exist. Create it first.${RC}"
        return 1
    fi

    if [ ! -f "$SUDOERS_FILE" ]; then
        log "${CYAN}[*] Enabling group '$GROUP' in sudoers...${RC}"
        if [ "$DRY_RUN" = false ]; then
            # Write temp file first, then move, but simplified here with visudo check
            echo "%$GROUP ALL=(ALL) ALL" > "$SUDOERS_FILE"
            chmod 440 "$SUDOERS_FILE"
            # Critical syntax check
            if visudo -c -f "$SUDOERS_FILE" >/dev/null 2>&1; then
                 log "${CYAN}[+] Group '$GROUP' has been enabled for sudo access.${RC}"
            else
                 log "${RED}[!] Syntax error in generated sudoers file. Reverting immediately.${RC}"
                 rm -f "$SUDOERS_FILE"
                 printf "%b\n" "${RED}[!] Failed to enable sudoers: Syntax check failed.${RC}"
            fi
        else
            log_verbose "${YELLOW}[Dry Run] Would enable group '$GROUP' in sudoers by creating $SUDOERS_FILE.${RC}"
        fi
    else
        log_verbose "${YELLOW}[-] Group '$GROUP' is already enabled in sudoers.${RC}"
        printf "%b\n" "${YELLOW}[-] Group '$GROUP' is already enabled in sudoers.${RC}"
    fi
}

disable_group_in_sudoers() {
    local GROUP="$1"
    local SUDOERS_FILE="/etc/sudoers.d/${GROUP}-sudo"
    if [ -f "$SUDOERS_FILE" ]; then
        log "${CYAN}[*] Disabling group '$GROUP' in sudoers...${RC}"
        if [ "$DRY_RUN" = false ]; then
            rm -f "$SUDOERS_FILE"
            log "${CYAN}[+] Group '$GROUP' has been disabled for sudo access.${RC}"
        else
            log_verbose "${YELLOW}[Dry Run] Would disable group '$GROUP' in sudoers by removing $SUDOERS_FILE.${RC}"
        fi
    else
        log_verbose "${YELLOW}[-] Group '$GROUP' is not enabled in sudoers.${RC}"
        printf "%b\n" "${YELLOW}[-] Group '$GROUP' is not enabled in sudoers.${RC}"
    fi
}

## Summary
generate_summary_report() {
    log "${CYAN}[*] Session ended.${RC}"
    if [ "$DRY_RUN" = false ]; then
        echo "==================== Session End: $(date) ====================" >> "$LOG_FILE"
    fi
}

## Main entry point
main_menu() {
    while true; do
        clear
        echo -e "#${CYAN} === // GROUPCTL //${RC}"
        echo -e "${YELLOW}Log File: $LOG_FILE${RC}"
        if [ "$DRY_RUN" = true ]; then echo -e "${YELLOW}MODE: DRY RUN${RC}"; fi
        echo ""
        echo -e "${YELLOW}Select an operation:${RC}"
        echo " 1) View User's Groups"
        echo " 2) Add User to Group"
        echo " 3) Remove User from Group"
        echo " 4) Apply Standard Group Preset"
        echo " 5) Create a New Group"
        echo " 6) Delete a Group"
        echo " 7) Enable Group in Sudoers"
        echo " 8) Disable Group in Sudoers"
        echo " 9) Exit"
        echo ""
        read -rp "#? " choice
        case "$choice" in
            1)
                echo -e "${CYAN}Enter username:${RC}"
                read -r username
                view_user_groups "$username"
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            2)
                echo -e "${CYAN}Enter username:${RC}"
                read -r username
                if id "$username" &>/dev/null; then
                    echo -e "${CYAN}Select group(s) to add user to (TAB to select multiple):${RC}"
                    # Use mapfile to safely capture fzf output
                    mapfile -t selected < <(cut -d: -f1 /etc/group | fzf -m --height 40% --layout=reverse --border)
                    if [ "${#selected[@]}" -gt 0 ]; then
                        add_user_to_groups "$username" "${selected[@]}"
                        echo -e "${CYAN}[+] User '$username' added to selected groups.${RC}"
                    else
                        echo -e "${YELLOW}[!] No groups selected.${RC}"
                    fi
                else
                    echo -e "${RED}[!] User '$username' does not exist.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            3)
                echo -e "${CYAN}Enter username:${RC}"
                read -r username
                if id "$username" &>/dev/null; then
                    echo -e "${CYAN}Select group(s) to remove user from (TAB to select multiple):${RC}"
                    mapfile -t selected < <(id -nG "$username" | tr ' ' '\n' | fzf -m --height 40% --layout=reverse --border)
                    if [ "${#selected[@]}" -gt 0 ]; then
                        remove_user_from_groups "$username" "${selected[@]}"
                        echo -e "${CYAN}[+] User '$username' removed from selected groups.${RC}"
                    else
                        echo -e "${YELLOW}[!] No groups selected.${RC}"
                    fi
                else
                    echo -e "${RED}[!] User '$username' does not exist.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            4)
                echo -e "${CYAN}Enter username:${RC}"
                read -r username
                if id "$username" &>/dev/null; then
                    apply_standard_preset "$username"
                else
                    echo -e "${RED}[!] User '$username' does not exist.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            5)
                echo -e "${CYAN}Enter group name to create:${RC}"
                read -r groupname
                if [[ "$groupname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    create_group "$groupname"
                else
                    echo -e "${RED}[!] Invalid group name. Use only letters, numbers, underscores, or hyphens.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            6)
                echo -e "${CYAN}Enter group name to delete:${RC}"
                read -r groupname
                if [[ "$groupname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    if [[ "$groupname" == "root" || "$groupname" == "sudo" ]]; then
                        echo -e "${RED}[!] Cannot delete critical group '$groupname'.${RC}"
                    else
                        delete_group "$groupname"
                    fi
                else
                    echo -e "${RED}[!] Invalid group name.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            7)
                echo -e "${CYAN}Enter group name to enable in sudoers:${RC}"
                read -r groupname
                if [[ "$groupname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    enable_group_in_sudoers "$groupname"
                else
                    echo -e "${RED}[!] Invalid group name.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            8)
                echo -e "${CYAN}Enter group name to disable in sudoers:${RC}"
                read -r groupname
                if [[ "$groupname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    disable_group_in_sudoers "$groupname"
                else
                    echo -e "${RED}[!] Invalid group name.${RC}"
                fi
                read -n1 -s -r -p "Press any key to return..." ; echo ""
                ;;
            9)
                echo -e "${CYAN}[+] Exiting group_manager.sh.${RC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid option. Please enter a number between 1 and 9.${RC}"
                sleep 1
                ;;
        esac
    done
}

# --- Execution Flow ---

# 1. Root Check
check_root "$@"

# 2. Argument Parsing
parse_arguments "$@"

# 3. Environment Setup
init_logging
#check_dependencies
remove_lock_files
apply_permissions

# 4. Main Interface
log "${CYAN}[+] Starting GROUPCTL session...${RC}"
main_menu

# 5. Cleanup
generate_summary_report
log "${CYAN}[+] GROUPCTL session complete.${RC}"
printf "%b\n" "${CYAN}[+] All tasks completed. Log at $LOG_FILE.${RC}"
