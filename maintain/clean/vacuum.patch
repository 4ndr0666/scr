diff --git a/vacuum.py b/vacuum.py
index abc1234..def5678 100644
@@
-import os
-import sys
-import subprocess
-import shutil
-import time
-import logging
-import json
+import os
+import sys
+import subprocess
+import shutil
+import time
+import logging
+import json
+import re
+from datetime import datetime
+from pathlib import Path
 
-from typing import List, Optional
+from typing import List, Optional, Callable
@@
 # ─────────────────────────── Utility / helper functions ────────────────── #
+# -------------------------------------------------------------------------
+# Official-repo checker and interactive selector
+# -------------------------------------------------------------------------
+
+def is_official_package(pkg_name: str) -> bool:
+    """
+    Heuristic: `pacman -Qi <pkg>` → parse “Repository” line.
+    Returns True for core/extra/community/multilib; False for local/AUR.
+    """
+    cp = subprocess.run(["pacman", "-Qi", pkg_name],
+                        capture_output=True, text=True)
+    if cp.returncode != 0:
+        return False
+    for ln in cp.stdout.splitlines():
+        if ln.lower().startswith("repository"):
+            repo = ln.split(":", 1)[1].strip().lower()
+            return repo not in {"local", "aur"}
+    return False
+
+
+def select_items_from_list(items: List[str], prompt: str) -> List[str]:
+    """
+    Return a subset chosen by the user. Uses **fzf** if available,
+    otherwise falls back to numeric input.
+    """
+    if not items:
+        return []
+
+    # fzf path
+    if shutil.which("fzf"):
+        proc = subprocess.run(
+            ["fzf", "-m", "--prompt", prompt],
+            input="\n".join(items),
+            text=True,
+            capture_output=True,
+        )
+        return proc.stdout.strip().splitlines() if proc.returncode == 0 else []
+
+    # CLI fallback
+    print(prompt)
+    for i, itm in enumerate(items, 1):
+        print(f" {i:2}) {itm}")
+    raw = input("Numbers comma-/space-separated (Q to cancel): ").strip()
+    if raw.upper() == "Q":
+        return []
+    try:
+        idxs = [int(x) - 1 for x in re.split(r"[,\s]+", raw) if x]
+        return [items[i] for i in idxs if 0 <= i < len(items)]
+    except ValueError:
+        print("Invalid input.")
+        return []
+
diff --git a/vacuum.py b/vacuum.py
@@
-    backup_file = LOG_BASE_DIR / f"services_backup_{datetime.datetime.now():%Y%m%d_%H%M%S}.txt"
+    backup_file = LOG_BASE_DIR / f"services_backup_{datetime.now():%Y%m%d_%H%M%S}.txt"
@@
-def run_all_tasks() -> None:
-    """Run all maintenance tasks (1 through 31)."""
-    for key in [str(k) for k in range(1, 32)]:
-        ...
+NON_INTERACTIVE_TASKS: List[Callable[[], None]] = [
+    process_dep_scan_log,
+    remove_broken_symlinks,
+    clean_old_kernels,
+    vacuum_journalctl,
+    clear_cache,
+    update_font_cache,
+    clear_trash,
+    optimize_databases,
+    clean_package_cache,
+    clean_aur_dir,
+    handle_pacnew_pacsave,
+    check_failed_cron_jobs,
+    clear_docker_images,
+    clear_temp_folder,
+    check_rmshit_script,
+    remove_old_ssh_known_hosts,
+    remove_orphan_vim_undo_files,
+    force_log_rotation,
+    configure_zram,
+    check_zram_configuration,
+    adjust_swappiness,
+    clear_system_cache,
+    disable_unused_services,
+    check_and_restart_systemd_units,
+    security_audit,
+    monitor_system_logs,
+    generate_system_report,
+]
+
+def run_all_tasks() -> None:
+    """Sequentially run every *non-interactive* maintenance task."""
+    for func in NON_INTERACTIVE_TASKS:
+        try:
+            func()
+        except Exception:
+            logging.exception("Task %s failed", func.__name__)
+            print(f"{FAILURE} {func.__name__} failed → see log.")
