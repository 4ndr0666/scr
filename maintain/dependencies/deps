#!/usr/bin/env bash
# File: deps
# Author: 4ndr0666
# Purpose: Check for missing dependencies and install them automatically,
#          mapping library names (e.g., "libjpeg") to correct Arch package names
#          (e.g., "libjpeg-turbo"), and defaulting to a "Y" installation prompt
#          after a long or indefinite wait.

###############################################################################
# Auto-escalation with refined failure handling
###############################################################################
declare user_status
user_status="$EUID"

if [ "$user_status" -ne 0 ]; then
    echo "Re-running the script with sudo privileges..."
    sudo bash "$0" "$@" || {
        declare status_code
        status_code="$?"
        if [ "$status_code" -ge 130 ] && [ "$status_code" -le 143 ]; then
            echo "Script interrupted by user during sudo execution. Exiting..."
        else
            echo "Failed to escalate privileges (exit code $status_code). Exiting..."
        fi
        exit 1
    }
    exit 0
fi

###############################################################################
# Internal Field Separator
###############################################################################
IFS=$'\n\t'

###############################################################################
# Global Variables & Constants
###############################################################################
declare DEFAULT_LOGFILE
DEFAULT_LOGFILE="${HOME}/.local/share/logs/dependency-checker.log"

declare PACMAN_LOCK
PACMAN_LOCK="/var/lib/pacman/db.lck"

declare AUR_DIR
AUR_DIR="${HOME}/build"

declare TMP_INSTALLED_FILE
TMP_INSTALLED_FILE=""

declare ALL_SYSTEM
ALL_SYSTEM=false

declare INTERACTIVE_MODE
INTERACTIVE_MODE=false

# We'll keep custom ignores separate and then merge them.
declare -a CUSTOM_IGNORE_PKGS
CUSTOM_IGNORE_PKGS=()

declare -a CUSTOM_IGNORE_GROUPS
CUSTOM_IGNORE_GROUPS=()

declare -a IGNORE_PKGS
IGNORE_PKGS=()

declare -a IGNORE_GROUPS
IGNORE_GROUPS=()

declare -a MISSING_DEPS
MISSING_DEPS=()

declare -a PKGLIST
PKGLIST=()

###############################################################################
# Cleanup with TRAP
###############################################################################
cleanup() {
    if [ -n "$TMP_INSTALLED_FILE" ] && [ -f "$TMP_INSTALLED_FILE" ]; then
        rm -f "$TMP_INSTALLED_FILE"
    fi
}
trap cleanup EXIT

###############################################################################
# Directory Setup
###############################################################################
mkdir -p "$(dirname "$DEFAULT_LOGFILE")"
mkdir -p "$AUR_DIR"
chown "$(whoami)":"$(whoami)" "$AUR_DIR"
chmod 755 "$AUR_DIR"

declare LOGFILE
LOGFILE="$DEFAULT_LOGFILE"

###############################################################################
# Logging Function
###############################################################################
log_message() {
    declare msg
    msg="$1"
    echo -e "$msg" 2>&1 | tee -a "$LOGFILE"
}

###############################################################################
# Auto-install Required Tools (with retries)
###############################################################################
check_requirements() {
    declare -a required_tools
    required_tools=("pacman" "pactree" "expac" "xargs" "git" "reflector" "setfacl" "loginctl")

    declare -a missing_tools
    missing_tools=()

    declare tool
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done

    if [ "${#missing_tools[@]}" -eq 0 ]; then
        log_message "INFO: All required tools are present."
        return 0
    fi

    log_message "INFO: Auto-installing missing tools: ${missing_tools[*]}"

    # 'pacman' cannot install itself if missing
    if [[ " ${missing_tools[*]} " =~ " pacman " ]]; then
        log_message "ERROR: 'pacman' is missing. Cannot auto-install. Please fix your system manually."
        exit 1
    fi

    declare t
    for t in "${missing_tools[@]}"; do
        declare retries
        retries=3
        declare i
        for (( i=1; i<=retries; i++ )); do
            if pacman -S --needed --noconfirm "$t" >/dev/null 2>&1; then
                log_message "INFO: Successfully installed '$t'."
                break
            fi
            log_message "WARN: Attempt $i/$retries failed to install '$t'. Retrying..."
            sleep 3
        done
        if ! command -v "$t" >/dev/null 2>&1; then
            log_message "ERROR: '$t' could not be installed after $retries attempts."
        fi
    done
}

###############################################################################
# Wait for Pacman Lock
###############################################################################
wait_for_pacman_lock() {
    declare wait_time
    wait_time=30

    declare interval
    interval=5

    declare elapsed
    elapsed=0

    while [ -e "$PACMAN_LOCK" ]; do
        if [ "$elapsed" -ge "$wait_time" ]; then
            log_message "ERROR: pacman lock ($PACMAN_LOCK) still exists after $wait_time seconds. Another process may be running!"
            log_message "INFO: Remove lock with: rm -f $PACMAN_LOCK"
            exit 1
        fi
        log_message "INFO: Waiting for pacman lock to be released... ($elapsed/$wait_time sec elapsed)"
        sleep "$interval"
        elapsed=$((elapsed + interval))
    done
}

###############################################################################
# Check if Available in Repos or AUR
###############################################################################
is_available_in_repo() {
    pacman -Si "$1" >/dev/null 2>&1
    return $?
}

is_available_in_aur() {
    declare pkg
    pkg="$1"
    # Using "grep -q" to detect "resultcount":1 from AUR JSON
    curl -s "https://aur.archlinux.org/rpc/?v=5&type=info&arg=$pkg" | grep -q '"resultcount":1'
}

###############################################################################
# Attempt to discover the *actual* package name if BFS yields a library name
###############################################################################
resolve_package_name() {
    declare node
    node="$1"

    # 1) If node is recognized by pacman or AUR, no changes needed
    if is_available_in_repo "$node" || is_available_in_aur "$node"; then
        echo "$node"
        return
    fi

    # 2) Possibly it's a library name like "libverto-module-base" -> /usr/lib/libverto-module-base.so
    #    We'll guess a few likely paths and see if they exist, then pacman -Qo them.
    declare -a possible_paths
    possible_paths=()

    # For example, if node is "libjpeg", we try /usr/lib/libjpeg.so
    # If node is "libverto-module-base", we try /usr/lib/libverto-module-base.so
    possible_paths+=( "/usr/lib/${node}.so" )
    # Also try the name itself in /usr/bin, in case it's a binary
    possible_paths+=( "/usr/bin/${node}" )
    # Some packages have slightly different .so names (like .so.0)
    # We'll do a small wildcard search. We'll limit to 1 file if multiple are found.
    declare -a wildcard
    wildcard=( $(find /usr/lib -maxdepth 1 -name "${node}.so*" 2>/dev/null) )
    if [ "${#wildcard[@]}" -gt 0 ]; then
        possible_paths+=( "${wildcard[0]}" )
    fi

    declare path
    for path in "${possible_paths[@]}"; do
        # If file doesn't exist, skip
        if [ ! -e "$path" ]; then
            continue
        fi

        # See if pacman -Qo yields a real package
        declare owned
        owned="$(pacman -Qo "$path" 2>/dev/null || true)"
        # E.g. "usr/lib/libverto-module-base.so is owned by libverto 0.3.2-5"
        if [[ "$owned" =~ " owned by " ]]; then
            # We'll parse out the actual package name
            # Example match: "usr/lib/libverto-module-base.so is owned by libverto 0.3.2-5"
            # We'll get "libverto" from that
            declare name
            name="$(echo "$owned" | awk '{print $(NF-1)}')"
            if [ -n "$name" ]; then
                echo "$name"
                return
            fi
        fi
    done

    # 3) If all else fails, we just return the original string
    echo "$node"
}

###############################################################################
# Install Single Package
###############################################################################
install_package() {
    declare pkg
    pkg="$1"

    declare clean_pkg
    clean_pkg="$(echo "$pkg" | sed -E 's/[><=].*$//')"

    # Final name resolution
    declare real_name
    real_name="$(resolve_package_name "$clean_pkg")"

    # If still unrecognized by pacman or AUR, skip
    if ! is_available_in_repo "$real_name" && ! is_available_in_aur "$real_name"; then
        log_message "WARN: '$clean_pkg' resolved to '$real_name', not found in pacman/AUR. Skipping."
        return 0
    fi

    declare retry_count
    retry_count=3
    declare success
    success=false

    declare i
    for (( i=1; i<=retry_count; i++ )); do
        log_message "INFO: Installing '$real_name' (attempt $i/$retry_count)..."
        if pacman -S --needed --noconfirm "$real_name" >/dev/null 2>&1; then
            success=true
            break
        else
            log_message "WARN: Installation of '$real_name' failed; retrying..."
            sleep 3
        fi
    done

    if $success; then
        log_message "INFO: Successfully installed '$real_name'."
    else
        log_message "WARN: Failed to install '$real_name' after $retry_count tries."
    fi
}

###############################################################################
# Install Missing Dependencies in Parallel
###############################################################################
install_missing_dependencies() {
    if [ "${#MISSING_DEPS[@]}" -eq 0 ]; then
        log_message "INFO: No missing dependencies to install."
        return
    fi

    log_message "INFO: Installing missing dependencies: ${MISSING_DEPS[*]}"

    declare max_jobs
    max_jobs=4
    declare current_jobs
    current_jobs=0

    declare dep
    for dep in "${MISSING_DEPS[@]}"; do
        install_package "$dep" &
        current_jobs=$(( current_jobs + 1 ))

        if [ "$current_jobs" -ge "$max_jobs" ]; then
            wait -n
            current_jobs=$(( current_jobs - 1 ))
        fi
    done

    wait
    log_message "INFO: Finished installing missing dependencies."
}

###############################################################################
# Load Ignored Packages & Groups
###############################################################################
load_ignored_packages() {
    if [ -f /etc/pacman.conf ]; then
        declare line
        while IFS= read -r line; do
            case "$line" in
                IgnorePkg*)
                    declare pkgs
                    pkgs="${line#IgnorePkg*= }"
                    declare -a pkg_array
                    pkg_array=()
                    IFS=' ' read -r -a pkg_array <<< "$pkgs"
                    IGNORE_PKGS=( "${IGNORE_PKGS[@]}" "${pkg_array[@]}" )
                    ;;
                IgnoreGroup*)
                    declare groups
                    groups="${line#IgnoreGroup*= }"
                    declare -a group_array
                    group_array=()
                    IFS=' ' read -r -a group_array <<< "$groups"
                    IGNORE_GROUPS=( "${IGNORE_GROUPS[@]}" "${group_array[@]}" )
                    ;;
            esac
        done </etc/pacman.conf
    fi
    # Merge with any custom ignores
    IGNORE_PKGS=( "${IGNORE_PKGS[@]}" "${CUSTOM_IGNORE_PKGS[@]}" )
    IGNORE_GROUPS=( "${IGNORE_GROUPS[@]}" "${CUSTOM_IGNORE_GROUPS[@]}" )
}

###############################################################################
# Check if a Package is Ignored
###############################################################################
is_ignored_package() {
    declare pkg
    pkg="$1"

    declare ignored
    for ignored in "${IGNORE_PKGS[@]}"; do
        if [ "$pkg" = "$ignored" ]; then
            return 0
        fi
    done

    declare group
    for group in "${IGNORE_GROUPS[@]}"; do
        declare group_pkgs
        group_pkgs="$(pacman -Sg "$group" 2>/dev/null | awk '{print $2}')"
        declare g_pkg
        for g_pkg in $group_pkgs; do
            if [ "$pkg" = "$g_pkg" ]; then
                return 0
            fi
        done
    done
    return 1
}

###############################################################################
# Refresh Pacman Databases
###############################################################################
refresh_pacman_databases() {
    log_message "INFO: Refreshing pacman db..."
    if ! pacman -Sy --noconfirm >/dev/null 2>&1; then
        declare error_output
        error_output="$(pacman -Sy --noconfirm 2>&1)" || true
        handle_pacman_errors "$error_output"

        if ! pacman -Sy --noconfirm >/dev/null 2>&1; then
            log_message "ERROR: Failed to refresh pacman db after error handling."
            exit 1
        fi
    else
        log_message "INFO: Pacman db refreshed successfully."
    fi
}

###############################################################################
# Handle Common pacman Errors
###############################################################################
handle_pacman_errors() {
    declare stderr
    stderr="$1"

    if echo "$stderr" | grep -q 'db\.sig'; then
        log_message "WARN: Signature error detected. Attempting mirror refresh..."
        if ! reflector --latest 20 --sort rate --save /etc/pacman.d/mirrorlist >/dev/null 2>&1; then
            log_message "WARN: Reflector failed; using existing mirrors."
        fi
        if ! pacman -Sy --noconfirm >/dev/null 2>&1; then
            log_message "ERROR: Could not refresh pacman db after signature error."
            exit 1
        fi
    elif echo "$stderr" | grep -q 'exists in filesystem'; then
        log_message "WARN: File conflict detected; attempting overwrite..."
        if ! pacman -Syu --overwrite '*' --noconfirm >/dev/null 2>&1; then
            log_message "ERROR: Failed to resolve file conflict."
            exit 1
        fi
    else
        log_message "ERROR: pacman error: $stderr"
        exit 1
    fi
}

###############################################################################
# Cache Installed Packages to a File
###############################################################################
cache_installed_packages() {
    TMP_INSTALLED_FILE="$(mktemp "/tmp/installed_pkgs.XXXXXX")"
    pacman -Qq >"$TMP_INSTALLED_FILE" 2>&1
}

###############################################################################
# Check if a Package is Installed
###############################################################################
is_installed() {
    declare pkg
    pkg="$(echo "$1" | sed -E 's/[><=].*$//')"

    # If the package is "sh" or some .so reference, skip
    if [ "$pkg" = "sh" ] || [[ "$pkg" =~ \.so ]]; then
        return 0
    fi

    # Attempt name resolution first:
    declare final_name
    final_name="$(resolve_package_name "$pkg")"

    grep -qxF "$final_name" "$TMP_INSTALLED_FILE"
}

###############################################################################
# Gather Dependencies Using pactree (with 10s timeout)
###############################################################################
gather_dependencies() {
    declare p
    p="$1"
    timeout 10 pactree -u "$p" 2>/dev/null || true
}

###############################################################################
# Check Missing Dependencies (BFS)
###############################################################################
check_missing_dependencies() {
    declare -a packages
    packages=("$@")

    declare -A visited
    declare -a queue
    queue=()

    declare pkg
    for pkg in "${packages[@]}"; do
        queue+=( "$pkg" )
    done

    while [ "${#queue[@]}" -gt 0 ]; do
        declare current
        current="${queue[0]}"
        queue=( "${queue[@]:1}" )

        declare real_current
        real_current="$(resolve_package_name "$current")"

        # If ignored or visited, skip
        if is_ignored_package "$real_current"; then
            continue
        fi
        if [ -n "${visited["$real_current"]+exists}" ]; then
            continue
        fi
        visited["$real_current"]=1

        # If not installed => missing
        if ! is_installed "$real_current"; then
            MISSING_DEPS+=( "$real_current" )
        fi

        # Attempt BFS sub-deps
        declare output
        output="$(gather_dependencies "$real_current")"
        if [ -n "$output" ]; then
            declare skip_first
            skip_first=true

            declare line
            while IFS= read -r line; do
                if [ "$skip_first" = true ]; then
                    skip_first=false
                    continue
                fi

                # Remove leading whitespace
                declare child
                child="$(echo "$line" | sed -E 's/^[[:space:]]+//')"
                # Strip version constraints
                child="$(echo "$child" | sed -E 's/[><=].*$//')"

                queue+=( "$child" )
            done < <(echo "$output")
        fi
    done

    if [ "${#MISSING_DEPS[@]}" -eq 0 ]; then
        log_message "INFO: All dependencies satisfied."
    else
        log_message "INFO: Missing dependencies: ${MISSING_DEPS[*]}"
    fi
}

###############################################################################
# Interactive Installation Prompt (now indefinite wait, default 'Y')
###############################################################################
prompt_with_timeout() {
    declare prompt_msg
    prompt_msg="$1"

    # Large or indefinite wait => remove -t usage
    echo -n "$prompt_msg"
    declare response
    read -r response
    if [ -z "$response" ]; then
        # default to 'Y' if user does nothing
        response="y"
    fi
    echo "$response"
}

interactive_install() {
    if [ "${#MISSING_DEPS[@]}" -gt 0 ]; then
        log_message "The following dependencies are missing:"
        declare i
        for i in $(seq 0 $((${#MISSING_DEPS[@]} - 1))); do
            echo "$(( i + 1 )). ${MISSING_DEPS[$i]}"
        done

        declare user_resp
        user_resp="$(prompt_with_timeout 'Install these dependencies? [Y/n]: ' )"

        case "$user_resp" in
            [Nn]*)
                log_message "INFO: Installation aborted by user."
                ;;
            *)
                install_missing_dependencies
                ;;
        esac
    else
        log_message "INFO: No missing dependencies to install."
    fi
}

###############################################################################
# Print Help Screen
###############################################################################
print_help() {
    cat <<EOF
Usage: $0 [OPTIONS] [package1 package2 ...]

  -a             Check & install missing dependencies for the entire system
  -i             Enable interactive installation mode
  -k <packages>  Comma-separated list of packages to ignore
  -g <groups>    Comma-separated list of groups to ignore
  -l <logfile>   Custom log file (default: $DEFAULT_LOGFILE)
  -h             Display this help screen

Examples:
  $0 -a
  $0 -i firefox
  $0 -k firefox,thunderbird bash
  $0 -g base,extra python
EOF
    exit 0
}

###############################################################################
# Parse Command-Line Arguments
###############################################################################
parse_arguments() {
    declare opt
    while getopts "iak:g:l:h" opt; do
        case "$opt" in
            a) ALL_SYSTEM=true ;;
            i) INTERACTIVE_MODE=true ;;
            k)
                declare -a pkg_array
                pkg_array=()
                IFS=',' read -r -a pkg_array <<< "$OPTARG"
                CUSTOM_IGNORE_PKGS+=( "${pkg_array[@]}" )
                ;;
            g)
                declare -a group_array
                group_array=()
                IFS=',' read -r -a group_array <<< "$OPTARG"
                CUSTOM_IGNORE_GROUPS+=( "${group_array[@]}" )
                ;;
            l) LOGFILE="$OPTARG" ;;
            h) print_help ;;
            *) print_help ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "$ALL_SYSTEM" = false ] && [ $# -eq 0 ]; then
        print_help
    fi

    if [ "$ALL_SYSTEM" = true ]; then
        mapfile -t PKGLIST < <(pacman -Qqe)
    else
        PKGLIST=( "$@" )
    fi
}

###############################################################################
# Main Execution
###############################################################################
main() {
    log_message "INFO: Starting dependency checker..."
    check_requirements
    wait_for_pacman_lock
    load_ignored_packages
    refresh_pacman_databases
    cache_installed_packages

    check_missing_dependencies "${PKGLIST[@]}"

    if [ "$INTERACTIVE_MODE" = true ] && [ -t 0 ]; then
        interactive_install
    else
        install_missing_dependencies
    fi
    log_message "INFO: Completed."
}

parse_arguments "$@"
main
