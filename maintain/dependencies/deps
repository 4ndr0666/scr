
set -euo pipefail
set -E

    clear
    OK="$(tput setaf 2)[OK]$(tput sgr0)"
    ERROR="$(tput setaf 1)[ERROR]$(tput sgr0)"
    NOTE="$(tput setaf 3)[NOTE]$(tput sgr0)"
    INFO="$(tput setaf 4)[INFO]$(tput sgr0)"
    WARN="$(tput setaf 1)[WARN]$(tput sgr0)"
    CAT="$(tput setaf 6)[ACTION]$(tput sgr0)"
    MAGENTA="$(tput setaf 5)"
    ORANGE="$(tput setaf 214)"
    WARNING="$(tput setaf 1)"
    YELLOW="$(tput setaf 3)"
    GREEN="$(tput setaf 2)"
    BLUE="$(tput setaf 4)"
    SKY_BLUE="$(tput setaf 6)"
    RESET="$(tput sgr0)"

    trap 'echo -e "\nExiting..."; exit 1' SIGINT

## Global Variables & Constants.

declare -r APP_NAME="dependency-checker"

declare -r SYSTEM_LOG_DIR="/var/log/${APP_NAME}"
declare DEFAULT_LOGFILE="${SYSTEM_LOG_DIR}/${APP_NAME}.log"
declare LOGFILE="${DEFAULT_LOGFILE}"

declare LOG_FILE_READY=false

declare -r PACMAN_LOCK="/var/lib/pacman/db.lck"
declare ALL_SYSTEM=false
declare INTERACTIVE_MODE=false
declare DEBUG_MODE=false
declare YAY_AVAILABLE=false
declare FIX_KEYS=false      # Manual trigger for keyring fix protocol

declare -a DEFAULT_IGNORE_PKGS=("wayland")
declare -a CUSTOM_IGNORE_PKGS=()
declare -a CUSTOM_IGNORE_GROUPS=()
declare -a TARGET_PKGLIST=()
declare -A INSTALLED_PKGS
declare -A OFFICIAL_PKGS
declare -A AUR_PKGS
declare -A PACKAGE_GROUPS
declare TMP_DIR=""
declare -a last_missing=()

error_handler () 
{ 
    local last_command="${BASH_COMMAND}";
    local line_number="${LINENO}";
    local exit_status="$?";
    if [[ "${exit_status}" -eq 0 ]]; then
        return;
    fi;
    log_message "FATAL" "Script error on line ${line_number}: '${last_command}' exited with status ${exit_status}.";
    printf "FATAL: An unexpected error occurred. Check log file for details (requires sudo): %s\n" "${LOGFILE}" 1>&2;
    exit 1
}
trap error_handler ERR

cleanup () 
{ 
    if [[ -n "${TMP_DIR:-}" && -d "${TMP_DIR:-}" ]]; then
        log_message "INFO" "Cleaning up temporary directory: ${TMP_DIR}";
        if ! rm -rf -- "${TMP_DIR}"; then
            log_message "ERROR" "Failed to remove temporary directory: ${TMP_DIR}";
            printf "Error: Failed to remove temporary directory: %s\n" "${TMP_DIR}" 1>&2;
        fi;
    fi
}

trap cleanup EXIT

log_message() {
	local level="$1"
	local message="$2"
	local timestamp # Declared as local
    local color_tag=""

	# If debug mode is off and the message is a DEBUG message, return early without logging.
	if [[ "${DEBUG_MODE}" = false && "${level}" = "DEBUG" ]]; then
		return 0
	fi

    # Map level to color tag
    case "$level" in
        INFO) color_tag="$INFO" ;;
        WARN) color_tag="$WARN" ;;
        ERROR|FATAL) color_tag="$ERROR" ;;
        DEBUG) color_tag="$NOTE" ;;
        OK) color_tag="$OK" ;;
        *) color_tag="[$level]" ;;
    esac

	# Get current timestamp in YYYY-MM-DD HH:MM:SS format.
	timestamp="$(date '+%Y-%m-%d %H:%M:%S')"

	# If LOG_FILE_READY is true and LOGFILE is set, attempt to write to the file.
	# Otherwise, log to standard error (console).
	if [[ "${LOG_FILE_READY}" = true && -n "${LOGFILE:-}" ]]; then
		# Attempt to write to the log file (plain text). If it fails, fall back to stderr.
        # We strip ANSI codes for the log file if we were passing them, but here we are passing distinct vars.
        # For the log file, we keep the standard format [LEVEL].
		printf "%s [%s] %s\n" "${timestamp}" "${level}" "${message}" >>"${LOGFILE}" ||
			printf "%s %s %s (WARNING: Could not write to log file)\n" "${timestamp}" "${color_tag}" "${message}" >&2
        
        # Output to console with color
        printf "%s %s %s\n" "${timestamp}" "${color_tag}" "${message}" >&2
	else
		# If log file is not ready or not set, always log to stderr with color.
		printf "%s %s %s\n" "${timestamp}" "${color_tag}" "${message}" >&2
	fi
}

# Simple spinner function to provide visual feedback
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-'
    while ps -p "$pid" > /dev/null; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr" >&2
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b" >&2
    done
    printf "    \b\b\b\b" >&2
}

declare CMD_OUTPUT=""

run_command () 
{ 
    local output_file exit_code cmd_pid;
    output_file=$(mktemp -p "${TMP_DIR:-/tmp}" "cmd_output.XXXXXX");
    set +e;
    "$@" > "${output_file}" 2>&1 & cmd_pid=$!;
    show_spinner "$cmd_pid";
    wait "$cmd_pid"
    exit_code=$?
    set -e

    CMD_OUTPUT=$(tr -d '\0' <"${output_file}")
    rm -f "${output_file}"

    if [[ ${exit_code} -ne 0 ]]; then
        log_message "DEBUG" "Command failed with exit code ${exit_code}: $*";
        log_message "DEBUG" "Output was: ${CMD_OUTPUT}";
    fi;
    return "${exit_code}"
}

# Function to check if the script is run with root privileges.
# Attempts to escalate privileges via sudo if not run as root.
require_root() {
	if [[ "${EUID}" -ne 0 ]]; then
        echo "Re-running the script with sudo privileges..."
        if ! sudo "$0" "$@"; then
            echo "Failed to escalate privileges. Exiting..."
            exit 1
        fi
        exit 0
	fi
	log_message "INFO" "Root privileges confirmed."
}

prepare_log_dir () 
{ 
    local log_directory;
    log_directory="$(dirname "${LOGFILE}")";
    if [[ ! -d "${log_directory}" ]]; then
        log_message "INFO" "Creating log directory: ${log_directory}";
        if ! mkdir -p "${log_directory}"; then
            log_message "ERROR" "Cannot create log directory: ${log_directory}";
            printf "Error: Cannot create log directory: %s\n" "${log_directory}" 1>&2;
            exit 1;
        fi;
    fi;
    if ! touch "${LOGFILE}" > /dev/null 2>&1; then
        log_message "ERROR" "Cannot write to log file: ${LOGFILE}";
        printf "Error: Cannot write to log file: %s\n" "${LOGFILE}" 1>&2;
        exit 1;
    fi;
    LOG_FILE_READY=true;
    log_message "INFO" "Log file prepared: ${LOGFILE}"
}

check_requirements () 
{ 
    log_message "INFO" "Checking system requirements...";
    local tool;
    local -a essential_tools=("pacman");
    local -a optional_tools=();
    local -a missing_tools=();
    if command -v yay > /dev/null 2>&1; then
        optional_tools+=("yay");
        YAY_AVAILABLE=true;
        log_message "INFO" "'yay' found, AUR support enabled.";
    else
        YAY_AVAILABLE=false;
        log_message "INFO" "'yay' not found. AUR support will be limited to identification.";
    fi;
    for tool in "${essential_tools[@]}";
    do
        if ! command -v "${tool}" > /dev/null 2>&1; then
            missing_tools+=("${tool}");
        fi;
    done;
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        local missing_str="${missing_tools[*]}";
        log_message "ERROR" "Essential required tools missing: ${missing_str}";
        printf "Error: Essential required tools missing: %s\n" "${missing_str}" 1>&2;
        exit 1;
    fi;
    missing_tools=();
    for tool in "${optional_tools[@]}";
    do
        if ! command -v "${tool}" > /dev/null 2>&1; then
            missing_tools+=("${tool}");
        fi;
    done;
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        local missing_str="${missing_tools[*]}";
        log_message "WARN" "Optional tools missing: %s. Functionality may be limited." "${missing_str}";
        printf "Warning: Optional tools missing: %s. Functionality may be limited.\n" "${missing_str}" 1>&2;
    fi;
    log_message "INFO" "All essential required tools found."
}

# Waits for the pacman lock file to disappear, with a timeout.
# Smartly removes stale locks if pacman is not running.
wait_for_pacman_lock() {
	log_message "INFO" "Checking for pacman lock..."
	local wait_time=120 # Maximum time to wait in seconds.
	local interval=5    # Time to sleep between checks in seconds.
	local elapsed=0     # Time elapsed so far.

	# Loop while the lock file exists.
	while [[ -e "${PACMAN_LOCK}" ]]; do
		# Check if pacman is actually running
		if ! pgrep -x "pacman" >/dev/null; then
			log_message "WARN" "Pacman lock file found but no pacman process running. Removing stale lock."
			rm -f "${PACMAN_LOCK}"
			break
		fi

		# Check if the maximum wait time has been reached.
		if ((elapsed >= wait_time)); then
			log_message "ERROR" "pacman lock persists after ${wait_time} seconds."
			printf "Error: pacman lock persists after %d seconds. Remove lock with: sudo rm -f %s\n" "${wait_time}" "${PACMAN_LOCK}" >&2
			exit 1 # Exit if lock persists too long.
		fi
		log_message "INFO" "Waiting for pacman lock... (${elapsed}/${wait_time} sec elapsed)"
		sleep "${interval}"
		((elapsed += interval))
	done

	log_message "INFO" "Pacman lock is not present."
}

fix_pacman_keyring () 
{ 
    log_message "INFO" "Attempting to fix pacman keyring and database issues...";
    local success=0;
    log_message "INFO" "Updating archlinux-keyring...";
    if ! pacman -Sy archlinux-keyring --noconfirm 2>&1 | tee -a "${LOGFILE}"; then
        log_message "ERROR" "Failed to update archlinux-keyring.";
        printf "Error: Failed to update archlinux-keyring.\n" 1>&2;
        success=1;
    fi;
    log_message "INFO" "Cleaning pacman sync databases and gnupg directory...";
    if ! rm -f /var/lib/pacman/sync/*; then
        log_message "WARN" "Failed to remove sync databases.";
    fi;
    if ! rm -rf /etc/pacman.d/gnupg/*; then
        log_message "WARN" "Failed to remove gnupg contents.";
    fi;
    log_message "INFO" "Re-initializing pacman keyring...";
    if ! pacman-key --init 2>&1 | tee -a "${LOGFILE}"; then
        log_message "ERROR" "pacman-key --init failed.";
        printf "Error: pacman-key --init failed.\n" 1>&2;
        success=1;
    fi;
    log_message "INFO" "Populating pacman keyring...";
    if ! pacman-key --populate archlinux 2>&1 | tee -a "${LOGFILE}"; then
        log_message "ERROR" "pacman-key --populate failed.";
        printf "Error: pacman-key --populate failed.\n" 1>&2;
        success=1;
    else
        log_message "INFO" "pacman-key --populate successful.";
    fi;
    log_message "INFO" "Refreshing pacman keys from servers...";
    if ! pacman-key --refresh-keys 2>&1 | tee -a "${LOGFILE}"; then
        log_message "WARN" "pacman-key --refresh-keys failed. This might indicate network issues or key server problems.";
    fi;
    log_message "INFO" "Attempting pacman database refresh again...";
    if ! pacman -Syy --noconfirm 2>&1 | tee -a "${LOGFILE}"; then
        log_message "ERROR" "Pacman database refresh still failing after keyring fix.";
        printf "Error: Pacman database refresh still failing after keyring fix.\n" 1>&2;
        success=1;
    else
        log_message "INFO" "Pacman database refresh successful after keyring fix.";
    fi;
    return "${success}"
}

refresh_pacman_databases () 
{ 
    local db_refresh_successful=false;
    log_message "INFO" "Refreshing pacman database (pacman -Syy)...";
	# Attempt database refresh. Use tee to show progress to console while logging.
	if pacman -Syy --noconfirm 2>&1 | tee -a "${LOGFILE}"; then
		log_message "INFO" "Pacman database refreshed successfully."
		db_refresh_successful=true
	else
		log_message "ERROR" "Failed to refresh pacman database."
		printf "Error: Failed to refresh pacman database.\n" >&2
		
		if [[ "$FIX_KEYS" = true ]]; then
			printf "\nWARNING: Emergency keyring repair protocol (-f) activated.\n" >&2
			printf "This will delete and regenerate your pacman keys (4ndr0keyfix). This is a destructive operation.\n" >&2
			printf "Are you absolutely sure you want to proceed? (y/N): " >&2
			read -r confirm
			if [[ "$confirm" =~ ^[Yy]$ ]]; then
				log_message "INFO" "User confirmed keyring repair protocol."
				# Attempt to fix keyring issues.
				if fix_pacman_keyring; then # fix_pacman_keyring returns 0 on success
					log_message "INFO" "Re-attempting pacman database refresh after keyring fix..."
					if pacman -Syy --noconfirm 2>&1 | tee -a "${LOGFILE}"; then
						log_message "INFO" "Pacman database refreshed successfully after re-attempt."
						db_refresh_successful=true
					else
						log_message "ERROR" "Pacman database refresh failed again after keyring fix."
						printf "Error: Pacman database refresh failed again after keyring fix.\n" >&2
					fi
				else
					log_message "ERROR" "Keyring fix failed. Cannot proceed without database refresh."
					printf "Error: Keyring fix failed. Cannot proceed without database refresh.\n" >&2
				fi
			else
				log_message "INFO" "Keyring repair aborted by user."
				printf "Aborted.\n" >&2
			fi
		else
			printf "Tip: If you are experiencing keyring issues, run this script with '-f' to enable the manual keyring repair protocol.\n" >&2
		fi
	fi
    if [[ "${db_refresh_successful}" = true ]]; then
        log_message "INFO" "Verifying pacman database integrity by querying essential package 'filesystem' (pacman -Si filesystem)...";
        if ! pacman -Si filesystem > /dev/null 2>&1; then
            log_message "FATAL" "Failed to retrieve 'filesystem' package info (pacman -Si filesystem). This indicates a severe database issue despite -Syy success. Check /etc/pacman.conf, mirrorlist, and network connectivity.";
            printf "FATAL: Pacman database appears empty or corrupted after refresh (failed to query 'filesystem'). Cannot proceed. Check /etc/pacman.conf, mirrorlist, and network connectivity.\n" 1>&2;
            exit 1;
        fi;
        log_message "INFO" "Pacman database integrity verified: 'filesystem' package info retrieved successfully.";
    else
        log_message "FATAL" "Unable to achieve a successful pacman database refresh. Exiting.";
        printf "FATAL: Unable to achieve a successful pacman database refresh. Exiting.\n" 1>&2;
        exit 1;
    fi
}

cache_package_lists () 
{ 
    log_message "INFO" "Caching package lists...";
    INSTALLED_PKGS=();
    OFFICIAL_PKGS=();
    AUR_PKGS=();
    log_message "INFO" "Caching installed packages (pacman -Qq)...";
    if ! run_command pacman -Qq; then
        log_message "FATAL" "pacman -Qq command failed. Cannot determine installed packages.";
        printf "FATAL: Failed to get list of installed packages. Check pacman configuration.\n" 1>&2;
        exit 1;
    fi;
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && INSTALLED_PKGS["$pkg"]=1;
    done <<< "$CMD_OUTPUT";
    log_message "INFO" "Cached ${#INSTALLED_PKGS[@]} installed packages.";
    if [[ ${#INSTALLED_PKGS[@]} -eq 0 ]]; then
        log_message "FATAL" "No installed packages found. This indicates a severe pacman issue or an empty system. Cannot proceed.";
        printf "FATAL: No installed packages found. This indicates a severe pacman issue or an empty system. Cannot proceed.\n" 1>&2;
        exit 1;
    fi;
    log_message "INFO" "Caching official packages (pacman -Slq)...";
    if ! run_command pacman -Slq; then
        log_message "FATAL" "pacman -Slq command failed. Cannot determine official packages.";
        printf "FATAL: Failed to get list of official packages. Check pacman database and mirrorlists.\n" 1>&2;
        exit 1;
    fi;
    log_message "DEBUG" "Raw output from pacman -Slq (first 10 lines):";
    log_message "DEBUG" "$(head -n 10 <<< "$CMD_OUTPUT")";
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && OFFICIAL_PKGS["$pkg"]=1;
    done <<< "$CMD_OUTPUT";
    log_message "INFO" "Cached ${#OFFICIAL_PKGS[@]} official packages.";
    if [[ ${#OFFICIAL_PKGS[@]} -eq 0 ]]; then
        log_message "FATAL" "No official packages found. This indicates a severe pacman database issue. Cannot proceed.";
        printf "FATAL: No official packages found. This indicates a severe pacman database issue. Cannot proceed.\n" 1>&2;
        exit 1;
    fi;
    if [[ "$YAY_AVAILABLE" = true ]]; then
        log_message "INFO" "Caching AUR packages (yay -Slqa)...";
        if ! run_command yay -Slqa; then
            log_message "WARN" "yay -Slqa command failed. AUR dependency resolution might be incomplete.";
            printf "Warning: Failed to cache AUR packages (yay -Slqa). AUR dependency resolution might be incomplete.\n" 1>&2;
        fi;
        while IFS= read -r pkg; do
            [[ -n "$pkg" ]] && AUR_PKGS["$pkg"]=1;
        done <<< "$CMD_OUTPUT";
        log_message "INFO" "Cached ${#AUR_PKGS[@]} AUR packages.";
    else
        log_message "INFO" "'yay' not found. Skipping AUR package caching.";
    fi
}

cache_package_groups () 
{ 
    log_message "INFO" "Caching package group information...";
    PACKAGE_GROUPS=();
    local pkg groups line;
    if ! run_command pacman -Qi; then
        log_message "WARN" "pacman -Qi command failed. This may indicate a corrupted pacman database. Group-based ignore functionality will be disabled.";
        printf "WARNING: pacman -Qi failed. Cannot retrieve package group info. Group-based ignore functionality will be disabled.\n" 1>&2;
        return;
    fi;
    if [[ -z "$CMD_OUTPUT" ]]; then
        log_message "WARN" "pacman -Qi produced no output. Group-based ignore functionality will be disabled.";
        printf "WARNING: pacman -Qi produced no output. Group-based ignore functionality will be disabled.\n" 1>&2;
        return;
    fi;
    printf "%s" "$CMD_OUTPUT" | tr -d '\0' | awk '
        /^Name[[:space:]]+:/ {
            current_pkg = $0
            sub(/^Name[[:space:]]+:/, "", current_pkg)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", current_pkg)
            current_groups = ""
        }

        /^Groups[[:space:]]+:/ {
            current_groups = $0
            sub(/^Groups[[:space:]]+:/, "", current_groups)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", current_groups)
            if (current_pkg != "") {
                print current_pkg, current_groups
            }
            current_pkg = ""
            current_groups = ""
        }
    ' | while IFS= read -r line; do
        pkg="${line%% *}";
        groups="${line#* }";
        [[ -n "$pkg" ]] && PACKAGE_GROUPS["$pkg"]="$groups";
    done;
    if [[ ${#PACKAGE_GROUPS[@]} -eq 0 ]]; then
        log_message "WARN" "No package group information cached. This might be normal if no installed packages have groups, or indicates a pacman -Qi parsing issue.";
    else
        log_message "INFO" "Cached group information for ${#PACKAGE_GROUPS[@]} packages.";
    fi
}

prompt_ignore_lists () 
{ 
    log_message "INFO" "Prompting for interactive ignore lists...";
    local selected_pkgs selected_groups all_groups user_pkgs user_groups;
    local -a tmp_pkgs tmp_groups;
    local old_ifs;
    if command -v fzf > /dev/null 2>&1 && [[ -t 0 ]]; then
        printf -- "--- Interactive Ignore Selection ---\n" 1>&2;
        printf "Select packages to ignore (TAB to mark, ENTER when done):\n" 1>&2;
        selected_pkgs=$(printf "%s\n" "${!INSTALLED_PKGS[@]}" | sort | fzf --multi --prompt="Ignore Package: " --header="Select packages to ignore" 2> /dev/null);
        if [[ -n "$selected_pkgs" ]]; then
            log_message "INFO" "User selected packages to ignore via fzf.";
            mapfile -t tmp_pkgs <<< "$selected_pkgs";
            CUSTOM_IGNORE_PKGS+=("${tmp_pkgs[@]}");
        else
            log_message "INFO" "No packages selected to ignore via fzf.";
        fi;
        printf "Select groups to ignore (TAB to mark, ENTER when done):\n" 1>&2;
        all_groups=$(for g in "${PACKAGE_GROUPS[@]}";
do
    [[ -n "$g" ]] && printf "%s\n" "$g";
done | tr ' ' '\n' | sort -u);
        selected_groups=$(printf "%s\n" "$all_groups" | fzf --multi --prompt="Ignore Group: " --header="Select groups to ignore" 2> /dev/null);
        if [[ -n "$selected_groups" ]]; then
            log_message "INFO" "User selected groups to ignore via fzf.";
            mapfile -t tmp_groups <<< "$selected_groups";
            CUSTOM_IGNORE_GROUPS+=("${tmp_groups[@]}");
        else
            log_message "INFO" "No groups selected to ignore via fzf.";
        fi;
        printf -- "------------------------------------\n" 1>&2;
    else
        log_message "INFO" "fzf not available or not interactive. Using fallback prompts.";
        local current_ignored_pkgs_str;
        if [[ ${#DEFAULT_IGNORE_PKGS[@]} -eq 0 && ${#CUSTOM_IGNORE_PKGS[@]} -eq 0 ]]; then
            current_ignored_pkgs_str="none";
        else
            printf -v current_ignored_pkgs_str '%s,' "${DEFAULT_IGNORE_PKGS[@]:-}" "${CUSTOM_IGNORE_PKGS[@]:-}";
            current_ignored_pkgs_str=${current_ignored_pkgs_str%,};
        fi;
        printf "Enter additional packages to ignore (comma-separated) [%s]: " "$current_ignored_pkgs_str" 1>&2;
        read -r user_pkgs;
        if [[ -n "$user_pkgs" ]]; then
            log_message "INFO" "User entered packages to ignore via fallback: $user_pkgs";
            old_ifs="$IFS";
            IFS=',' read -r -a tmp_pkgs <<< "$user_pkgs";
            IFS="$old_ifs";
            for pkg in "${tmp_pkgs[@]}";
            do
                [[ -n "$pkg" ]] && CUSTOM_IGNORE_PKGS+=("$pkg");
            done;
        fi;
        local current_ignored_groups_str;
        if [[ ${#CUSTOM_IGNORE_GROUPS[@]} -eq 0 ]]; then
            current_ignored_groups_str="none";
        else
            printf -v current_ignored_groups_str '%s,' "${CUSTOM_IGNORE_GROUPS[@]:-}";
            current_ignored_groups_str=${current_ignored_groups_str%,};
        fi;
        printf "Enter additional groups to ignore (comma-separated) [%s]: " "$current_ignored_groups_str" 1>&2;
        read -r user_groups;
        if [[ -n "$user_groups" ]]; then
            log_message "INFO" "User entered groups to ignore via fallback: $user_groups";
            old_ifs="$IFS";
            IFS=',' read -r -a tmp_groups <<< "$user_groups";
            IFS="$old_ifs";
            for group in "${tmp_groups[@]}";
            do
                [[ -n "$group" ]] && CUSTOM_IGNORE_GROUPS+=("$group");
            done;
        fi;
    fi;
    log_message "INFO" "Interactive ignore lists processed."
}

is_ignored () 
{ 
    local pkg="$1";
    local ignore_item pkg_groups;
    for ignore_item in "${DEFAULT_IGNORE_PKGS[@]:-}" "${CUSTOM_IGNORE_PKGS[@]:-}";
    do
        if [[ -n "$ignore_item" && "$pkg" == "$ignore_item" ]]; then
            log_message "DEBUG" "Package '$pkg' ignored (explicitly listed as '$ignore_item').";
            return 0;
        fi;
    done;
    pkg_groups="${PACKAGE_GROUPS[$pkg]:-}";
    if [[ -n "$pkg_groups" && ${#CUSTOM_IGNORE_GROUPS[@]} -gt 0 ]]; then
        for ignore_item in "${CUSTOM_IGNORE_GROUPS[@]:-}";
        do
            if [[ " ${pkg_groups} " =~ (^|[[:space:]])${ignore_item}([[:space:]]|$) ]]; then
                log_message "DEBUG" "Package '$pkg' ignored (belongs to ignored group '$ignore_item').";
                return 0;
            fi;
        done;
    fi;
    log_message "DEBUG" "Package '$pkg' is not ignored.";
    return 1
}

compute_missing_dependencies () 
{ 
    local -a target_pkgs=("$@");
    local -a missing=();
    local -A missing_set=();
    local line dep_name;
    local pacman_output_file="${TMP_DIR}/pacman_output.txt";
    log_message "INFO" "Checking for missing dependencies in ${#target_pkgs[@]} packages using 'pacman -Qkk'.";
    set +e;
    pacman -Qkk "${target_pkgs[@]}" > "$pacman_output_file" 2>&1 & local cmd_pid=$!;
    show_spinner "$cmd_pid";
    wait "$cmd_pid";
    local exit_code=$?;
    set -e;
    if [[ $exit_code -ne 0 ]]; then
        :;
    fi;
    while IFS= read -r line; do
        if [[ "$line" =~ 'is a missing dependency' ]]; then
            dep_name=$(echo "$line" | sed -n "s/.*'\([^']*\)'.*/\1/p");
            if [[ -n "$dep_name" ]]; then
                if ! is_ignored "$dep_name"; then
                    log_message "DEBUG" "Dependency '$dep_name' is missing and not ignored.";
                    missing_set["$dep_name"]=1;
                else
                    log_message "DEBUG" "Dependency '$dep_name' is missing but ignored.";
                fi;
            fi;
        fi;
    done < "$pacman_output_file";
    if [[ ${#missing_set[@]} -gt 0 ]]; then
        mapfile -t missing < <(printf "%s\n" "${!missing_set[@]}" | sort);
        log_message "INFO" "Found ${#missing[@]} missing dependencies.";
        printf "%s\n" "${missing[@]}";
    else
        log_message "INFO" "No missing dependencies found.";
    fi;
    return 0
}

# Checks if there is sufficient disk space on the root partition.
# Returns 0 if space is sufficient (>= 1GB), 1 otherwise.
check_disk_space() {
    local required_space_kb=1048576 # 1GB in KB
    local available_space_kb

    # Get available space on / in KB
    available_space_kb=$(df --output=avail / | tail -n 1)

    if [[ "$available_space_kb" -lt "$required_space_kb" ]]; then
        log_message "ERROR" "Insufficient disk space on /. Available: $((available_space_kb / 1024))MB, Required: $((required_space_kb / 1024))MB."
        printf "Error: Insufficient disk space. Operation aborted.\n" >&2
        return 1
    fi
    
    log_message "INFO" "Disk space check passed. Available: $((available_space_kb / 1024))MB."
    return 0
}

install_dependencies () 
{ 
    local -a deps_to_install=("$@");
    local -a official_deps=();
    local -a aur_deps=();
    local dep success=0 confirm;
    
    if ! check_disk_space; then
        return 1
    fi

    if [[ ${#deps_to_install[@]} -eq 0 ]]; then
        log_message "INFO" "No dependencies to install.";
        return 0;
    fi;
    log_message "INFO" "Preparing to install ${#deps_to_install[@]} dependencies.";
    for dep in "${deps_to_install[@]}";
    do
        [[ -z "$dep" ]] && continue;
        if [[ -n "${OFFICIAL_PKGS[$dep]:-}" ]]; then
            official_deps+=("$dep");
        else
            if [[ -n "${AUR_PKGS[$dep]:-}" ]]; then
                aur_deps+=("$dep");
            else
                log_message "WARN" "Dependency '$dep' not found in official repos or AUR cache. Skipping installation attempt.";
                printf "Warning: Dependency '%s' not found in official or AUR repositories. Cannot install.\n" "$dep" 1>&2;
            fi;
        fi;
    done;
    	if [[ ${#official_deps[@]} -gt 0 ]]; then
    		printf "${SKY_BLUE}Official dependencies to install:${RESET}\n" >&2
    		for dep in "${official_deps[@]}"; do
    			printf "  %s\n" "$dep" >&2
    		done
    		if [[ "$INTERACTIVE_MODE" = true ]]; then
    			printf "${YELLOW}Proceed to install official dependencies? (y/N): ${RESET}" >&2
    			read -r confirm
    			if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    				log_message "INFO" "User declined installation of official dependencies."
    				official_deps=()
    			fi
    		fi
    
    		if [[ ${#official_deps[@]} -gt 0 ]]; then
    			log_message "INFO" "Installing official dependencies: ${official_deps[*]}"
    			if ! pacman -S --needed --noconfirm "${official_deps[@]}" 2>&1 | tee -a "${LOGFILE}"; then
    				log_message "ERROR" "Failed to install official dependencies: ${official_deps[*]}"
    				printf "${ERROR}Error: Failed to install official dependencies.${RESET}\n" >&2
    				success=1
    			else
    				log_message "INFO" "Official dependencies installed successfully."
    			fi
    		fi
    	fi
    
    	if [[ ${#aur_deps[@]} -gt 0 ]]; then
    		printf "${MAGENTA}AUR dependencies to install:${RESET}\n" >&2
    		for dep in "${aur_deps[@]}"; do
    			printf "  %s\n" "$dep" >&2
    		done
    		if [[ "$YAY_AVAILABLE" = true ]]; then
    			if [[ "$INTERACTIVE_MODE" = true ]]; then
    				printf "${YELLOW}Proceed to install AUR dependencies? (y/N): ${RESET}" >&2
    				read -r confirm
    				if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    					log_message "INFO" "User declined installation of AUR dependencies."
    					aur_deps=()
    				fi
    			fi
    
    			if [[ ${#aur_deps[@]} -gt 0 ]]; then
    				log_message "INFO" "Installing AUR dependencies: ${aur_deps[*]}"
    				if ! yay -S --needed --noconfirm "${aur_deps[@]}" 2>&1 | tee -a "${LOGFILE}"; then
    					log_message "ERROR" "Failed to install AUR dependencies: ${aur_deps[*]}"
    					printf "${ERROR}Error: Failed to install AUR dependencies.${RESET}\n" >&2
    					success=1
    				else
    					log_message "INFO" "AUR dependencies installed successfully."
    				fi
    			fi
    		else
    			log_message "WARN" "'yay' not found. Cannot install AUR dependencies: ${aur_deps[*]}"
    			printf "${WARN}Warning: 'yay' not found. Cannot install AUR dependencies: %s${RESET}\n" "${aur_deps[*]}" >&2
    			success=1
    		fi
    	fi
    return "$success"
}

process_dependency_closure () 
{ 
    log_message "INFO" "Starting dependency closure process.";
    local iteration=1;
    local max_iterations=15;
    local -a current_targets missing_deps=();
    if [[ "$ALL_SYSTEM" = true ]]; then
        log_message "INFO" "Checking dependencies for all installed system packages.";
        mapfile -t current_targets < <(printf "%s\n" "${!INSTALLED_PKGS[@]}" | sort);
    else
        if [[ ${#TARGET_PKGLIST[@]} -gt 0 ]]; then
            log_message "INFO" "Checking dependencies for specified target packages: ${TARGET_PKGLIST[*]}";
            current_targets=("${TARGET_PKGLIST[@]}");
        fi;
    fi;
    last_missing=();
    while ((iteration <= max_iterations)); do
        log_message "INFO" "Dependency closure iteration $iteration.";
        log_message "DEBUG" "Targets for iteration $iteration: ${current_targets[*]:-none}";
        if [[ ${#current_targets[@]} -eq 0 ]]; then
            log_message "INFO" "No targets for iteration $iteration. Stopping closure process.";
            break;
        fi;
        if ! mapfile -t missing_deps < <(compute_missing_dependencies "${current_targets[@]}"); then
            log_message "ERROR" "Failed to compute missing dependencies in iteration $iteration. Stopping closure.";
            printf "Error: Failed to compute missing dependencies in iteration %d. Stopping closure.\n" "$iteration" 1>&2;
            exit 1;
        fi;
        if [[ ${#missing_deps[@]} -eq 0 ]]; then
            log_message "INFO" "No new missing dependencies found in iteration $iteration. Closure reached.";
            last_missing=();
            break;
        fi;
        last_missing=("${missing_deps[@]}");
        log_message "INFO" "Found ${#missing_deps[@]} missing dependencies in iteration $iteration.";
        log_message "DEBUG" "Missing dependencies: ${missing_deps[*]}";
        if ! install_dependencies "${missing_deps[@]}"; then
            log_message "ERROR" "Installation of dependencies failed in iteration $iteration. Stopping closure process.";
            break;
        fi;
        log_message "INFO" "Re-caching package lists after installation.";
        cache_package_lists;
        current_targets=("${missing_deps[@]}");
        ((iteration++));
    done;
    if ((iteration > max_iterations)); then
        log_message "WARN" "Maximum iterations (${max_iterations}) reached. Dependency closure may not be complete.";
        printf "Warning: Maximum iterations (%d) reached. Dependency closure may not be complete.\n" "$max_iterations" 1>&2;
    fi;
    log_message "INFO" "Dependency closure process finished."
}

parse_arguments() {
	log_message "INFO" "Parsing arguments: $*"
    
    # Handle --help manually as getopts doesn't support long options
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        print_help
        exit 0
    fi

	local opt packages_arg="" groups_arg=""
	local -a tmp_pkgs tmp_groups
	local old_ifs # Declare old_ifs as local to prevent global side effects
	OPTIND=1

	while getopts ":aik:g:l:hdf" opt; do
        case "$opt" in 
            a)
                ALL_SYSTEM=true;
                log_message "INFO" "Option -a (ALL_SYSTEM) set."
            ;;
            i)
                INTERACTIVE_MODE=true;
                log_message "INFO" "Option -i (INTERACTIVE_MODE) set."
            ;;
			f)
				FIX_KEYS=true
				log_message "INFO" "Option -f (FIX_KEYS) set. Keyring repair protocol enabled."
			;;
            k)
                packages_arg="$OPTARG";
                log_message "INFO" "Option -k (ignore packages) argument: '$packages_arg'."
            ;;
            g)
                groups_arg="$OPTARG";
                log_message "INFO" "Option -g (ignore groups) argument: '$groups_arg'."
            ;;
            l)
                LOGFILE="$OPTARG";
                log_message "INFO" "Option -l (logfile) argument: '$LOGFILE'."
            ;;
            d)
                DEBUG_MODE=true;
                log_message "INFO" "INFO: Debug mode enabled."
            ;;
            h)
                print_help;
                exit 0
            ;;
            \?)
                log_message "ERROR" "Invalid option: -$OPTARG";
                printf "Error: Invalid option: -%s\n" "$OPTARG" 1>&2;
                print_help 1>&2;
                exit 1
            ;;
            :)
                log_message "ERROR" "Option -$OPTARG requires an argument.";
                printf "Error: Option -%s requires an argument.\n" "$OPTARG" 1>&2;
                print_help 1>&2;
                exit 1
            ;;
        esac;
    done;
    shift $((OPTIND - 1));
    if [[ -n "$packages_arg" ]]; then
        old_ifs="$IFS";
        IFS=',' read -r -a tmp_pkgs <<< "$packages_arg";
        IFS="$old_ifs";
        for pkg in "${tmp_pkgs[@]}";
        do
            [[ -n "$pkg" ]] && CUSTOM_IGNORE_PKGS+=("$pkg");
        done;
        log_message "INFO" "CUSTOM_IGNORE_PKGS from args: ${CUSTOM_IGNORE_PKGS[*]:-none}";
    fi;
    if [[ -n "$groups_arg" ]]; then
        old_ifs="$IFS";
        IFS=',' read -r -a tmp_groups <<< "$groups_arg";
        IFS="$old_ifs";
        for group in "${tmp_groups[@]}";
        do
            [[ -n "$group" ]] && CUSTOM_IGNORE_GROUPS+=("$group");
        done;
        log_message "INFO" "CUSTOM_IGNORE_GROUPS from args: ${CUSTOM_IGNORE_GROUPS[*]:-none}";
    fi;
    if [[ "$#" -gt 0 ]]; then
        TARGET_PKGLIST=("$@");
        ALL_SYSTEM=false;
        log_message "INFO" "Target packages from args: ${TARGET_PKGLIST[*]}";
    fi;
    log_message "INFO" "Argument parsing complete."
}

print_help () 
{ 
    cat <<EOF
Usage: ${0##*/} [OPTIONS] [package1 package2 ...]
Checks for missing dependencies of installed packages on Arch Linux.

Options:
  -a             Check dependencies for ALL system packages (default if no packages specified).
  -i             Interactive mode: Prompt before installing dependencies.
  -k <pkgs>      Comma-separated list of packages to ALWAYS ignore (e.g., "pkg1,pkg2").
  -g <groups>    Comma-separated list of package groups to ALWAYS ignore.
  -l <logfile>   Specify a custom log file path. Defaults to ${SYSTEM_LOG_DIR}/${APP_NAME}.log.
  -f             Enable manual keyring repair protocol (4ndr0keyfix). Use with caution.
  -d             Enable debug logging.
  -h             Show this help message and exit.

Examples:
  sudo ${0##*/}                             # Check dependencies for all installed packages
  sudo ${0##*/} package-a package-b         # Check dependencies for package-a and package-b
  sudo ${0##*/} -a -k "pkg-manual,pkg-git"  # Check all packages, ignoring pkg-manual and pkg-git
  sudo ${0##*/} -i package-c                # Check package-c, prompt before installing deps
  sudo ${0##*/} -d -l /tmp/debug.log        # Run with debug logging to a custom file
EOF

}

main () 
{ 
    parse_arguments "$@";
    require_root "$@";

    # If no work is specified (no -a and no package list), show usage and exit.
    if [[ "$ALL_SYSTEM" = false && ${#TARGET_PKGLIST[@]} -eq 0 ]]; then
        print_help
        exit 1
    fi

    prepare_log_dir;
    TMP_DIR="$(mktemp -d -t "${APP_NAME}-XXXXXX")";
    if [[ $? -ne 0 || -z "${TMP_DIR:-}" || ! -d "${TMP_DIR:-}" ]]; then
        log_message "ERROR" "Failed to create temporary directory.";
        printf "Error: Failed to create temporary directory.\n" 1>&2;
        exit 1;
    fi;
    log_message "INFO" "Created temporary directory: ${TMP_DIR}";
    check_requirements;
    wait_for_pacman_lock;
    refresh_pacman_databases;
    log_message "INFO" "Caching package lists for initial operations and dependency check.";
    cache_package_lists;
    log_message "INFO" "Caching package groups for ignore logic.";
    cache_package_groups;
    if [[ "$INTERACTIVE_MODE" = true ]]; then
        prompt_ignore_lists;
    fi;
    log_message "INFO" "Starting dependency checker (Log: ${LOGFILE})...";
    log_message "INFO" "ALL_SYSTEM: ${ALL_SYSTEM}, INTERACTIVE_MODE: ${INTERACTIVE_MODE}, DEBUG_MODE: ${DEBUG_MODE}";
    local ignored_pkgs_str ignored_groups_str;
    printf -v ignored_pkgs_str '%s,' "${DEFAULT_IGNORE_PKGS[@]:-}" "${CUSTOM_IGNORE_PKGS[@]:-}";
    ignored_pkgs_str=${ignored_pkgs_str%,};
    log_message "INFO" "Ignore Packages: ${ignored_pkgs_str:-none}";
    printf -v ignored_groups_str '%s,' "${CUSTOM_IGNORE_GROUPS[@]:-}";
    ignored_groups_str=${ignored_groups_str%,};
    log_message "INFO" "Ignore Groups: ${ignored_groups_str:-none}";
    if [[ "$ALL_SYSTEM" = false && ${#TARGET_PKGLIST[@]} -gt 0 ]]; then
        log_message "INFO" "Target Packages: ${TARGET_PKGLIST[*]}";
    fi;
    process_dependency_closure;
    log_message "INFO" "Generating final report."
    declare -a final_missing=("${last_missing[@]}")

    printf "\n${GREEN}## Dependency Check Summary ##${RESET}\n"
    if [[ ${#final_missing[@]} -gt 0 ]]; then
        printf "${WARN}Found %d unresolved missing dependencies:${RESET}\n" "${#final_missing[@]}"
        for dep in "${final_missing[@]}"; do
            printf " ${WARN}- %s${RESET}\n" "$dep"
        done
        printf "\n"

        local needs_yay_for_install=false
        local -a official_only=() aur_only=() unknown_only=()

        for dep in "${final_missing[@]}"; do
            if [[ -n "${OFFICIAL_PKGS[$dep]:-}" ]]; then
                official_only+=("$dep")
            elif [[ -n "${AUR_PKGS[$dep]:-}" ]]; then
                aur_only+=("$dep")
                needs_yay_for_install=true
            else
                log_message "WARN" "Final missing dependency '$dep' not found in official or AUR caches. Cannot suggest installation method."
                printf "${WARN}Warning: Dependency '%s' not found in official or AUR repositories.${RESET}\n" "$dep" >&2
                unknown_only+=("$dep")
            fi
        done

        if [[ ${#official_only[@]} -gt 0 ]]; then
            printf "${SKY_BLUE}Official dependencies:${RESET}\n"
            for dep in "${official_only[@]}"; do
                printf "  %s\n" "$dep"
            done
        fi
        if [[ ${#aur_only[@]} -gt 0 ]]; then
            printf "${MAGENTA}AUR dependencies:${RESET}\n"
            for dep in "${aur_only[@]}"; do
                printf "  %s\n" "$dep"
            done
        fi
        if [[ ${#unknown_only[@]} -gt 0 ]]; then
            printf "${WARN}Unknown dependencies (not found in official/AUR caches):${RESET}\n"
            for dep in "${unknown_only[@]}"; do
                printf "  %s\n" "$dep"
            done
        fi
        printf "\n"

        if [[ "$needs_yay_for_install" = true && "$YAY_AVAILABLE" = true ]]; then
            printf "${GREEN}To install all found missing dependencies (official and AUR):${RESET}\n"
            local install_cmd="yay -S --needed"
            for dep in "${final_missing[@]}"; do
                install_cmd+=" '$dep'"
            done
            printf "  ${CAT}%s${RESET}\n" "$install_cmd"
        elif [[ "$needs_yay_for_install" = true && "$YAY_AVAILABLE" = false ]]; then
            printf "${WARN}Warning: 'yay' is required to install some dependencies, but it was not found.${RESET}\n" >&2
            if [[ ${#official_only[@]} -gt 0 ]]; then
                printf "${GREEN}To install official dependencies:${RESET}\n"
                local install_cmd="sudo pacman -S --needed"
                for dep in "${official_only[@]}"; do
                    install_cmd+=" '$dep'"
                done
                printf "  ${CAT}%s${RESET}\n" "$install_cmd"
            fi
        else
            if [[ ${#official_only[@]} -gt 0 ]]; then
                printf "${GREEN}To install official dependencies:${RESET}\n"
                local install_cmd="sudo pacman -S --needed"
                for dep in "${official_only[@]}"; do
                    install_cmd+=" '$dep'"
                done
                printf "  ${CAT}%s${RESET}\n" "$install_cmd"
            fi
        fi

    else
        printf "${OK}All dependencies satisfiedâ€”no further action needed!${RESET}\n"
    fi;
    log_message "INFO" "Script finished successfully."
}

main "$@"

