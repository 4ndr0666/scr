#!/usr/bin/env bash
# File: optimize_nvm.sh
# Author: 4ndr0666
# Description: Standalone NVM environment optimization, potentially duplicative
# of "optimize_node.sh" logic.

set -euo pipefail
IFS=$'\n\t'

CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

LOG_FILE="${LOG_FILE:-$HOME/.cache/4ndr0service/logs/service_optimization.log}"
mkdir -p "$(dirname "$LOG_FILE")" || {
    echo "Failed to create log directory for optimize_nvm."
    exit 1
}

log() {
    local msg="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $msg" >> "$LOG_FILE"
}

handle_error() {
    local e_msg="$1"
    echo -e "${RED}âŒ Error: $e_msg${NC}" >&2
    log "ERROR: $e_msg"
    exit 1
}

remove_npmrc_prefix_conflict() {
    local npmrcfile="$HOME/.npmrc"
    if [[ -f "$npmrcfile" ]] && grep -Eq '^(prefix|globalconfig)=' "$npmrcfile"; then
        echo -e "${YELLOW}Detected prefix/globalconfig in ~/.npmrc => removing for NVM compatibility.${NC}"
        sed -i '/^\(prefix\|globalconfig\)=/d' "$npmrcfile" || handle_error "Failed removing prefix/globalconfig from ~/.npmrc."
        log "Removed prefix/globalconfig from ~/.npmrc for NVM compatibility."
    fi
}

install_nvm_for_nvm_service() {
    echo "ðŸ“¦ Installing NVM..."
    if command -v curl &>/dev/null; then
        LATEST_NVM_VERSION=$(curl -s https://api.github.com/repos/nvm-sh/nvm/releases/latest | jq -r '.tag_name')
        curl -o- "https://raw.githubusercontent.com/nvm-sh/nvm/${LATEST_NVM_VERSION}/install.sh" | bash || handle_error "Failed to install NVM (curl)."
    elif command -v wget &>/dev/null; then
        LATEST_NVM_VERSION=$(wget -qO- https://api.github.com/repos/nvm-sh/nvm/releases/latest | jq -r '.tag_name')
        wget -qO- "https://raw.githubusercontent.com/nvm-sh/nvm/${LATEST_NVM_VERSION}/install.sh" | bash || handle_error "Failed to install NVM (wget)."
    else
        handle_error "No curl or wget => cannot install NVM."
    fi

    export NVM_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/nvm"
    mkdir -p "$NVM_DIR" || handle_error "Failed to create NVM directory."

    if [[ -d "$HOME/.nvm" && "$HOME/.nvm" != "$NVM_DIR" ]]; then
        mv "$HOME/.nvm" "$NVM_DIR" || handle_error "Failed moving ~/.nvm => $NVM_DIR."
    fi

    export PROVIDED_VERSION=""  # Fix unbound variable in older nvm

    set +u
    [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" || handle_error "Failed to source nvm.sh post-install."
    [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion" || handle_error "Failed to source nvm bash_completion."
    set -u

    if command -v nvm &>/dev/null; then
        echo -e "${GREEN}âœ… NVM installed successfully.${NC}"
        log "NVM installed successfully."
    else
        handle_error "NVM missing after installation attempt."
    fi
}

optimize_nvm_service() {
    echo "ðŸ”§ Optimizing NVM environment..."

    remove_npmrc_prefix_conflict

    if command -v nvm &>/dev/null; then
        echo -e "${GREEN}âœ… NVM is already installed.${NC}"
        log "NVM is already installed."
    else
        echo "NVM not installed. Installing..."
        install_nvm_for_nvm_service
    fi

    export NVM_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/nvm"
    export PROVIDED_VERSION=""

    set +u
    [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" || handle_error "Failed to source NVM script for usage."
    set -u

    echo "ðŸ”„ Installing latest LTS Node.js via NVM..."
    echo "Installing latest LTS version..."
    if nvm install --lts; then
        echo -e "${GREEN}âœ… Latest LTS Node installed.${NC}"
        log "Latest LTS Node installed via NVM."
    else
        echo -e "${YELLOW}âš  Warning: nvm install --lts failed.${NC}"
        log "nvm install --lts failed."
    fi

    if nvm use --lts; then
        echo -e "${GREEN}âœ… Using latest LTS Node.${NC}"
        log "Using latest LTS Node."
    else
        echo -e "${YELLOW}âš  Warning: nvm use --lts failed.${NC}"
        log "Failed nvm use --lts."
    fi

    if nvm alias default 'lts/*'; then
        echo -e "${GREEN}âœ… LTS Node set as default alias in NVM.${NC}"
        log "Set default => lts/* in NVM."
    else
        echo -e "${YELLOW}âš  Warning: Could not set default alias => lts/*.${NC}"
        log "Failed setting default => lts/*."
    fi

    echo -e "${GREEN}ðŸŽ‰ NVM environment optimization complete.${NC}"
    log "NVM environment optimization completed."
}
#!/usrbin/env bash
# File: optimize_electron.sh
# Author: 4ndr0666
# Date: 2024-11-24
# Description: Automates Electron environment optimization

set -euo pipefail
IFS=$'\n\t'

CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

LOG_FILE="${LOG_FILE:-$HOME/.cache/4ndr0service/logs/service_optimization.log}"
mkdir -p "$(dirname "$LOG_FILE")" || { echo "Failed to create log directory."; exit 1; }

log() {
    local message="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$LOG_FILE"
}

handle_error() {
    local error_message="$1"
    echo -e "${RED}âŒ Error: $error_message${NC}" >&2
    log "ERROR: $error_message"
    exit 1
}

check_directory_writable() {
    local dir_path="$1"
    if [[ -w "$dir_path" ]]; then
        echo "âœ… Directory $dir_path is writable."
        log "Directory '$dir_path' is writable."
    else
        handle_error "Directory $dir_path is not writable."
    fi
}

export ELECTRON_CACHE="${XDG_CACHE_HOME:-$HOME/.cache}/electron"

npm_global_install_or_update() {
    local package_name="$1"
    if npm ls -g "$package_name" --depth=0 &> /dev/null; then
        echo "ðŸ”„ Updating $package_name globally..."
        if npm update -g "$package_name"; then
            echo "âœ… $package_name updated successfully."
            log "$package_name updated successfully."
        else
            echo "âš ï¸ Warning: Failed to update $package_name."
            log "Warning: Failed to update $package_name."
        fi
    else
        echo "ðŸ“¦ Installing $package_name globally..."
        if npm install -g "$package_name"; then
            echo "âœ… $package_name installed successfully."
            log "$package_name installed successfully."
        else
            echo "âš ï¸ Warning: Failed to install $package_name."
            log "Warning: Failed to install $package_name."
        fi
    fi
}

optimize_electron_service() {
    echo "ðŸ”§ Optimizing Electron environment..."

    if ! command -v npm &> /dev/null; then
        handle_error "npm not found. Install Node.js first."
    fi

    # Install or update Electron
    if npm ls -g electron --depth=0 &> /dev/null; then
        echo "âœ… Electron is already installed globally."
        log "Electron globally installed."
    else
        echo "Electron not found, installing globally..."
        if npm install -g electron; then
            echo "âœ… Electron installed globally."
            log "Electron installed globally."
        else
            handle_error "Failed to install electron globally."
        fi
    fi

    # Optionally ensure electron-builder
    npm_global_install_or_update "electron-builder"

    echo "ðŸ› ï¸ Setting environment variable for Wayland + Electron..."
    export ELECTRON_OZONE_PLATFORM_HINT="wayland-egl"

    mkdir -p "$ELECTRON_CACHE" || handle_error "Failed to create Electron cache dir => $ELECTRON_CACHE"
    check_directory_writable "$ELECTRON_CACHE"

    echo "ðŸ—‘ï¸ Optionally cleaning old Electron cache..."
    if [[ -d "$ELECTRON_CACHE" && -w "$ELECTRON_CACHE" ]]; then
        rm -rf "${ELECTRON_CACHE:?}/"*
        log "Cleaned up old Electron cache."
    else
        log "Skipped Electron cache cleanup (not needed or not writable)."
    fi

    echo "âœ… Verifying Electron installation..."
    if command -v electron &> /dev/null; then
        echo "Electron => $(electron --version)"
        log "Electron verified."
    else
        handle_error "Electron verification failed."
    fi

    echo -e "${GREEN}ðŸŽ‰ Electron environment optimization complete.${NC}"
    log "Electron environment optimization completed."
}
#!/usr/bin/env bash
# File: optimize_ruby.sh
# Author: 4ndr0666
# Date: 2024-11-24
# Description: Optimizes Ruby environment.

set -euo pipefail
IFS=$'\n\t'

CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m'

LOG_FILE="${LOG_FILE:-$HOME/.cache/4ndr0service/logs/service_optimization.log}"
mkdir -p "$(dirname "$LOG_FILE")" || { echo "Failed to create log directory."; exit 1; }

log() {
    local message="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$LOG_FILE"
}

handle_error() {
    local err_msg="$1"
    echo -e "${RED}âŒ Error: $err_msg${NC}" >&2
    log "ERROR: $err_msg"
    exit 1
}

check_directory_writable() {
    local dir="$1"
    if [[ -w "$dir" ]]; then
        echo "âœ… Directory $dir is writable."
        log "Directory '$dir' is writable."
    else
        handle_error "Directory $dir not writable."
    fi
}

export RUBY_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/ruby"
export RUBY_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/ruby"
export RUBY_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}/ruby"

install_ruby() {
    if command -v ruby &> /dev/null; then
        echo "âœ… Ruby already installed: $(ruby -v)"
        log "Ruby already installed."
    else
        echo "Installing Ruby..."
        if command -v pacman &> /dev/null; then
            sudo pacman -Syu --needed ruby || handle_error "Failed to install Ruby with pacman."
        else
            handle_error "Ruby missing. Use --fix to install."
        fi
        echo "âœ… Ruby installed."
        log "Ruby installed."
    fi
}

gem_install_or_update() {
    local gem_name="$1"
    if gem list "$gem_name" -i &> /dev/null; then
        echo "ðŸ”„ Updating $gem_name gem..."
        if gem update "$gem_name"; then
            echo "âœ… $gem_name gem updated."
            log "$gem_name gem updated."
        else
            echo "âš ï¸ Warning: Failed to update $gem_name."
            log "Warning: Failed to update $gem_name."
        fi
    else
        echo "ðŸ“¦ Installing $gem_name gem..."
        if gem install "$gem_name"; then
            echo "âœ… $gem_name gem installed."
            log "$gem_name gem installed."
        else
            echo "âš ï¸ Warning: Failed to install $gem_name."
            log "Warning: Failed to install $gem_name."
        fi
    fi
}

npm_install_or_update() {
    local pkg_name="$1"
    if command -v npm &> /dev/null; then
        if npm ls -g "$pkg_name" --depth=0 &> /dev/null; then
            echo "ðŸ”„ Updating $pkg_name..."
            if npm update -g "$pkg_name"; then
                echo "âœ… $pkg_name updated."
                log "$pkg_name updated."
            else
                echo "âš ï¸ Warning: Failed to update $pkg_name."
                log "Warning: Failed to update $pkg_name."
            fi
        else
            echo "ðŸ“¦ Installing $pkg_name globally..."
            if npm install -g "$pkg_name"; then
                echo "âœ… $pkg_name installed."
                log "$pkg_name installed."
            else
                echo "âš ï¸ Warning: Failed to install $pkg_name."
                log "Warning: Failed to install $pkg_name."
            fi
        fi
    else
        echo "âš ï¸ npm not available, skipping $pkg_name."
        log "npm not available, skipping $pkg_name."
    fi
}

manage_ruby_versions() {
    if command -v rbenv &> /dev/null; then
        echo "ðŸ”„ Managing Ruby versions with rbenv..."
        if rbenv install -s "$(rbenv install -l | grep -v - | tail -1)"; then
            rbenv global "$(rbenv versions --bare | tail -1)" || log "Warning: Failed to set global Ruby with rbenv."
            echo "âœ… Ruby managed with rbenv."
            log "Ruby managed with rbenv."
        else
            echo "âš ï¸ Warning: Failed to install Ruby version with rbenv."
            log "Warning: Failed rbenv Ruby install."
        fi
    elif command -v rvm &> /dev/null; then
        echo "ðŸ”„ Managing Ruby versions with RVM..."
        if rvm install ruby --latest; then
            rvm use ruby --default || log "Warning: Failed to set default Ruby with RVM."
            echo "âœ… Ruby managed with RVM."
            log "Ruby managed with RVM."
        else
            echo "âš ï¸ Warning: Failed to install Ruby with RVM."
            log "Warning: Failed RVM Ruby install."
        fi
    else
        echo "âš ï¸ Neither RVM nor rbenv installed. Skipping Ruby version management."
        log "Neither RVM nor rbenv installed."
    fi
}

optimize_ruby_service() {
    echo "ðŸ”§ Starting Ruby environment optimization..."
    echo "ðŸ“¦ Checking if Ruby is installed..."
    install_ruby

    echo "ðŸ› ï¸ Setting up Ruby environment variables..."
    ruby_version=$(ruby -e 'puts RUBY_VERSION')
    GEM_HOME="$RUBY_DATA_HOME/gems/$ruby_version"
    GEM_PATH="$GEM_HOME"
    export GEM_HOME GEM_PATH
    export PATH="$GEM_HOME/bin:$PATH"
    mkdir -p "$GEM_HOME" "$RUBY_CONFIG_HOME" "$RUBY_CACHE_HOME" || handle_error "Failed to create Ruby directories."

    echo "ðŸ” Checking permissions..."
    check_directory_writable "$GEM_HOME"
    check_directory_writable "$RUBY_CONFIG_HOME"
    check_directory_writable "$RUBY_CACHE_HOME"

    echo "ðŸ”§ Ensuring common gems (bundler, rake) updated..."
    gem_install_or_update "bundler"
    gem_install_or_update "rake"

    echo "ðŸ”§ Installing Ruby linter (rubocop) and (optionally prettier)..."
    gem_install_or_update "rubocop"
    npm_install_or_update "prettier"

    echo "ðŸ› ï¸ Ensuring Bundler and RubyGems config..."
    if bundle config set --global path "$GEM_HOME"; then
        echo "âœ… Bundler configured to use GEM_HOME."
        log "Bundler configured to GEM_HOME."
    else
        echo "âš ï¸ Warning: Failed to configure Bundler."
        log "Warning: Failed to configure Bundler."
    fi

    if gem sources --add https://rubygems.org/ --remove https://rubygems.org/ 2>/dev/null; then
        echo "âœ… RubyGems source set."
        log "RubyGems source set."
    else
        echo "âš ï¸ Warning: Failed to configure RubyGems source."
        log "Warning: Failed to configure RubyGems source."
    fi

    echo "ðŸ”§ Managing Ruby versions (optional)..."
    manage_ruby_versions

    echo "ðŸ§¼ Final cleanup..."
    if [[ -d "$RUBY_CACHE_HOME/tmp" ]]; then
        rm -rf "${RUBY_CACHE_HOME:?}/tmp" || log "Warning: Failed to remove $RUBY_CACHE_HOME/tmp."
        log "Cleaned $RUBY_CACHE_HOME/tmp."
    fi

    echo "ðŸŽ‰ Ruby environment optimization complete."
    echo -e "${CYAN}Ruby version:${NC} $(ruby -v)"
    echo -e "${CYAN}GEM_HOME:${NC} $GEM_HOME"
    echo -e "${CYAN}GEM_PATH:${NC} $GEM_PATH"
    log "Ruby environment optimization completed."
}
#!/usr/bin/env bash
# File: optimize_cargo.sh
# Enhanced Verification and Automated Self-Healing for the Cargo environment in 4ndr0service.
# This script optimizes the Cargo environment, verifies tool installations, and attempts automated
# self-healing for missing or misconfigured components.
#
# ==================== // 4ndr0service optimize_cargo.sh //

set -euo pipefail
IFS=$'\n\t'

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Logging
LOG_FILE="${LOG_FILE:-$HOME/.cache/4ndr0service/logs/service_optimization.log}"
mkdir -p "$(dirname "$LOG_FILE")" || { echo "Failed to create log directory." >&2; exit 1; }

log() {
    local message="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$LOG_FILE"
}

handle_error() {
    local error_message="$1"
    echo -e "${RED}âŒ Error: $error_message${NC}" >&2
    log "ERROR: $error_message"
    exit 1
}

# --- // Check if directory is writable
check_directory_writable() {
    local dir_path="$1"
    if [[ ! -w "$dir_path" ]]; then
        handle_error "Directory $dir_path is not writable."
    else
        echo -e "${CYAN}âœ… Directory $dir_path is writable.${NC}"
        log "Directory '$dir_path' is writable."
    fi
}

# Set Cargo and Rustup directories according to XDG Base Directory Specs
export CARGO_HOME="${CARGO_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/cargo}"
export RUSTUP_HOME="${RUSTUP_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/rustup}"

install_rustup() {
    echo -e "${CYAN}ðŸ“¦ Installing rustup...${NC}"
    if curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path; then
        echo -e "${CYAN}âœ… rustup installed successfully.${NC}"
        log "rustup installed successfully."
    else
        handle_error "Failed to install rustup."
    fi
    [ -s "$CARGO_HOME/env" ] && source "$CARGO_HOME/env" || handle_error "Failed to source Rustup environment."
}

update_rustup_and_cargo() {
    echo -e "${CYAN}ðŸ”„ Updating rustup and Cargo toolchain...${NC}"
    if rustup self update > /dev/null 2>&1; then
        if rustup update stable > /dev/null 2>&1; then
            echo -e "${CYAN}âœ… rustup and Cargo updated successfully.${NC}"
            log "rustup and Cargo updated successfully."
        else
            echo -e "${YELLOW}âš ï¸ Warning: Failed to update Cargo.${NC}"
            log "Warning: Failed to update Cargo."
        fi
    else
        echo -e "${YELLOW}âš ï¸ rustup self-update disabled for this system. Use your system package manager to update rustup.${NC}"
        log "rustup self-update not available."
    fi
    # Ensure default toolchain is set (required on Arch)
    if ! rustup default | grep -q "stable"; then
        echo -e "${CYAN}ðŸ”„ Setting default toolchain to stable...${NC}"
        rustup default stable > /dev/null 2>&1 || handle_error "Failed to set default toolchain."
        log "Default toolchain set to stable."
    fi
}

cargo_install_or_update() {
    local package_name="$1"
    if cargo install --list | grep -q "^$package_name "; then
        echo -e "${CYAN}ðŸ”„ Updating Cargo package: $package_name...${NC}"
        if cargo install "$package_name" --force; then
            echo -e "${CYAN}âœ… $package_name updated successfully.${NC}"
            log "$package_name updated successfully."
        else
            echo -e "${YELLOW}âš ï¸ Warning: Failed to update $package_name.${NC}"
            log "Warning: Failed to update $package_name."
        fi
    else
        echo -e "${CYAN}ðŸ“¦ Installing Cargo package: $package_name...${NC}"
        if cargo install "$package_name"; then
            echo -e "${CYAN}âœ… $package_name installed successfully.${NC}"
            log "$package_name installed successfully."
        else
            echo -e "${YELLOW}âš ï¸ Warning: Failed to install $package_name.${NC}"
            log "Warning: Failed to install $package_name."
        fi
    fi
}

consolidate_cargo_directories() {
    echo -e "${CYAN}ðŸ§¹ Ensuring Cargo directories exist...${NC}"
    mkdir -p "$CARGO_HOME" "$RUSTUP_HOME" || handle_error "Failed creating Cargo dirs."

    # Merge .cargo into $CARGO_HOME if they differ
    if [[ -d "$HOME/.cargo" && "$HOME/.cargo" != "$CARGO_HOME" ]]; then
        echo -e "${CYAN}ðŸ§¹ Merging existing .cargo => $CARGO_HOME...${NC}"
        if command -v rsync > /dev/null 2>&1; then
            rsync -a --remove-source-files --progress "$HOME/.cargo/" "$CARGO_HOME/" \
                || handle_error "Failed to merge .cargo => $CARGO_HOME."
            rmdir "$HOME/.cargo" 2>/dev/null || true
        else
            mv "$HOME/.cargo"/* "$CARGO_HOME" || handle_error "Failed to move .cargo => $CARGO_HOME."
            rmdir "$HOME/.cargo" 2>/dev/null || true
        fi
    fi

    # Merge .rustup into $RUSTUP_HOME if they differ
    if [[ -d "$HOME/.rustup" && "$HOME/.rustup" != "$RUSTUP_HOME" ]]; then
        echo -e "${CYAN}ðŸ§¹ Merging existing .rustup => $RUSTUP_HOME...${NC}"
        # Attempt to remove immutable attributes if possible
        if command -v chattr > /dev/null 2>&1; then
            chattr -R -i "$HOME/.rustup" > /dev/null 2>&1 || log "Warning: Unable to remove immutable attributes from ~/.rustup."
        fi
        # Check and exclude settings.toml if permission cannot be changed
        RSYNC_EXCLUDES=""
        if [ -f "$HOME/.rustup/settings.toml" ]; then
            if ! chmod u+w "$HOME/.rustup/settings.toml" 2>/dev/null; then
                echo -e "${CYAN}ðŸ”„ Unable to modify permissions on ~/.rustup/settings.toml; excluding it from migration...${NC}"
                RSYNC_EXCLUDES="--exclude=settings.toml"
            else
                rm -f "$HOME/.rustup/settings.toml" || log "Warning: Failed to remove ~/.rustup/settings.toml."
            fi
        fi
        if command -v rsync > /dev/null 2>&1; then
            rsync -a $RSYNC_EXCLUDES --remove-source-files --progress "$HOME/.rustup/" "$RUSTUP_HOME/" \
                || handle_error "Failed to merge .rustup => $RUSTUP_HOME."
            rmdir "$HOME/.rustup" 2>/dev/null || true
        else
            mv "$HOME/.rustup"/* "$RUSTUP_HOME" || handle_error "Failed to move .rustup => $RUSTUP_HOME."
            rmdir "$HOME/.rustup" 2>/dev/null || true
        fi
    fi

    log "Cargo directories consolidated."
}

install_cargo_tools() {
    echo -e "${CYAN}ðŸ”§ Installing essential Cargo tools (cargo-update, cargo-audit)...${NC}"
    cargo_install_or_update "cargo-update"
    cargo_install_or_update "cargo-audit"
}

manage_permissions() {
    echo -e "${CYAN}ðŸ” Verifying permissions for Cargo directories...${NC}"
    check_directory_writable "$CARGO_HOME"
    check_directory_writable "$RUSTUP_HOME"
    log "Permissions verified for Cargo directories."
}

validate_cargo_installation() {
    echo -e "${CYAN}âœ… Validating Cargo installation...${NC}"
    if ! cargo --version > /dev/null 2>&1; then
        handle_error "Cargo missing. Use --fix to attempt installation."
    fi
    if ! rustup --version > /dev/null 2>&1; then
        handle_error "rustup not installed correctly."
    fi
    echo -e "${CYAN}âœ… Cargo and rustup are installed and configured.${NC}"
    log "Cargo and rustup validated."
}

enhanced_verify_cargo() {
    # Basic validation
    validate_cargo_installation

    # Enhanced verification for essential Cargo tools
    echo -e "${CYAN}ðŸ” Verifying essential Cargo tools...${NC}"
    if ! cargo install --list | grep -q "^cargo-update "; then
        echo -e "${YELLOW}âš ï¸ cargo-update not found. Attempting self-healing...${NC}"
        cargo_install_or_update "cargo-update"
    else
        echo -e "${GREEN}âœ… cargo-update is present.${NC}"
    fi
    if ! cargo install --list | grep -q "^cargo-audit "; then
        echo -e "${YELLOW}âš ï¸ cargo-audit not found. Attempting self-healing...${NC}"
        cargo_install_or_update "cargo-audit"
    else
        echo -e "${GREEN}âœ… cargo-audit is present.${NC}"
    fi
    # Ensure executables are in PATH
    if ! command -v cargo-update >/dev/null 2>&1; then
        echo -e "${YELLOW}âš ï¸ cargo-update executable not found in PATH. Attempting to add CARGO_HOME/bin to PATH...${NC}"
        export PATH="$CARGO_HOME/bin:$PATH"
        if ! command -v cargo-update >/dev/null 2>&1; then
            echo -e "${RED}âŒ cargo-update is still missing. Self-healing failed.${NC}"
            log "Self-healing failed: cargo-update missing in PATH."
        else
            echo -e "${GREEN}âœ… cargo-update is now available in PATH.${NC}"
        fi
    fi
    if ! command -v cargo-audit >/dev/null 2>&1; then
        echo -e "${YELLOW}âš ï¸ cargo-audit executable not found in PATH. Attempting to add CARGO_HOME/bin to PATH...${NC}"
        export PATH="$CARGO_HOME/bin:$PATH"
        if ! command -v cargo-audit >/dev/null 2>&1; then
            echo -e "${RED}âŒ cargo-audit is still missing. Self-healing failed.${NC}"
            log "Self-healing failed: cargo-audit missing in PATH."
        else
            echo -e "${GREEN}âœ… cargo-audit is now available in PATH.${NC}"
        fi
    fi
    log "Enhanced verification of Cargo tools completed."
}

perform_final_cleanup() {
    echo -e "${CYAN}ðŸ§¼ Performing final cleanup tasks...${NC}"
    if [[ -d "$CARGO_HOME/tmp" ]]; then
        echo -e "${CYAN}ðŸ—‘ï¸ Cleaning $CARGO_HOME/tmp...${NC}"
        rm -rf "${CARGO_HOME:?}/tmp" > /dev/null 2>&1 || log "Warning: Failed removing $CARGO_HOME/tmp."
        log "Removed $CARGO_HOME/tmp."
    fi
    if [[ -d "$RUSTUP_HOME/tmp" ]]; then
        echo -e "${CYAN}ðŸ—‘ï¸ Cleaning $RUSTUP_HOME/tmp...${NC}"
        rm -rf "${RUSTUP_HOME:?}/tmp" > /dev/null 2>&1 || log "Warning: Failed removing $RUSTUP_HOME/tmp."
        log "Removed $RUSTUP_HOME/tmp."
    fi
    echo -e "${CYAN}ðŸ§¼ Final cleanup completed.${NC}"
    log "Cargo final cleanup done."
}

optimize_cargo_service() {
    echo -e "${CYAN}ðŸ”§ Starting Cargo environment optimization...${NC}"

    if ! command -v rustup > /dev/null 2>&1; then
        echo -e "${CYAN}ðŸ“¦ rustup not installed. Installing...${NC}"
        install_rustup
    else
        echo -e "${CYAN}âœ… rustup already installed.${NC}"
        log "rustup installed."
    fi

    echo -e "${CYAN}ðŸ”„ Updating rustup + Cargo...${NC}"
    update_rustup_and_cargo

    echo -e "${CYAN}ðŸ› ï¸ Setting PATH for Cargo...${NC}"
    export PATH="$CARGO_HOME/bin:$PATH"

    echo -e "${CYAN}ðŸ§¹ Consolidating Cargo directories...${NC}"
    consolidate_cargo_directories

    echo -e "${CYAN}ðŸ”§ Installing essential Cargo tools...${NC}"
    install_cargo_tools

    echo -e "${CYAN}ðŸ” Managing permissions...${NC}"
    manage_permissions

    echo -e "${CYAN}âœ… Validating Cargo installation...${NC}"
    enhanced_verify_cargo

    echo -e "${CYAN}ðŸ§¼ Final cleanup...${NC}"
    perform_final_cleanup

    echo -e "${CYAN}ðŸŽ‰ Cargo environment optimization complete.${NC}"
    echo -e "${CYAN}CARGO_HOME:${NC} $CARGO_HOME"
    echo -e "${CYAN}RUSTUP_HOME:${NC} $RUSTUP_HOME"
    echo -e "${CYAN}Cargo version:${NC} $(cargo --version)"
    echo -e "${CYAN}rustup version:${NC} $(rustup --version)"
    log "Cargo environment optimization completed."
}

# Allow direct execution
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    optimize_cargo_service
fi
#!/usr/bin/env bash
# File: optimize_meson.sh
# Description: Meson build system environment optimization for the 4ndr0service suite on Arch-based systems.
# Safely ensures Meson (and Ninja) are installed and configures Meson to use XDG base directories.

set -euo pipefail
IFS=$'\n\t'

# Determine package path and source common environment setup
PKG_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
# shellcheck source=../common.sh
source "$PKG_PATH/common.sh"

# Define XDG base directories for Meson
export MESON_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/meson"
export MESON_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/meson"
export MESON_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}/meson"

# Ensure pipx-installed binaries are accessible (pipx apps install here by default)
case ":$PATH:" in
    *:"$PIPX_BIN_DIR":*) ;; 
    *) export PATH="$PIPX_BIN_DIR:$PATH" ;;
esac

install_meson() {
    if command -v meson &>/dev/null; then
        log_info "Meson is already installed (version $(meson --version))."
        return 0
    fi
    log_info "Meson not found. Beginning installation..."
    # 1. Try installing via pacman (system package manager)
    if command -v pacman &>/dev/null; then
        log_info "Attempting to install Meson via pacman."
        if sudo pacman -S --needed --noconfirm meson; then
            log_info "Meson successfully installed via pacman."
        else
            log_warn "pacman failed to install Meson (permission or other issue)."
        fi
    else
        log_warn "Pacman package manager not available. Skipping system package installation."
    fi
    # 2. If still not installed, try pipx (isolated Python package installer)
    if ! command -v meson &>/dev/null; then
        log_info "Attempting to install Meson via pipx."
        if ! command -v pipx &>/dev/null; then
            log_info "pipx not found; installing pipx using pip."
            if command -v python3 &>/dev/null; then
                python3 -m ensurepip --upgrade &>/dev/null || true  # ensure pip is available
                if python3 -m pip install --user pipx; then
                    log_info "pipx installed successfully."
                    # Add pipx bin directory to PATH (for newly installed pipx and its apps)
                    export PATH="$PIPX_BIN_DIR:$PATH"
                else
                    log_warn "Failed to install pipx via pip."
                fi
            else
                log_warn "Python3 is not available; cannot install pipx."
            fi
        fi
        if command -v pipx &>/dev/null; then
            if pipx list | grep -qw meson; then
                log_info "Meson already installed via pipx; upgrading to latest version."
                pipx upgrade meson || log_warn "Failed to upgrade Meson via pipx."
            else
                pipx install meson || log_warn "Failed to install Meson via pipx."
            fi
        fi
    fi
    # 3. If still not installed, use pip as a last resort
    if ! command -v meson &>/dev/null; then
        log_info "Attempting to install Meson via pip (user install)."
        if command -v python3 &>/dev/null; then
            python3 -m ensurepip --upgrade &>/dev/null || true  # ensure pip is available
            if python3 -m pip install --user meson; then
                log_info "Meson installed via pip."
            else
                handle_error "Failed to install Meson via pip."
            fi
        else
            handle_error "Python3 is required to install Meson via pip, but it's not available."
        fi
    fi
    # Verify Meson is now installed
    if ! command -v meson &>/dev/null; then
        handle_error "Meson installation was not successful."
    else
        log_info "Meson installation complete (version $(meson --version))."
    fi
}

optimize_meson_service() {
    log_info "ðŸ”§ Starting Meson environment optimization..."
    install_meson

    # Ensure Meson home directory exists (for storing Meson files in XDG_DATA_HOME)
    if [[ ! -d "$MESON_HOME" ]]; then
        if ! mkdir -p "$MESON_HOME"; then
            handle_error "Cannot create directory $MESON_HOME."
        fi
    fi

    # Prepend MESON_HOME/bin to PATH if not already present (for any Meson-related binaries stored there)
    case ":$PATH:" in
        *:"$MESON_HOME/bin":*) ;; 
        *) export PATH="$MESON_HOME/bin:$PATH" ;;
    esac
    log_info "Configured Meson environment variables and updated PATH."

    # Verify the MESON_HOME directory is writable
    if [[ ! -w "$MESON_HOME" ]]; then
        handle_error "Directory $MESON_HOME is not writable. Please check permissions."
    else
        log_info "Directory $MESON_HOME is present and writable."
    fi

    # Set up an initial Meson build directory with Ninja backend (optional, to verify Meson works)
    log_info "Configuring Meson build directory and backends..."
    local build_dir="$MESON_HOME/build"
    if [[ -d "$build_dir" ]]; then
        log_info "Meson build directory already exists at $build_dir."
    else
        log_info "Creating Meson build directory at $build_dir."
        if mkdir -p "$build_dir" && meson setup "$build_dir" --backend=ninja; then
            log_info "Meson build directory initialized with Ninja backend."
        else
            log_warn "Meson setup for $build_dir failed (this may be non-critical)."
        fi
    fi

    # Consolidate any legacy Meson directory from $HOME/.meson into XDG directory
    log_info "Consolidating Meson configuration data to XDG directories..."
    if [[ -d "$HOME/.meson" ]]; then
        if rsync -av "$HOME/.meson/" "$MESON_HOME/" && rm -rf "$HOME/.meson"; then
            log_info "Moved contents of $HOME/.meson into $MESON_HOME."
        else
            log_warn "Failed to consolidate $HOME/.meson into $MESON_HOME (manual cleanup may be needed)."
        fi
    else
        log_info "No legacy ~/.meson directory found; nothing to consolidate."
    fi

    # Cleanup: remove any temporary files in Meson cache
    if [[ -d "$MESON_CACHE_HOME/tmp" ]]; then
        log_info "Removing temporary files in $MESON_CACHE_HOME/tmp..."
        rm -rf "${MESON_CACHE_HOME:?}/tmp" || log_warn "Could not remove $MESON_CACHE_HOME/tmp."
    fi

    # Ensure Ninja build tool is installed (Meson requires ninja for building projects)
    if ! command -v ninja &>/dev/null; then
        log_warn "Ninja build tool not found. Attempting to install Ninja..."
        if command -v pacman &>/dev/null; then
            log_info "Installing Ninja via pacman."
            sudo pacman -S --needed --noconfirm ninja || log_warn "Pacman failed to install Ninja."
        elif command -v python3 &>/dev/null; then
            log_info "Installing Ninja via pip."
            python3 -m pip install --user ninja || log_warn "pip failed to install Ninja."
        else
            log_warn "No available package manager to install Ninja. Please install Ninja manually."
        fi
    fi

    # Final validation: Meson and Ninja should now be available
    if ! command -v meson &>/dev/null; then
        handle_error "Meson is not available after installation steps."
    fi
    if ! command -v ninja &>/dev/null; then
        handle_error "Ninja is required by Meson but is still not installed."
    fi

    # Output final status and environment info
    log_info "Meson and Ninja are installed and configured correctly."
    log_info "Meson version: $(meson --version 2>/dev/null || echo 'unknown')"
    log_info "Ninja version: $(ninja --version 2>/dev/null || echo 'unknown')"
    log_info "MESON_HOME is set to $MESON_HOME"
    log_info "MESON_CONFIG_HOME is set to $MESON_CONFIG_HOME"
    log_info "MESON_CACHE_HOME is set to $MESON_CACHE_HOME"
    log_info "ðŸŽ‰ Meson environment optimization complete."
}

# If script is run directly (not sourced), execute the optimization
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    optimize_meson_service
fi
#!/usr/bin/env bash
# File: optimize_venv.sh
# Author: 4ndr0666
# Description: Additional venv + pipx oriented environment optimization steps

set -euo pipefail
IFS=$'\n\t'

CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

LOG_FILE="${LOG_FILE:-$HOME/.cache/4ndr0service/logs/service_optimization.log}"
mkdir -p "$(dirname "$LOG_FILE")" || {
    echo "Failed to create log directory for venv optimization."
    exit 1
}

log() {
    local msg="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $msg" >> "$LOG_FILE"
}

handle_error() {
    local err="$1"
    echo -e "${RED}âŒ Error: $err${NC}" >&2
    log "ERROR: $err"
    exit 1
}

check_directory_writable() {
    local dir_path="$1"
    if [[ ! -w "$dir_path" ]]; then
        handle_error "Directory $dir_path is not writable."
    else
        echo "âœ… Directory $dir_path is writable."
        log "Directory $dir_path is writable."
    fi
}

pipx_install_or_update() {
    local tool_name="$1"
    if pipx list | grep -q "$tool_name"; then
        echo "Updating $tool_name with pipx..."
        if pipx upgrade "$tool_name"; then
            echo "âœ… $tool_name upgraded."
            log "$tool_name upgraded via pipx."
        else
            echo "âš ï¸ Warning: Failed to update $tool_name."
            log "Warning: pipx failed to update $tool_name."
        fi
    else
        echo "Installing $tool_name with pipx..."
        if pipx install "$tool_name"; then
            echo "âœ… $tool_name installed."
            log "$tool_name installed via pipx."
        else
            echo "âš ï¸ Warning: Failed to install $tool_name."
            log "Warning: pipx failed to install $tool_name."
        fi
    fi
}

optimize_venv_service() {
    echo "ðŸ”§ Optimizing Python environment specifically for venv & pipx usage..."

    if ! command -v python3 &>/dev/null; then
        handle_error "Python3 not found. Please install Python before venv usage."
    fi

    echo "ðŸ›  Checking if main venv directory ($VENV_HOME/.venv) exists..."
    if [[ ! -d "$VENV_HOME/.venv" ]]; then
        echo "Creating a new venv => $VENV_HOME/.venv"
        python3 -m venv "$VENV_HOME/.venv" || handle_error "Could not create venv at $VENV_HOME/.venv"
    else
        echo "Venv already exists => $VENV_HOME/.venv"
    fi

    echo "Activating the venv => $VENV_HOME/.venv..."
    source "$VENV_HOME/.venv/bin/activate" || handle_error "Failed to activate venv => $VENV_HOME/.venv"

    echo "Installing pipx if missing..."
    if ! command -v pipx &>/dev/null; then
        echo "Installing pipx within system or user scope..."
        if ! python3 -m pip install --user pipx; then
            echo "âš ï¸ Warning: Could not install pipx via pip. Attempting fallback..."
        fi
        command -v pipx &>/dev/null || echo "Still missing pipx; user must install manually."
    else
        echo "pipx is already available => $(pipx --version 2>/dev/null || echo 'Unknown')"
    fi

    echo "Installing or updating base Python dev tools via pipx => black, flake8, mypy, pytest..."
    pipx_install_or_update black
    pipx_install_or_update flake8
    pipx_install_or_update mypy
    pipx_install_or_update pytest

    if [[ -f "requirements.txt" ]]; then
        echo "Installing from local requirements.txt..."
        pip install -r requirements.txt || log "Warning: could not install from requirements.txt"
    fi

    echo "ðŸ” Checking venv directory permissions..."
    check_directory_writable "$VENV_HOME/.venv"

    echo "ðŸ§¼ Checking for empty or stale directories within $VENV_HOME..."
    find "$VENV_HOME" -type d -empty -delete 2>/dev/null || true

    echo -e "${GREEN}ðŸŽ‰ Venv environment optimization complete.${NC}"
    echo -e "${CYAN}Venv path:${NC} $VENV_HOME/.venv"
    log "Venv environment optimization completed."
}
