#!/bin/bash
# Author: 4ndr0666
set -euo pipefail
# ==================== // UFW.SH //

## Declarations

declare VERBOSE=false
declare SILENT=false
declare DRY_RUN=false
declare VPN_FLAG=false
declare JD_FLAG=false
declare PRIMARY_IF="" # Detected primary network interface (e.g., eth0, wlan0)
declare VPN_IFACES="" # Detected VPN interfaces (space-separated, e.g., tun0 tun1)
VPN_PORT is specifically for ExpressVPN Lightway UDP, assumed to be 443
declare VPN_PORT=""

## Read Only

readonly LOG_FILE="/var/log/ufw.sh.log"
readonly UFW_DEFAULTS_FILE="/etc/default/ufw"
readonly SYSCTL_D_DIR="/etc/sysctl.d"
readonly SYSCTL_CONF="/etc/sysctl.conf"
readonly SYSCTL_UFW_CONF="${SYSCTL_D_DIR}/99-ufwsh.conf"

## Logging Function

log() {
	local timestamp message
	timestamp=$(date +"%Y-%m-%d %H:%M:%S")
	message="$1"

	# Write to log file, check for errors
	if ! printf "%s : %s\n" "$timestamp" "$message" >>"$LOG_FILE"; then
		# If writing to log fails, print error and message to stderr
		echo "Error: Failed to write to log file $LOG_FILE" >&2
		echo "$timestamp : $message" >&2
	fi

	# Write to stdout based on SILENT and VERBOSE flags
	if [[ "$SILENT" == "false" ]]; then
		if [[ "$VERBOSE" == "true" ]]; then
			# Verbose output includes timestamp.
			printf "%s : %s\n" "$timestamp" "$message"
		else
			# Non-verbose output is just the message.
			printf "%s\n" "$message"
		fi
	fi
}

## Logging

setup_logging() {
	local log_dir
	log_dir=$(dirname "$LOG_FILE")

	if [[ ! -d "$log_dir" ]]; then
		echo "Creating log directory: $log_dir" >&2 # Use echo before logging is fully setup
		if ! mkdir -p "$log_dir"; then
			echo "Error: Failed to create log directory $log_dir. Exiting." >&2 # Use echo before logging is fully setup
			exit 1
		fi
		log "Created log directory: $log_dir" # Now logging is potentially available
	fi

	if [[ ! -f "$LOG_FILE" ]]; then
		echo "Creating log file: $LOG_FILE" >&2 # Use echo before logging is fully setup
		if ! touch "$LOG_FILE"; then
			echo "Error: Failed to create log file $LOG_FILE. Exiting." >&2 # Use echo before logging is fully setup
			exit 1
		fi
		log "Created log file: $LOG_FILE" # Now logging is potentially available
	fi

	# Set permissions to owner read/write only
	if ! chmod 600 "$LOG_FILE"; then
		log "Warning: Failed to set permissions on $LOG_FILE."
	fi
	log "Logging initialized to $LOG_FILE"
}

## Dry run

run_cmd_dry() {
	local cmd_desc exit_code
	cmd_desc="${*}"          # Capture command and arguments for logging
	local -a cmd_args=("$@") # Store command and arguments for execution

	if [[ "$DRY_RUN" == "true" ]]; then
		log "Dry-run: Would run: ${cmd_desc}"
		return 0 # Simulate success in dry-run
	else
		log "Running: ${cmd_desc}"
		if ! "${cmd_args[@]}" >>"$LOG_FILE" 2>&1; then
			exit_code=$?
			log "Error: Command failed with exit code $exit_code: ${cmd_desc}"
			return $exit_code # Return the actual exit code
		fi
		return 0 # Command succeeded
	fi
}

## Help

usage() {
	echo "Usage: $0 [options]"
	echo "Options:"
	echo "  --vpn         Configure VPN-specific firewall rules (assumes ExpressVPN Lightway UDP on port 443)."
	echo "  --jdownloader Configure JDownloader2-specific firewall rules."
	echo "  --verbose     Enable verbose output to stdout."
	echo "  --silent      Enable silent mode (no output to stdout, only log file)."
	echo "  --dry-run     Simulate actions without making changes."
	echo "  --help, -h    Display this help message."
	exit 0
}

## Escalate

check_root() {
	if [[ "${EUID}" -ne 0 ]]; then
		echo "Attempting to re-run with sudo..." >&2 # Use echo before logging is fully setup
		# Use exec to replace the current process with sudo
		exec sudo "$0" "$@"
		# If exec fails, print an error and exit
		echo "Error: Failed to re-run with sudo. Exiting." >&2 # Use echo before logging is fully setup
		exit 1
	fi
	# Setup logging only after confirming root privileges
	setup_logging
	log "Script is running as root."
}

## CLI Argument Parsing

parse_args() {
	log "Parsing command-line arguments: $*"
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--vpn)
			VPN_FLAG=true
			log "Option --vpn enabled."
			;;
		--jdownloader)
			JD_FLAG=true
			log "Option --jdownloader enabled."
			;;
		--verbose)
			VERBOSE=true
			log "Option --verbose enabled."
			;;
		--silent)
			SILENT=true
			log "Option --silent enabled."
			;;
		--dry-run)
			DRY_RUN=true
			log "Option --dry-run enabled."
			;;
		--help | -h)
			usage # Display usage and exit
			;;
		*)
			log "Error: Unknown option '$1'"
			usage # Display usage and exit on unknown option
			;;
		esac
		shift # Move to the next argument
	done
}

## Dependency Check

check_dependencies() {
	log "Checking required dependencies..."
	# List of required commands
	local -a dependencies=("rsync" "ufw" "ss" "awk" "grep" "sed" "systemctl" "touch" "mkdir" "cp" "date" "tee" "ip" "sysctl" "iptables" "printf")
	local cmd install_output install_exit_code
	for cmd in "${dependencies[@]}"; do
		if ! command -v "$cmd" >/dev/null 2>&1; then
			log "Dependency '$cmd' not found. Attempting to install..."
			# Attempt installation using common package managers
			if command -v apt >/dev/null 2>&1; then
				log "Attempting installation via apt..."
				if install_output=$(apt update && apt install -y --no-install-recommends "$cmd" 2>&1); then
					log "Package for '$cmd' installed via apt."
				else
					install_exit_code=$?
					log "Error: Could not install '$cmd' via apt (exit code $install_exit_code). Output: $install_output"
					exit 1 # Exit if a dependency cannot be installed
				fi
			elif command -v dnf >/dev/null 2>&1; then
				log "Attempting installation via dnf..."
				if install_output=$(dnf install -y "$cmd" 2>&1); then
					log "Package for '$cmd' installed via dnf."
				else
					install_exit_code=$?
					log "Error: Could not install '$cmd' via dnf (exit code $install_exit_code). Output: $install_output"
					exit 1 # Exit if a dependency cannot be installed
				fi
			elif command -v pacman >/dev/null 2>&1; then
				log "Attempting installation via pacman..."
				if install_output=$(pacman -S --noconfirm --needed "$cmd" 2>&1); then
					log "Package for '$cmd' installed via pacman."
				else
					install_exit_code=$?
					log "Error: Could not install '$cmd' via pacman (exit code $install_exit_code). Output: $install_output"
					exit 1 # Exit if a dependency cannot be installed
				fi
			elif command -v yay >/dev/null 2>&1; then
				log "Attempting installation via yay..."
				if install_output=$(yay -S --noconfirm --needed "$cmd" 2>&1); then
					log "Package for '$cmd' installed via yay."
				else
					install_exit_code=$?
					log "Error: Could not install '$cmd' via yay (exit code $install_exit_code). Output: $install_output"
					exit 1 # Exit if a dependency cannot be installed
				fi
			else
				log "Error: '$cmd' not found and no known package manager (apt, dnf, pacman, yay) is installed. Please install it manually."
				exit 1 # Exit if dependency is missing and no known package manager is found
			fi
		else
			log "Dependency '$cmd' is already installed."
		fi
	done
	log "All dependencies are satisfied."
}

## Detect 

detect_primary_interface() {
	log "Detecting primary network interface..."
	local primary_if
	# Use ip command to list active links, filter out loopback, take the first one.
	primary_if=$(ip -o link show up | awk -F': ' '{print $2}' | grep -v '^lo$' | head -n1)
	if [[ -z "$primary_if" ]]; then
		log "Error: Unable to detect the primary network interface."
		exit 1 # Exit if primary interface cannot be detected
	fi
	PRIMARY_IF="$primary_if"
	log "Primary network interface detected: $PRIMARY_IF"
}

detect_vpn_interfaces() {
	log "Detecting VPN interfaces..."
	local vpn_ifaces
	# Use ip command to list tun interfaces.
	vpn_ifaces=$(ip -o link show type tun | awk -F': ' '{print $2}')
	if [[ -z "$vpn_ifaces" ]]; then
		log "Warning: No VPN interfaces detected."
		VPN_IFACES=""
	else
		VPN_IFACES="$vpn_ifaces"
		log "Detected VPN interfaces: $VPN_IFACES"
	fi
}

detect_vpn_port() {
	# This function is only relevant if the VPN flag is set
	if [[ "$VPN_FLAG" == "false" ]]; then
		log "VPN flag is not set. Skipping VPN port detection."
		return 0 # Not an error if VPN is not requested
	fi

	log "Checking for VPN interfaces to determine VPN port..."
	detect_vpn_interfaces # Ensure VPN_IFACES is populated

	if [[ -z "${VPN_IFACES:-}" ]]; then
		log "Error: VPN flag set but no VPN interfaces found. Ensure ExpressVPN is connected."
		# Exit here because VPN rules cannot be applied without an interface
		exit 1
	fi

	# Assuming ExpressVPN Lightway UDP uses port 443 based on common configuration.
	# The previous ss parsing logic was brittle. We rely on the known configuration.
	VPN_PORT=443
	log "Assuming ExpressVPN Lightway UDP port: $VPN_PORT (based on detected VPN interfaces and --vpn flag)"

	# Optional: Add a check here using ss to verify if port 443 UDP is in use on a VPN interface
	# This is for verification, not detection.
	local vpn_if_check
	local port_in_use=false
	while read -r vpn_if_check; do
		if ss -u -a state established "( sport = :$VPN_PORT or dport = :$VPN_PORT )" -o "dev $vpn_if_check" | grep -q "$VPN_PORT"; then
			log "Verification: Confirmed port $VPN_PORT/udp is in use on $vpn_if_check."
			port_in_use=true
			break # Found it on at least one interface
		fi
	done <<<"$VPN_IFACES"

	if [[ "$port_in_use" == "false" ]]; then
		log "Warning: Could not verify port $VPN_PORT/udp is in use on any VPN interface using ss. Proceeding with assumed port."
		# Decide if this should be a fatal error or just a warning.
		# Keeping it a warning for now, as ss might not show all connections immediately.
	fi

	return 0 # Detection/Assumption successful
}

## Content Comparison Helper

content_matches() {
	local file="$1"
	local desired_content="$2"
	local current_content_processed desired_content_processed
	# Define a unique separator string unlikely to appear in file content
	local separator='
--UFWSH-SEPARATOR--
'

	if [[ ! -f "$file" ]]; then
		return 1 # File doesn't exist, content doesn't match
	fi

	# Process current file content: remove comments, blank lines, trim whitespace
	current_content_processed=$(
		grep -v '^[[:space:]]*#' "$file" 2>/dev/null |
			grep -v '^[[:space:]]*$' |
			sed 's/^[[:space:]]//;s/[[:space:]]$//'
	)

	# Process desired content: remove comments, blank lines, trim whitespace
	desired_content_processed=$(
		grep -v '^[[:space:]]*#' <<<"$desired_content" |
			grep -v '^[[:space:]]*$' |
			sed 's/^[[:space:]]//;s/[[:space:]]$//'
	)

	# Compare processed content line by line, joined by separator
	if [[ "$(paste -sd "$separator" - <<<"$current_content_processed")" == "$(paste -sd "$separator" - <<<"$desired_content_processed")" ]]; then
		return 0 # Match
	else
		return 1 # No match
	fi
}

## Rules

rule_exists() {
	local rule_spec="$1"     # The rule specification string to look for
	local status_output="$2" # The captured output of 'ufw status verbose'
	local escaped_rule_spec regex
	# Escape special regex characters in the rule specification
	escaped_rule_spec=$(printf "%s" "$rule_spec" | sed "s/[][\/.?*+^$()|]/\\&/g")
	# Create a regex that matches the exact rule, allowing for variable whitespace (\s+)
	regex="^${escaped_rule_spec// /\\s+}$"
	# Use grep -q to check for the pattern quietly
	grep -qE "$regex" <<<"$status_output"
}

## Sysctl Configuration

configure_sysctl() {
	log "Configuring sysctl settings..."
	local SYSCTL_CONF_CONTENT
	# Define content for /etc/sysctl.conf
	read -r -d '' SYSCTL_CONF_CONTENT <<EOF
${SYSCTL_CONF} - Managed by ufw.sh. Do not edit manually.


This file can be used for basic settings or includes.


Specific configurations are managed in ${SYSCTL_D_DIR}/


Include settings from /etc/sysctl.d/


include ${SYSCTL_D_DIR}/*.conf
EOF
	local SYSCTL_UFW_CONF_CONTENT
	# Define content for /etc/sysctl.d/99-ufwsh.conf
	read -r -d '' SYSCTL_UFW_CONF_CONTENT <<EOF
${SYSCTL_UFW_CONF} - Custom sysctl settings for ufw.sh


# Managed by ufw.sh. Do not edit manually.


# Enable IP forwarding (needed for routing, e.g., VPN split tunneling)

net.ipv4.ip_forward=1

# Disable ICMP redirects (security hardening)

net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.default.accept_redirects=0

# Enable Source Route Verification (prevents spoofing)

net.ipv4.conf.all.rp_filter=1
net.ipv4.conf.default.rp_filter=1

# Disable Source Routing (security hardening)

net.ipv4.conf.default.accept_source_route=0
net.ipv4.conf.all.accept_source_route=0

# Ignore bogus error responses (security hardening)

net.ipv4.icmp_ignore_bogus_error_responses=1

# Disable logging of martian packets (can be noisy, enable for debugging)

net.ipv4.conf.default.log_martians=0
net.ipv4.conf.all.log_martians=0

# Ignore broadcast ICMP requests (security hardening)

net.ipv4.icmp_echo_ignore_broadcasts=1

# Allow ping responses (set to 1 to ignore all echo requests)

net.ipv4.icmp_echo_ignore_all=0

# TCP performance settings (examples, adjust based on system needs)

net.ipv4.tcp_sack=1
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.core.optmem_max=65536
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216
net.core.somaxconn=8192
net.ipv4.tcp_window_scaling=1
net.core.netdev_max_backlog=5000
net.ipv4.udp_rmem_min=8192
net.ipv4.udp_wmem_min=8192
net.ipv4.tcp_fastopen=3
net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_fin_timeout=10
net.ipv4.tcp_slow_start_after_idle=0
net.ipv4.tcp_keepalive_time=60
net.ipv4.tcp_keepalive_intvl=10
net.ipv4.tcp_keepalive_probes=6
net.ipv4.tcp_mtu_probing=1
net.ipv4.tcp_timestamps=0 # Disable timestamps for minor privacy gain
net.core.default_qdisc=cake # Requires kernel support
net.ipv4.tcp_congestion_control=bbr # Requires kernel support
vm.swappiness=133 # Example value, adjust based on system needs
EOF
	local vpn_if
	# Add IPv6 disable settings for VPN interfaces if detected and VPN flag is set
	if [[ "$VPN_FLAG" == "true" && -n "${VPN_IFACES:-}" ]]; then
		log "Adding IPv6 disable settings for VPN interfaces: $VPN_IFACES"
		while read -r vpn_if; do
			SYSCTL_UFW_CONF_CONTENT+="\nnet.ipv6.conf.${vpn_if}.disable_ipv6=1 # Disabled by ufw.sh"
		done <<<"$VPN_IFACES"
		SYSCTL_UFW_CONF_CONTENT+="\n" # Add a final newline for cleanliness
	fi

	# Array of files to configure and the variable holding their desired content
	local -a sysctl_files=(
		"${SYSCTL_CONF}|SYSCTL_CONF_CONTENT"
		"${SYSCTL_UFW_CONF}|SYSCTL_UFW_CONF_CONTENT"
	)
	local separator="|" # Define the separator used in the array

	# Ensure the sysctl.d directory exists
	if [[ ! -d "$SYSCTL_D_DIR" ]]; then
		log "Creating sysctl directory: $SYSCTL_D_DIR"
		if ! mkdir -p "$SYSCTL_D_DIR"; then
			log "Error: Failed to create sysctl directory $SYSCTL_D_DIR. Exiting."
			exit 1
		fi
	fi

	local file content_var_name content
	# Loop through the array of files
	for item in "${sysctl_files[@]}"; do
		# Split item into file path and content variable name
		file="${item%%"${separator}"*}"
		content_var_name="${item#*"${separator}"}"

		# Check if the content variable is defined and not empty
		if [[ -z "${!content_var_name:-}" ]]; then
			log "Error: Content variable '$content_var_name' is not defined or empty. Skipping $file."
			continue # Skip this file if content variable is missing
		fi
		content="${!content_var_name}" # Get the content using indirect expansion

		log "Processing sysctl file: $file"

		# Check if content matches idempotently using the helper function
		if content_matches "$file" "$content"; then
			log "$file is already correctly configured."
		else
			log "Creating or updating $file..."
			# Use printf "%s" instead of echo for writing content safely.
			# Redirect printf output to the file. run_cmd_dry logs the command execution.
			if run_cmd_dry printf "%s" "$content" >"$file"; then
				log "$file updated."
			else
				log "Error: Failed to write to $file."
				exit 1 # Exit on failure to write critical config file
			fi
		fi
	done

	log "Applying sysctl settings..."
	if [[ "$DRY_RUN" == "false" ]]; then
		log "Running: sysctl --system"
		# Apply settings and redirect output to log file
		if ! sysctl --system >>"$LOG_FILE" 2>&1; then
			log "Error: Failed to apply sysctl settings."
			exit 1 # Exit on failure to apply sysctl settings
		fi
		log "Sysctl settings applied successfully."
	else
		log "Dry-run: Would run: sysctl --system"
		log "Sysctl settings application simulated."
	fi
}

## Additional Critical Files Management

manage_additional_critical_files() {
	log "Processing additional critical configuration files..."

	# Array format: "FILE_PATH|CHECK_PATTERN|MODIFY_COMMAND|SUCCESS_MESSAGE"
	# CHECK_PATTERN: Extended regex to grep for the desired state.
	# MODIFY_COMMAND: Shell command string to execute via bash -c, with filename passed as $1.
	# SUCCESS_MESSAGE: Message to log if the check pattern is found.
	local -a ADDITIONAL_FILE_MODS=(
		"/etc/dhcpcd.conf|^[[:space:]]*noipv6\b|echo 'noipv6' >> \"\$1\"|IPv6 already disabled"
		"/etc/strongswan.conf|^[[:space:]]*strictcrlpolicy=yes\b|echo 'strictcrlpolicy=yes' >> \"\$1\"|Strict CRL policy already enabled"
		"/etc/nsswitch.conf|^[[:space:]]hosts:[[:space:]]files[[:space:]]dns\b|sed -i 's/^[[:space:]]hosts:.*$/hosts: files dns/' \"\$1\"|Hosts already configured to 'files dns'"
		"/etc/nfs.conf|^[[:space:]]*RPCMOUNTDOPTS=\"?--no-nfs-version[[:space:]]3\"?\b|echo 'RPCMOUNTDOPTS=\"--no-nfs-version 3\"' >> \"\$1\"|NFS settings already configured"
		"/etc/ipsec.conf|^[[:space:]]*charondebug=\"?ike[[:space:]]2,[[:space:]]knl[[:space:]]2,[[:space:]]cfg[[:space:]]2\"?\b|echo 'charondebug=\"ike 2, knl 2, cfg 2\"' >> \"\$1\"|charondebug already set"
		"/etc/hosts|^[[:space:]]*127\.0\.0\.1[[:space:]]+localhost\b|echo '127.0.0.1       localhost' >> \"\$1\"|localhost entry already present"
	)
	local separator="|" # Define the separator used in the array

	local FILE check_pattern modify_cmd success_msg rest
	# Loop through the array of file modifications
	for item in "${ADDITIONAL_FILE_MODS[@]}"; do
		# Split item into fields using the separator
		FILE="${item%%"${separator}"*}"
		rest="${item#*"${separator}"}"
		check_pattern="${rest%%"${separator}"*}"
		rest="${rest#*"${separator}"}"
		modify_cmd="${rest%%"${separator}"*}"
		success_msg="${rest#*"${separator}"}"

		log "Processing $FILE..."

		# Check if the file exists before attempting to modify
		if [[ ! -f "$FILE" ]]; then
			log "Warning: File $FILE not found. Skipping modification."
			continue # Skip to the next file
		fi

		# Check if the desired state already exists in the file
		if grep -qE "$check_pattern" "$FILE" 2>/dev/null; then
			log "$success_msg in $FILE."
		else
			log "Modifying $FILE..."
			# Execute the modify command string via bash -c, passing the filename as $1.
			# run_cmd_dry logs the command execution and handles dry-run.
			if run_cmd_dry bash -c "$modify_cmd" -- "$FILE"; then
				log "$FILE modified."
			else
				log "Error: Failed to modify $FILE."
				exit 1 # Exit on failure to modify critical file
			fi
		fi
	done
}

## UFW Configuration

configure_ufw() {
	log "Configuring UFW firewall rules..."

	# Define standard service ports to allow on the primary interface
	# Format: "port/protocol:Description"
	local -a SERVICES_PRIMARY_PORTS=(
		"80/tcp:HTTP Traffic"
		"443/tcp:HTTPS Traffic"
		"7531/tcp:PlayWithMPV"
		"6800/tcp:Aria2c"
	)
	# Define JDownloader ports
	local -a JDOWNLOADER_PORTS=(
		"9665/tcp:JDownloader2 Port"
		"9666/tcp:JDownloader2 Port"
	)

	local ufw_status_output=""
	# Capture current UFW status. In dry-run, provide mock status.
	if [[ "$DRY_RUN" == "false" ]]; then
		log "Capturing current UFW status..."
		# Capture output and tee to log file. Check exit status.
		# 2>&1 redirects stderr to stdout before piping to tee.
		if ! ufw_status_output=$(ufw status verbose 2>&1 | tee -a "$LOG_FILE"); then
			log "Error: Failed to get UFW status. Is UFW installed and working?"
			exit 1 # Exit if UFW status cannot be retrieved
		fi
		log "UFW status captured."
	else
		log "Dry-run: Would capture UFW status."
		# Provide a mock status for dry-run checks to work.
		# This mock status assumes inactive, default deny incoming, allow outgoing, disabled routed.
		ufw_status_output=$(
			cat <<EOF
Status: inactive
Logging: on (low)
Default: deny (incoming), allow (outgoing), disabled (routed)
New rules:
EOF
		)
	fi

	# Enable UFW if it's inactive
	if ! grep -qE "^Status:\s+active" <<<"$ufw_status_output"; then
		log "UFW is inactive. Enabling..."
		# Use --force to avoid interactive prompts
		if run_cmd_dry ufw --force enable; then
			log "UFW enabled successfully."
			# Re-capture status after enabling if not dry-run
			if [[ "$DRY_RUN" == "false" ]]; then
				log "Re-capturing UFW status after enabling..."
				if ! ufw_status_output=$(ufw status verbose 2>&1 | tee -a "$LOG_FILE"); then
					log "Error: Failed to get UFW status after enabling."
					exit 1 # Exit if UFW status cannot be retrieved after enabling
				fi
				log "UFW status re-captured."
			fi
		else
			log "Error: Failed to enable UFW."
			exit 1 # Exit on failure to enable UFW
		fi
	else
		log "UFW is already enabled."
	fi

	local default_incoming default_outgoing

	# Extract current default policies from status output
	default_incoming=$(awk '/^Default:/ {print $2}' <<<"$ufw_status_output")
	default_outgoing=$(awk '/^Default:/ {print $4}' <<<"$ufw_status_output")

	# Set default incoming policy to 'deny' if it's not already
	if [[ "$default_incoming" != "deny" ]]; then
		log "Default incoming policy is '$default_incoming'. Setting to 'deny'."
		if run_cmd_dry ufw default deny incoming; then
			log "Default incoming policy set to 'deny'."
		else
			log "Error: Failed to set default incoming policy."
			exit 1 # Exit on failure to set default policy
		fi
	else
		log "Default incoming policy is already 'deny'."
	fi

	# Set default outgoing policy to 'allow' if it's not already
	if [[ "$default_outgoing" != "allow" ]]; then
		log "Default outgoing policy is '$default_outgoing'. Setting to 'allow'."
		if run_cmd_dry ufw default allow outgoing; then
			log "Default outgoing policy set to 'allow'."
		else
			log "Error: Failed to set default outgoing policy."
			exit 1 # Exit on failure to set default policy
		fi
	else
		log "Default outgoing policy is already 'allow'."
	fi

	# Re-capture status if defaults were changed and not in dry-run
	if [[ "$DRY_RUN" == "false" ]]; then
		if [[ "$default_incoming" != "deny" ]] || [[ "$default_outgoing" != "allow" ]]; then
			log "Re-capturing UFW status after setting defaults..."
			if ! ufw_status_output=$(ufw status verbose 2>&1 | tee -a "$LOG_FILE"); then
				log "Error: Failed to get UFW status after setting defaults."
				exit 1 # Exit if UFW status cannot be retrieved
			fi
			log "UFW status re-captured."
		fi
	fi

	# Define SSH rule specifications to check for
	local ssh_rule_spec_generic="Limit in to any port 22 proto tcp comment \"Limit SSH\""
	local ssh_rule_spec_specific="Limit in on $PRIMARY_IF to any port 22 proto tcp comment \"Limit SSH\""
	local ssh_rule_exists=false

	# Check if the specific SSH rule (on primary interface) exists if PRIMARY_IF is known
	if [[ -n "${PRIMARY_IF:-}" ]]; then
		if rule_exists "$ssh_rule_spec_specific" "$ufw_status_output"; then
			ssh_rule_exists=true
		fi
	fi

	# If specific rule not found, check if the generic SSH rule exists
	if [[ "$ssh_rule_exists" == "false" ]] && rule_exists "$ssh_rule_spec_generic" "$ufw_status_output"; then
		ssh_rule_exists=true
	fi

	# Add SSH limit rule if neither specific nor generic rule exists
	if [[ "$ssh_rule_exists" == "false" ]]; then
		log "Adding rule: Limit SSH (22/tcp)."
		local -a ufw_limit_cmd=("ufw" "limit" "22/tcp")
		# Add 'on interface' if primary interface was detected
		if [[ -n "${PRIMARY_IF:-}" ]]; then
			ufw_limit_cmd+=("on" "$PRIMARY_IF")
		fi
		ufw_limit_cmd+=("comment" "Limit SSH")

		if run_cmd_dry "${ufw_limit_cmd[@]}"; then
			log "Rule added: Limit SSH (22/tcp)."
		else
			log "Error: Failed to add SSH limit rule."
			exit 1 # Exit on failure to add critical rule
		fi
	else
		log "Rule already exists: Limit SSH (22/tcp)."
	fi

	# Define loopback rule specifications
	local loopback_in_rule_spec="ALLOW in on lo to any comment \"Allow loopback traffic\""
	local loopback_out_rule_spec="ALLOW out on lo to any comment \"Allow loopback traffic\""

	# Add loopback incoming rule if it doesn't exist
	if ! rule_exists "$loopback_in_rule_spec" "$ufw_status_output"; then
		log "Adding rule: Allow loopback incoming."
		if run_cmd_dry ufw allow in on lo comment "Allow loopback traffic"; then
			log "Rule added: Allow loopback incoming."
		else
			log "Error: Failed to add loopback incoming rule."
			exit 1 # Exit on failure to add critical rule
		fi
	else
		log "Rule already exists: Allow loopback incoming."
	fi

	# Add loopback outgoing rule if it doesn't exist
	if ! rule_exists "$loopback_out_rule_spec" "$ufw_status_output"; then
		log "Adding rule: Allow loopback outgoing."
		if run_cmd_dry ufw allow out on lo comment "Allow loopback traffic"; then
			log "Rule added: Allow loopback outgoing."
		else
			log "Error: Failed to add loopback outgoing rule."
			exit 1 # Exit on failure to add critical rule
		fi
	else
		log "Rule already exists: Allow loopback outgoing."
	fi

	local service port_protocol desc port proto

	# Add rules for standard primary services on the primary interface
	for service in "${SERVICES_PRIMARY_PORTS[@]}"; do
		# Split the service string into port/protocol and description
		port_protocol="${service%%:*}"
		desc="${service#*:}"
		port="${port_protocol%%/*}"
		proto="${port_protocol#*/}"

		# Define the rule specification to check for
		local rule_spec="ALLOW in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""

		# Add the rule if it doesn't exist
		if ! rule_exists "$rule_spec" "$ufw_status_output"; then
			log "Adding rule: Allow $desc on $PRIMARY_IF port $port/$proto."
			if run_cmd_dry ufw allow in on "$PRIMARY_IF" to any port "$port" proto "$proto" comment "$desc"; then
				log "Rule added: Allow $desc on $PRIMARY_IF port $port/$proto."
			else
				log "Error: Failed to add rule for $desc on $PRIMARY_IF."
				exit 1 # Exit on failure to add rule
			fi
		else
			log "Rule exists: Allow $desc on $PRIMARY_IF port $port/$proto."
		fi
	done

	# Configure VPN-specific rules if the VPN flag is set
	if [[ "$VPN_FLAG" == "true" ]]; then
		log "VPN flag set. Configuring VPN-specific rules..."

		# Check if VPN interfaces and port were detected (should be handled by apply_configurations calling detect_vpn_port)
		if [[ -z "${VPN_IFACES:-}" ]]; then
			log "Error: No VPN interfaces detected for VPN rules. Ensure ExpressVPN is connected. Exiting."
			exit 1 # Exit if VPN rules requested but no VPN interface found
		fi
		if [[ -z "${VPN_PORT:-}" ]]; then
			log "Error: VPN port not detected for VPN rules. Exiting."
			exit 1 # Exit if VPN rules requested but port not found
		fi

		local vpn_if

		# Add rules for each detected VPN interface
		while read -r vpn_if; do
			log "Configuring rules for VPN interface: $vpn_if"
			# Define rule specifications for Lightway UDP on the VPN interface
			local rule_spec_in="ALLOW in on $vpn_if to any port $VPN_PORT proto udp comment \"Allow Lightway UDP on $vpn_if\""
			local rule_spec_out="ALLOW out on $vpn_if to any port $VPN_PORT proto udp comment \"Allow Lightway UDP on $vpn_if\""

			# Add incoming rule if it doesn't exist
			if ! rule_exists "$rule_spec_in" "$ufw_status_output"; then
				log "Adding rule: Allow Lightway UDP incoming on $vpn_if (port $VPN_PORT/udp)."
				if run_cmd_dry ufw allow in on "$vpn_if" to any port "$VPN_PORT" proto udp comment "Allow Lightway UDP on $vpn_if"; then
					log "Rule added: Allow Lightway UDP incoming on $vpn_if (port $VPN_PORT/udp)."
				else
					log "Error: Failed to add incoming VPN rule on $vpn_if."
					exit 1 # Exit on failure to add VPN rule
				fi
			else
				log "Rule exists: Allow Lightway UDP incoming on $vpn_if (port $VPN_PORT/udp)."
			fi

			# Add outgoing rule if it doesn't exist
			if ! rule_exists "$rule_spec_out" "$ufw_status_output"; then
				log "Adding rule: Allow Lightway UDP outgoing on $vpn_if (port $VPN_PORT/udp)."
				if run_cmd_dry ufw allow out on "$vpn_if" to any port "$VPN_PORT" proto udp comment "Allow Lightway UDP on $vpn_if"; then
					log "Rule added: Allow Lightway UDP outgoing on $vpn_if (port $VPN_PORT/udp)."
				else
					log "Error: Failed to add outgoing VPN rule on $vpn_if."
					exit 1 # Exit on failure to add VPN rule
				fi
			else
				log "Rule exists: Allow Lightway UDP outgoing on $vpn_if (port $VPN_PORT/udp)."
			fi
		done <<<"$VPN_IFACES" # Process substitution for loop input

	fi # End VPN_FLAG block

	# Configure JDownloader2-specific rules if the JD flag is set
	if [[ "$JD_FLAG" == "true" ]]; then
		log "JDownloader flag set. Configuring JDownloader2-specific rules..."
		local jd_rule port_protocol desc port proto

		# Loop through each JDownloader port
		for jd_rule in "${JDOWNLOADER_PORTS[@]}"; do
			# Split the JDownloader rule string
			port_protocol="${jd_rule%%:*}"
			desc="${jd_rule#*:}"
			port="${port_protocol%%/*}"
			proto="${port_protocol#*/}"
			log "Processing JDownloader port: $port/$proto ($desc)"

			# Apply rules based on whether the VPN flag is also set
			if [[ "$VPN_FLAG" == "true" ]]; then
				log "VPN flag is also set. Configuring JDownloader rules for VPN interface and denying on primary."
				# Check if VPN interfaces were detected (should be handled by apply_configurations)
				if [[ -z "${VPN_IFACES:-}" ]]; then
					log "Error: No VPN interfaces detected for JDownloader VPN rules. Exiting."
					exit 1 # Exit if JD VPN rules requested but no VPN interface found
				fi
				local vpn_if

				# Add allow rule for this port on each detected VPN interface
				while read -r vpn_if; do
					log "Configuring JD rule on VPN interface: $vpn_if"
					local rule_spec_allow_vpn="ALLOW in on $vpn_if to any port $port proto $proto comment \"$desc\""
					if ! rule_exists "$rule_spec_allow_vpn" "$ufw_status_output"; then
						log "Adding rule: Allow $desc on $vpn_if port $port/$proto."
						if run_cmd_dry ufw allow in on "$vpn_if" to any port "$port" proto "$proto" comment "$desc"; then
							log "Rule added: Allow $desc on $vpn_if port $port/$proto."
						else
							log "Error: Failed to add JDownloader rule on $vpn_if."
							exit 1 # Exit on failure to add JD rule
						fi
					else
						log "Rule exists: Allow $desc on $vpn_if port $port/$proto."
					fi
				done <<<"$VPN_IFACES" # Process substitution for loop input

				# Add deny rule for this port on the primary interface
				log "Configuring JD deny rule on primary interface: $PRIMARY_IF"
				local rule_spec_deny_primary="DENY in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""
				if ! rule_exists "$rule_spec_deny_primary" "$ufw_status_output"; then
					log "Adding rule: Deny $desc on $PRIMARY_IF port $port/$proto."
					if run_cmd_dry ufw deny in on "$PRIMARY_IF" to any port "$port" proto "$proto" comment "$desc"; then
						log "Rule added: Deny $desc on $PRIMARY_IF port $port/$proto."
					else
						log "Error: Failed to add JDownloader deny rule on $PRIMARY_IF."
						exit 1 # Exit on failure to add JD deny rule
					fi
				else
					log "Rule exists: Deny $desc on $PRIMARY_IF port $port/$proto."
				fi
			else
				log "VPN flag is NOT set. Configuring JDownloader rules for primary interface."
				# Add allow rule for this port on the primary interface if VPN is NOT active
				local rule_spec_allow_primary="ALLOW in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""
				if ! rule_exists "$rule_spec_allow_primary" "$ufw_status_output"; then
					log "Adding rule: Allow $desc on $PRIMARY_IF port $port/$proto."
					if run_cmd_dry ufw allow in on "$PRIMARY_IF" to any port "$port" proto "$proto" comment "$desc"; then
						log "Rule added: Allow $desc on $PRIMARY_IF port $port/$proto."
					else
						log "Error: Failed to add JDownloader rule on $PRIMARY_IF."
						exit 1 # Exit on failure to add JD rule
					fi
				else
					log "Rule exists: Allow $desc on $PRIMARY_IF port $port/$proto."
				fi
			fi  # End if/else VPN_FLAG check for JD rules
		done # End loop over JDownloader ports
	fi    # End JD_FLAG block

	# Disable IPv6 in UFW defaults file if enabled
	if [[ -f "$UFW_DEFAULTS_FILE" ]]; then
		# Check if IPV6=yes line exists and is not commented out. Use <<< for here-string input.
		if grep -qE "^[[:space:]]*IPV6=yes" "$UFW_DEFAULTS_FILE" 2>/dev/null; then
			log "IPv6 is enabled in UFW defaults. Disabling..."
			# Use sed -i.bak to modify in place and create a backup
			if run_cmd_dry sed -i.bak 's/^[[:space:]]*IPV6=yes/IPV6=no/' "$UFW_DEFAULTS_FILE"; then
				log "Disabled IPv6 in UFW default settings ($UFW_DEFAULTS_FILE). Backup created: ${UFW_DEFAULTS_FILE}.bak"
			else
				log "Warning: Failed to disable IPv6 in $UFW_DEFAULTS_FILE."
			fi
		else
			log "IPv6 is already disabled or not explicitly enabled as 'IPV6=yes' in UFW defaults."
		fi
	else
		log "Warning: UFW defaults file $UFW_DEFAULTS_FILE not found. Cannot configure IPv6 default."
	fi

	log "Reloading UFW rules..."
	# Reload UFW to apply changes
	if run_cmd_dry ufw reload; then
		log "UFW reloaded successfully."
		# Re-capture status after reload if not dry-run
		if [[ "$DRY_RUN" == "false" ]]; then
			log "Re-capturing UFW status after reload..."
			if ! ufw_status_output=$(ufw status verbose 2>&1 | tee -a "$LOG_FILE"); then
				log "Error: Failed to get UFW status after reload."
				exit 1 # Exit if UFW status cannot be retrieved
			fi
			log "UFW status re-captured."
		fi
	else
		log "Error: Failed to reload UFW."
		exit 1 # Exit on failure to reload UFW
	fi

	log "UFW firewall rules configuration complete."
}

## Validate Critical Configurations

validate_configurations() {
	log "Validating critical configurations..."

	# --- Validate Sysctl Settings ---
	log "Validating sysctl settings..."
	# List of expected sysctl settings and their values
	local -a APPLIED_SYSCTL_SETTINGS=(
		"net.ipv4.ip_forward=1"
		"net.ipv4.conf.all.accept_redirects=0"
		"net.ipv4.conf.default.accept_redirects=0"
		"net.ipv4.conf.all.rp_filter=1"
		"net.ipv4.conf.default.rp_filter=1"
		"net.ipv4.conf.default.accept_source_route=0"
		"net.ipv4.conf.all.accept_source_route=0"
		"net.ipv4.icmp_ignore_bogus_error_responses=1"
		"net.ipv4.conf.default.log_martians=0"
		"net.ipv4.conf.all.log_martians=0"
		"net.ipv4.icmp_echo_ignore_broadcasts=1"
		"net.ipv4.icmp_echo_ignore_all=0"
		"net.ipv4.tcp_sack=1"
		"vm.swappiness=133"
		"net.core.rmem_max=16777216"
		"net.core.wmem_max=16777216"
		"net.core.optmem_max=65536"
		"net.ipv4.tcp_rmem=4096 87380 16777216"
		"net.ipv4.tcp_wmem=4096 65536 16777216"
		"net.core.somaxconn=8192"
		"net.ipv4.tcp_window_scaling=1"
		"net.core.netdev_max_backlog=5000"
		"net.ipv4.udp_rmem_min=8192"
		"net.ipv4.udp_wmem_min=8192"
		"net.ipv4.tcp_fastopen=3"
		"net.ipv4.tcp_tw_reuse=1"
		"net.ipv4.tcp_fin_timeout=10"
		"net.ipv4.tcp_slow_start_after_idle=0"
		"net.ipv4.tcp_keepalive_time=60"
		"net.ipv4.tcp_keepalive_intvl=10"
		"net.ipv4.tcp_keepalive_probes=6"
		"net.ipv4.tcp_mtu_probing=1"
		"net.ipv4.tcp_timestamps=0"
		"net.core.default_qdisc=cake"
		"net.ipv4.tcp_congestion_control=bbr"
	)
	local vpn_if
	# Add IPv6 disable settings for VPN interfaces to the validation list if applicable
	if [[ "$VPN_FLAG" == "true" && -n "${VPN_IFACES:-}" ]]; then
		log "Adding IPv6 disable settings for VPN interfaces to validation list: $VPN_IFACES"
		while read -r vpn_if; do
			APPLIED_SYSCTL_SETTINGS+=("net.ipv6.conf.${vpn_if}.disable_ipv6=1")
		done <<<"$VPN_IFACES"
	fi

	local setting key expected_value actual_value key_trimmed expected_trimmed actual_trimmed
	# Loop through each expected sysctl setting
	for setting in "${APPLIED_SYSCTL_SETTINGS[@]}"; do
		# Split setting into key and expected value
		key="${setting%%=*}"
		expected_value="${setting#*=}"

		# Trim whitespace from key and expected value for robust comparison
		key_trimmed=$(sed 's/^[[:space:]]//;s/[[:space:]]$//' <<<"$key")
		expected_trimmed=$(sed 's/^[[:space:]]//;s/[[:space:]]$//' <<<"$expected_value")

		# Get the actual applied value from sysctl. Handle unset/errors gracefully.
		# Redirect stderr to /dev/null in case the key doesn't exist.
		actual_value=$(sysctl -n "$key_trimmed" 2>/dev/null || echo "unset")

		# Trim and normalize actual value whitespace (replace multiple spaces with single, trim ends)
		actual_trimmed=$(tr -s '[:space:]' ' ' <<<"$actual_value" | sed 's/^[[:space:]]//;s/[[:space:]]$//')

		# Compare actual value with expected value
		if [[ "$actual_trimmed" == "$expected_trimmed" ]]; then
			log "Validation passed: sysctl $key_trimmed = $actual_value"
		else
			log "Validation failed: sysctl $key_trimmed expected '$expected_value' but got '$actual_value'"
			exit 1 # Exit on sysctl validation failure
		fi
	done
	log "Sysctl settings validated successfully."

	# --- Validate UFW Rules ---
	log "Validating UFW rules..."
	local ufw_status_output=""
	# Skip UFW validation in dry-run as status is not real
	if [[ "$DRY_RUN" == "false" ]]; then
		# Get current UFW status for validation. Capture output and tee to log file.
		# 2>&1 redirects stderr to stdout before piping to tee.
		if ! ufw_status_output=$(ufw status verbose 2>&1 | tee -a "$LOG_FILE"); then
			log "Error: Failed to get UFW status for validation."
			exit 1 # Exit if UFW status cannot be retrieved for validation
		fi
	else
		log "Dry-run: Skipping UFW validation as status is not real."
		return 0 # Skip validation in dry-run
	fi

	# Validate default policies. Use <<< for here-string input.
	local default_incoming default_outgoing
	default_incoming=$(awk '/^Default:/ {print $2}' <<<"$ufw_status_output")
	default_outgoing=$(awk '/^Default:/ {print $4}' <<<"$ufw_status_output")

	if [[ "$default_incoming" == "deny" ]]; then
		log "Validation passed: Default incoming policy is 'deny'."
	else
		log "Validation failed: Default incoming policy is not 'deny' ('$default_incoming')."
		exit 1 # Exit on default policy validation failure
	fi

	if [[ "$default_outgoing" == "allow" ]]; then
		log "Validation passed: Default outgoing policy is 'allow'."
	else
		log "Validation failed: Default outgoing policy is not 'allow' ('$default_outgoing')."
		exit 1 # Exit on default policy validation failure
	fi

	# Validate SSH rule (check for specific or generic).
	local ssh_rule_spec_generic="Limit in to any port 22 proto tcp comment \"Limit SSH\""
	local ssh_rule_spec_specific="Limit in on $PRIMARY_IF to any port 22 proto tcp comment \"Limit SSH\""
	local ssh_rule_found=false

	# Check for the specific rule first if PRIMARY_IF is known
	if [[ -n "${PRIMARY_IF:-}" ]]; then
		if rule_exists "$ssh_rule_spec_specific" "$ufw_status_output"; then
			ssh_rule_found=true
		fi
	fi
	# Also check for the generic rule, in case the interface wasn't specified during add
	if [[ "$ssh_rule_found" == "false" ]] && rule_exists "$ssh_rule_spec_generic" "$ufw_status_output"; then
		ssh_rule_found=true
	fi

	if [[ "$ssh_rule_found" == "true" ]]; then
		log "Validation passed: Limit SSH rule exists."
	else
		log "Validation failed: Limit SSH rule missing."
		exit 1 # Exit on missing SSH rule
	fi

	# Validate loopback rules.
	local loopback_in_rule_spec="ALLOW in on lo to any comment \"Allow loopback traffic\""
	if rule_exists "$loopback_in_rule_spec" "$ufw_status_output"; then
		log "Validation passed: Allow loopback incoming rule exists."
	else
		log "Validation failed: Allow loopback incoming rule missing."
		exit 1 # Exit on missing loopback rule
	fi
	# Check for outgoing loopback rule
	local loopback_out_rule_spec="ALLOW out on lo to any comment \"Allow loopback traffic\""
	if rule_exists "$loopback_out_rule_spec" "$ufw_status_output"; then
		log "Validation passed: Allow loopback outgoing rule exists."
	else
		log "Validation failed: Allow loopback outgoing rule missing."
		exit 1 # Exit on missing loopback rule
	fi

	# Validate primary services rules on PRIMARY_IF.
	local service port_protocol desc port proto
	# Define standard service ports to allow on the primary interface (re-declared for clarity in validation)
	local -a SERVICES_PRIMARY_PORTS=(
		"80/tcp:HTTP Traffic"
		"443/tcp:HTTPS Traffic"
		"7531/tcp:PlayWithMPV"
		"6800/tcp:Aria2c"
	)
	for service in "${SERVICES_PRIMARY_PORTS[@]}"; do
		# Split the service string using parameter expansion
		port_protocol="${service%%:*}"
		desc="${service#*:}"
		port="${port_protocol%%/*}"
		proto="${port_protocol#*/}"
		# Construct the expected rule string
		local rule_spec="ALLOW in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""
		# Check if the rule exists
		if rule_exists "$rule_spec" "$ufw_status_output"; then
			log "Validation passed: $port_protocol rule exists on $PRIMARY_IF."
		else
			log "Validation failed: $port_protocol rule missing on $PRIMARY_IF."
			exit 1 # Exit on missing primary service rule
		fi
	done

	# Validate VPN and JDownloader rules based on flags
	if [[ "$VPN_FLAG" == "true" ]]; then
		log "Validating VPN-specific rules..."
		# Check if VPN interfaces and port were detected (should be if flag is set)
		if [[ -z "${VPN_IFACES:-}" ]]; then
			log "Error: VPN flag set but no VPN interfaces detected during validation."
			exit 1 # Exit if VPN flag set but no interfaces found
		fi
		# VPN_PORT is assumed 443 if VPN_FLAG is true and interfaces found, no need to check detection here
		# if [[ -z "${VPN_PORT:-}" ]]; then
		# 	log "Error: VPN flag set but VPN port not detected during validation."
		# 	exit 1 # Exit if VPN flag set but port not found
		# fi
		local vpn_if
		# Read VPN interfaces line by line from the variable. Use <<< for here-string input.
		while read -r vpn_if; do
			log "Validating rules for VPN interface: $vpn_if"
			# Validate Lightway UDP rules (in and out)
			local rule_spec_in="ALLOW in on $vpn_if to any port $VPN_PORT proto udp comment \"Allow Lightway UDP on $vpn_if\""
			local rule_spec_out="ALLOW out on $vpn_if to any port $VPN_PORT proto udp comment \"Allow Lightway UDP on $vpn_if\""
			if rule_exists "$rule_spec_in" "$ufw_status_output"; then
				log "Validation passed: Allow Lightway UDP incoming rule exists on $vpn_if."
			else
				log "Validation failed: Allow Lightway UDP incoming rule missing on $vpn_if."
				exit 1 # Exit on missing VPN rule
			fi
			if rule_exists "$rule_spec_out" "$ufw_status_output"; then
				log "Validation passed: Allow Lightway UDP outgoing rule exists on $vpn_if."
			else
				log "Validation failed: Allow Lightway UDP outgoing rule missing on $vpn_if."
				exit 1 # Exit on missing VPN rule
			fi
		done <<<"$VPN_IFACES" # Process substitution for loop input
	fi                     # End VPN_FLAG validation

	if [[ "$JD_FLAG" == "true" ]]; then
		log "Validating JDownloader2-specific rules..."
		# Define JDownloader ports (re-declared for clarity in validation)
		local -a JDOWNLOADER_PORTS=(
			"9665/tcp:JDownloader2 Port"
			"9666/tcp:JDownloader2 Port"
		)
		local jd_rule port_protocol desc port proto

		# Loop through each JDownloader port
		for jd_rule in "${JDOWNLOADER_PORTS[@]}"; do
			# Split the JDownloader rule string using parameter expansion
			port_protocol="${jd_rule%%:*}"
			desc="${jd_rule#*:}"
			port="${port_protocol%%/*}"
			proto="${port_protocol#*/}"
			log "Validating JDownloader port: $port/$proto ($desc)"

			if [[ "$VPN_FLAG" == "true" ]]; then
				log "Validating JDownloader rules for VPN interface."
				if [[ -z "${VPN_IFACES:-}" ]]; then
					log "Error: JD and VPN flags set but no VPN interfaces detected during validation."
					exit 1 # Exit if JD/VPN flags set but no interfaces found
				fi
				local vpn_if
				# Loop through each detected VPN interface for this specific port. Use <<< for here-string input.
				while read -r vpn_if; do
					log "Validating JD rule on VPN interface: $vpn_if"
					# Validate Allow JD on VPN interface rule
					local rule_spec_allow_vpn="ALLOW in on $vpn_if to any port $port proto $proto comment \"$desc\""
					if rule_exists "$rule_spec_allow_vpn" "$ufw_status_output"; then
						log "Validation passed: Allow $desc rule exists on $vpn_if."
					else
						log "Validation failed: Allow $desc rule missing on $vpn_if."
						exit 1 # Exit on missing JD VPN rule
					fi
				done <<<"$VPN_IFACES" # Process substitution for loop input

				# Validate Deny JD on PRIMARY_IF rule if VPN is active
				log "Validating JD deny rule on primary interface: $PRIMARY_IF"
				local rule_spec_deny_primary="DENY in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""
				if rule_exists "$rule_spec_deny_primary" "$ufw_status_output"; then
					log "Validation passed: Deny $desc rule exists on $PRIMARY_IF."
				else
					log "Validation failed: Deny $desc rule missing on $PRIMARY_IF."
					exit 1 # Exit on missing JD deny rule
				fi
			else
				log "VPN flag is NOT set. Validating JDownloader rules for primary interface."
				# Validate Allow JD on PRIMARY_IF rule if VPN is NOT active
				local rule_spec_allow_primary="ALLOW in on $PRIMARY_IF to any port $port proto $proto comment \"$desc\""
				if rule_exists "$rule_spec_allow_primary" "$ufw_status_output"; then
					log "Validation passed: Allow $desc rule exists on $PRIMARY_IF."
				else
					log "Validation failed: Allow $desc rule missing on $PRIMARY_IF."
					exit 1 # Exit on missing JD primary rule
				fi
			fi  # End if/else VPN_FLAG check for JD validation
		done # End loop over JDownloader ports
	fi    # End JD_FLAG validation

	# Validate IPv6 disabled in defaults file
	if [[ -f "$UFW_DEFAULTS_FILE" ]]; then
		# Check if IPV6=no line exists and is not commented out. Use <<< for here-string input.
		if grep -qE "^[[:space:]]*IPV6=no" "$UFW_DEFAULTS_FILE" 2>/dev/null; then
			log "Validation passed: IPv6 is disabled in UFW defaults."
		else
			# This might not be a fatal error depending on requirements, but log it as a warning.
			log "Warning: IPv6 is not disabled as 'IPV6=no' in UFW defaults."
		fi
	else
		log "Warning: UFW defaults file $UFW_DEFAULTS_FILE not found during validation."
	fi

	log "All critical configurations validated successfully."
}

## Final Verification

final_verification() {
	echo "" # Add a blank line for readability
	log "### Final UFW Status ###"
	if [[ "$DRY_RUN" == "false" ]]; then
		# Display status and tee to log file
		ufw status verbose 2>&1 | tee -a "$LOG_FILE"
	else
		log "Dry-run: Would display UFW status."
	fi
	echo "" # Add a blank line for readability
	log "### Current Listening Ports (ss -tunlp) ###"
	if [[ "$DRY_RUN" == "false" ]]; then
		# Display listening ports and tee to log file
		ss -tunlp 2>&1 | tee -a "$LOG_FILE"
	else
		log "Dry-run: Would display listening ports."
	fi
}

## Apply Configurations

apply_configurations() {
	log "Applying configurations..."

	# Detect VPN interfaces and port before configuring sysctl or ufw if VPN is requested
	if [[ "$VPN_FLAG" == "true" ]]; then
		# detect_vpn_port now handles interface detection internally and exits on failure
		detect_vpn_port
		# VPN_PORT is set to 443 inside detect_vpn_port if successful
	fi

	configure_sysctl
	manage_additional_critical_files
	configure_ufw
	validate_configurations # Validate after applying configurations
}

## Main Entry Point

check_root "$@"
parse_args "$@"
check_dependencies
detect_primary_interface
apply_configurations
final_verification

echo "" # Add a blank line for readability
log "Ufw complete and firewall setup!"

exit 0
