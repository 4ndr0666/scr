#!/bin/bash
# Author: 4ndr0666
set -euo pipefail
# ================= // MAKEX //
## Description: Ensure potential script files in a directory have user executable permission.
#               Processes files ending in .sh or starting with a #!.*sh shebang,
#               excluding files within .git directories, README, .md, .txt, and only chmods
#               files that currently lack user executable permission.
## Usage:       makex.sh [DIR]   (default: current dir)
# ----------------------------------------------------------------------------

DEFAULT_DIR="."
SHEBANG_PATTERN='^#!.*\b(bash|sh|zsh|dash|ksh|ash)\b'

# Declare color variables. They will remain empty if tput is not available or stdout is not a TTY.
declare COLOR_GLOW=""
declare COLOR_BUG=""
declare COLOR_INFO=""
declare COLOR_BANNER_START=""
declare COLOR_RESET=""

# Check if tput is available and stdout is a terminal to enable colors.
if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
    COLOR_GLOW=$(tput setaf 6) # Cyan
    COLOR_BUG=$(tput setaf 1)  # Red
    COLOR_INFO=$(tput setaf 4) # Blue
    COLOR_BANNER_START=$(tput setaf 5) # Magenta
    COLOR_RESET=$(tput sgr0)
fi

# Helper function for success messages
GLOW() {
    local message="$*"
    printf '%s[✔️] %s%s\n' "$COLOR_GLOW" "$message" "$COLOR_RESET"
}

# Helper function for error messages (printed to stderr)
BUG() {
    local message="$*"
    printf '%s[❌] %s%s\n' "$COLOR_BUG" "$message" "$COLOR_RESET" >&2
}

# Helper function for informational messages
INFO() {
    local message="$*"
    printf '%s[➡️] %s%s\n' "$COLOR_INFO" "$message" "$COLOR_RESET"
}

# Function to pause script execution and wait for user input
pause_prompt() {
    local oldstty # Variable to store current stty settings
    GLOW "Press any key to continue..."

    # Save current stty settings
    if ! oldstty=$(stty -g); then
        BUG "Failed to save stty settings."
        return 1
    fi

    # Set stty to cbreak mode (read char by char) and disable echo
    # If this fails, return immediately.
    if ! stty cbreak -echo; then
        BUG "Failed to set stty cbreak -echo."
        return 1
    fi

    # Read a single character without displaying it
    read -r -n 1 -s

    # Restore original stty settings. Use || true to prevent set -e from exiting
    # if stty restoration itself fails (less critical than initial setup failing).
    stty "$oldstty" || BUG "Failed to restore stty settings."
    printf '\n' # Print a newline after the key press
}

# Clear the terminal if the 'clear' command is available
command -v clear >/dev/null 2>&1 && clear

# ASCII art banner for visual appeal
banner="███╗   ███╗ █████╗ ██╗  ██╗███████╗██╗  ██╗
████╗ ████║██╔══██╗██║ ██╔╝██╔════╝╚██╗██╔╝
██╔████╔██║███████║█████╔╝ ██████╗   ╚███╔╝
██║╚██╔╝██║██╔══██║██╔═██╗ ██╔══╝   ██╔██╗
██║ ╚═╝ ██║██║  ██║██║  ██╗███████╗██╔╝ ██╗
╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝"

# Print the banner with colors
printf '%s%s%s\n\n' "$COLOR_BANNER_START" "$banner" "$COLOR_RESET"
printf "Ensuring potential script files have user executable permission...\n\n"

# Pause execution to allow user to read the banner/description
pause_prompt

# Determine the target directory: use the first argument or the default current directory.
DIR="${1:-$DEFAULT_DIR}"

# Validate if the target is a directory
if [ ! -d "$DIR" ]; then
    BUG "Error: Directory '$DIR' not found or is not a directory."
    exit 1
fi

INFO "Searching for non-executable scripts in '$DIR'..."

# Create a temporary file to store the list of files found by 'find'.
# This is crucial for handling filenames with spaces or special characters.
TEMP_FILE=$(mktemp)
# Ensure the temporary file is removed upon script exit (success or failure).
trap 'rm -f "$TEMP_FILE"' EXIT

# Find all files that meet the criteria:
# - Regular files (-type f)
# - Not within a .git directory (! -path "*/.git/*")
# - Not common documentation/text files (! -name "*.md", etc.)
# - Are either a .sh file OR have a shell shebang (checked by 'head | grep')
#   IMPORTANT: The `-exec sh -c '...'` is used to run a pipeline (head | grep)
#   within `find`, as `find -exec` does not directly support pipes.
#   "$0" and "$1" in the sh -c string refer to {} and "$SHEBANG_PATTERN" respectively.
# - Do NOT already have user executable permission (! -perm -u=x)
# - Print results null-delimited (-print0) to the temporary file.
find "$DIR" \
    -type f \
    ! -path "*/.git/*" \
    ! -name "*.md" \
    ! -name "*.MD" \
    ! -name "*.markdown" \
    ! -name "*.txt" \
    ! -name "*.TXT" \
    ! -name "README" \
    ! -name "README.md" \
    ! -name "README.MD" \
    ! -name "*.rst" \
    \( -name "*.sh" -o -exec sh -c 'head -n 1 "$0" | grep -Eq "$1"' {} "$SHEBANG_PATTERN" \; \) \
    ! -perm -u=x \
    -print0 > "$TEMP_FILE"

# Count the number of files found by 'find'
files_found_by_find=0
while IFS= read -r -d '' file; do
    files_found_by_find=$((files_found_by_find + 1))
done < "$TEMP_FILE"

# If no files were found requiring action, exit successfully.
if [ "$files_found_by_find" -eq 0 ]; then
    GLOW "No files found requiring executable permission."
    exit 0
fi

files_made_executable=0
files_failed=0

INFO "Processing $files_found_by_find file(s)..."

# Iterate over the files listed in the temporary file (null-delimited)
while IFS= read -r -d '' file; do
    # Files in TEMP_FILE already satisfy the criteria from the find command.
    # No need to re-check extension or shebang here, as 'find' already filtered them.
    INFO "Attempting to make executable: '$file'"
    if chmod u+x "$file"; then
        GLOW "Successfully made executable: '$file'"
        files_made_executable=$((files_made_executable + 1))
    else
        BUG "Failed to make executable: '$file'"
        files_failed=$((files_failed + 1))
    fi
done < "$TEMP_FILE"

printf '\n'
INFO "Summary:"
INFO "  Files found requiring executability: $files_found_by_find"
INFO "  Files successfully made executable: $files_made_executable"

# Provide a final status based on whether any files failed to be made executable.
if [ "$files_failed" -gt 0 ]; then
    BUG "  Files failed to make executable: $files_failed"
    exit 1 # Exit with error status if any file failed
else
    # If files were found and all were successfully processed, show a success message.
    [ "$files_found_by_find" -gt 0 ] && GLOW "  All found files successfully made executable."
    exit 0 # Exit with success status
fi
