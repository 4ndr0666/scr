#!/bin/bash
# Author: 4ndr0666
# Enhanced by: Ψ-Anarch
set -euo pipefail

# ================= // MAKEX //
## Description: Manages executable permissions in a directory.
#               - Default Mode: Makes scripts executable, makes non-scripts non-executable.
#               - Reverse Mode: Makes scripts non-executable, makes non-scripts executable.
## Usage:       makex.sh [-r | --reverse] [DIR]   (default: current dir)
# ----------------------------------------------------------------------------

DEFAULT_DIR="."
SHEBANG_PATTERN='^#!.*\b(bash|sh|zsh|dash|ksh|ash)\b'

# --- Configuration ---

# Patterns for files that should NOT be made executable, even if they have a shebang.
EXEC_EXCLUSION_PATTERNS=(
    "*.md" "*.MD" "*.markdown"
    "*.txt" "*.TXT"
    "README" "README.md" "README.MD"
    "*.rst"
)

# Patterns for files that should NEVER be executable (in default mode).
NON_EXEC_PATTERNS=(
    "*.md" "*.MD" "*.markdown"
    "*.txt" "*.TXT"
    "*.pdf" "*.PDF"
    "*.jpg" "*.jpeg" "*.png" "*.gif" "*.svg"
    "*.json" "*.yml" "*.yaml"
    "*.csv" "*.html" "*.css"
    "*.rst" "README"
)

# --- Color and Helper Functions ---

# Declare color variables. They will remain empty if tput is not available or stdout is not a TTY.
declare COLOR_GLOW="" COLOR_BUG="" COLOR_INFO="" COLOR_BANNER_START="" COLOR_RESET=""

if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
    COLOR_GLOW=$(tput setaf 6) # Cyan
    COLOR_BUG=$(tput setaf 1)  # Red
    COLOR_INFO=$(tput setaf 4) # Blue
    COLOR_BANNER_START=$(tput setaf 5) # Magenta
    COLOR_RESET=$(tput sgr0)
fi

GLOW() { printf '%s[✔️] %s%s\n' "$COLOR_GLOW" "$*" "$COLOR_RESET"; }
BUG() { printf '%s[❌] %s%s\n' "$COLOR_BUG" "$*" "$COLOR_RESET" >&2; }
INFO() { printf '%s[➡️] %s%s\n' "$COLOR_INFO" "$*" "$COLOR_RESET"; }

usage() {
    cat <<EOH
Usage: ${0##*/} [-r | --reverse] [DIR]

Manages executable permissions in a directory.

Default Mode:
  - Adds executable permission for the user (u+x) to shell scripts.
  - Removes all executable permissions (a-x) from common non-script files
    (e.g., .md, .txt, .jpg).

Options:
  -r, --reverse   Perform the opposite actions:
                  - Removes user executable permission (u-x) from scripts.
                  - Adds user executable permission (u+x) to non-scripts.
  [DIR]           The target directory to process (default: current directory).
  -h, --help      Show this help message.
EOH
}

# --- Script Argument Parsing ---

REVERSE_MODE=0
declare -a positional_args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -r|--reverse)
        REVERSE_MODE=1
        shift
        ;;
        -h|--help)
        usage
        exit 0
        ;;
        -*)
        BUG "Error: Unknown option '$1'"
        usage
        exit 1
        ;;
        *)
        positional_args+=("$1")
        shift
        ;;
    esac
done

DIR="${positional_args[0]:-$DEFAULT_DIR}"
if [ ! -d "$DIR" ]; then
    BUG "Error: Directory '$DIR' not found or is not a directory."
    exit 1
fi

# --- Mode-dependent variable setup ---

declare MODE_NAME
declare -a SCRIPT_PERM_CHECK_ARGS SCRIPT_CHMOD_OP SCRIPT_ACTION_VERB SCRIPT_PAST_TENSE_VERB
declare -a NON_SCRIPT_PERM_CHECK_ARGS NON_SCRIPT_CHMOD_OP NON_SCRIPT_ACTION_VERB NON_SCRIPT_PAST_TENSE_VERB

if [ "$REVERSE_MODE" -eq 1 ]; then
    MODE_NAME="Reverse"
    SCRIPT_PERM_CHECK_ARGS=("-perm" "/u=x") # Find scripts that ARE executable
    SCRIPT_CHMOD_OP="u-x"
    SCRIPT_ACTION_VERB="non-executable"
    SCRIPT_PAST_TENSE_VERB="removed executable permission from"

    NON_SCRIPT_PERM_CHECK_ARGS=("!" "-perm" "-u=x") # Find non-scripts that ARE NOT executable
    NON_SCRIPT_CHMOD_OP="u+x"
    NON_SCRIPT_ACTION_VERB="executable"
    NON_SCRIPT_PAST_TENSE_VERB="made"
else
    MODE_NAME="Default"
    SCRIPT_PERM_CHECK_ARGS=("!" "-perm" "-u=x") # Find scripts that ARE NOT executable
    SCRIPT_CHMOD_OP="u+x"
    SCRIPT_ACTION_VERB="executable"
    SCRIPT_PAST_TENSE_VERB="made"

    NON_SCRIPT_PERM_CHECK_ARGS=("-perm" "/a=x") # Find non-scripts that ARE executable
    NON_SCRIPT_CHMOD_OP="a-x"
    NON_SCRIPT_ACTION_VERB="non-executable"
    NON_SCRIPT_PAST_TENSE_VERB="removed executable permission from"
fi

# --- Script Start ---

command -v clear >/dev/null 2>&1 && clear

banner="███╗   ███╗ █████╗ ██╗  ██╗███████╗██╗  ██╗
████╗ ████║██╔══██╗██║ ██╔╝██╔════╝╚██╗██╔╝
██╔████╔██║███████║█████╔╝ ██████╗   ╚███╔╝
██║╚██╔╝██║██╔══██║██╔═██╗ ██╔══╝   ██╔██╗
██║ ╚═╝ ██║██║  ██║██║  ██╗███████╗██╔╝ ██╗
╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝"

printf '%s%s%s\n\n' "$COLOR_BANNER_START" "$banner" "$COLOR_RESET"
INFO "Running in $MODE_NAME mode."
printf "Managing executable permissions in '$DIR'...\n\n"

TEMP_FILE_ADD=$(mktemp)
TEMP_FILE_REMOVE=$(mktemp)
trap 'rm -f "$TEMP_FILE_ADD" "$TEMP_FILE_REMOVE"' EXIT

# Initialize counters for summary
files_changed_phase1=0
files_changed_phase2=0
total_failures=0

# ==============================================================================
# PHASE 1: PROCESS SCRIPTS
# ==============================================================================
INFO "PHASE 1: Searching for scripts to make $SCRIPT_ACTION_VERB..."

declare -a find_exclusion_args=()
for pattern in "${EXEC_EXCLUSION_PATTERNS[@]}"; do
    find_exclusion_args+=("!" "-name" "$pattern")
done

find "$DIR" \
    -type f \
    ! -path "*/.git/*" \
    "${find_exclusion_args[@]}" \
    \( -name "*.sh" -o -exec sh -c 'head -n 1 "$0" | grep -Eq "$1"' {} "$SHEBANG_PATTERN" \; \) \
    "${SCRIPT_PERM_CHECK_ARGS[@]}" \
    -print0 > "$TEMP_FILE_ADD"

if [ -s "$TEMP_FILE_ADD" ]; then
    mapfile -d '' files_to_process < "$TEMP_FILE_ADD"
    INFO "Found ${#files_to_process[@]} script(s). Processing..."
    for file in "${files_to_process[@]}"; do
        INFO "Attempting: chmod $SCRIPT_CHMOD_OP '$file'"
        if chmod "$SCRIPT_CHMOD_OP" "$file"; then
            GLOW "Success: $SCRIPT_PAST_TENSE_VERB '$file'."
            files_changed_phase1=$((files_changed_phase1 + 1))
        else
            BUG "Failure: could not modify '$file'."
            total_failures=$((total_failures + 1))
        fi
    done
else
    GLOW "No scripts found requiring permission changes."
fi
printf '\n'

# ==============================================================================
# PHASE 2: PROCESS NON-SCRIPTS
# ==============================================================================
INFO "PHASE 2: Searching for non-scripts to make $NON_SCRIPT_ACTION_VERB..."

declare -a find_non_exec_args=()
if [ ${#NON_EXEC_PATTERNS[@]} -gt 0 ]; then
    find_non_exec_args+=("-name" "${NON_EXEC_PATTERNS[0]}")
    for ((i=1; i<${#NON_EXEC_PATTERNS[@]}; i++)); do
        find_non_exec_args+=("-o" "-name" "${NON_EXEC_PATTERNS[i]}")
    done
fi

find "$DIR" \
    -type f \
    ! -path "*/.git/*" \
    "${NON_SCRIPT_PERM_CHECK_ARGS[@]}" \
    \( "${find_non_exec_args[@]}" \) \
    -print0 > "$TEMP_FILE_REMOVE"

if [ -s "$TEMP_FILE_REMOVE" ]; then
    mapfile -d '' files_to_process < "$TEMP_FILE_REMOVE"
    INFO "Found ${#files_to_process[@]} non-script file(s). Processing..."
    for file in "${files_to_process[@]}"; do
        INFO "Attempting: chmod $NON_SCRIPT_CHMOD_OP '$file'"
        if chmod "$NON_SCRIPT_CHMOD_OP" "$file"; then
            GLOW "Success: $NON_SCRIPT_PAST_TENSE_VERB '$file'."
            files_changed_phase2=$((files_changed_phase2 + 1))
        else
            BUG "Failure: could not modify '$file'."
            total_failures=$((total_failures + 1))
        fi
    done
else
    GLOW "No non-script files found requiring permission changes."
fi
printf '\n'

# ==============================================================================
# SUMMARY
# ==============================================================================
INFO "Summary for $MODE_NAME mode:"
GLOW "  Script permissions changed: $files_changed_phase1"
GLOW "  Non-script permissions changed: $files_changed_phase2"

if [ "$total_failures" -gt 0 ]; then
    BUG "  Total operations failed: $total_failures"
    exit 1
else
    GLOW "  All operations completed successfully."
    exit 0
fi
