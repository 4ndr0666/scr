#!/usr/bin/env bash
# Author: 4ndr0666
# pi-image-capture.sh â€” Capture a Raspberry Pi SD card into a distributable image with shrink, verify, and compression.
# Deterministic, non-interactive, auto-mount aware, with TUI (fzf/plain), per-host Markdown report, and hardened fallbacks.
# License: MIT

set -Eeuo pipefail
VERSION="1.4.0"

# ======================= // 4NDR0NIS //
# Purpose: Host-side capture of a powered-off Pi SD/microSD to .img[.xz|.gz|.zst], with ext4-min shrink if root is last.
# =======================

# --------------------------- Defaults / Flags ---------------------------
SRC_DEV=""                # e.g. /dev/sdb or /dev/mmcblk0
OUT_IMG=""                # e.g. /path/raspi.img or .img.xz/.gz/.zst
COMPRESS="auto"           # auto|xz|gz|zst|none
FAST_DD=0                 # prefer dd over ddrescue
NO_SHRINK=0               # skip shrink stage
VERIFY=0                  # fsck -n + read-only mount checks
QUIET=0
JSON=0
COLOR=1
LOG_FILE=""
FORCE=0                   # auto-confirm prompts
TUI=0                     # launch TUI if args omitted
TIMEOUT_SECS="${TIMEOUT_SECS:-0}"  # 0 = no timeout
REPORT_DIR=""             # where to write Markdown report
REPORT_PATH=""            # full path, auto-filled
START_TS="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
HOST_ID="$(hostnamectl --static 2>/dev/null || hostname || echo unknown-host)"

# --------------------------- Logging ----------------------------
_ts() { date +"%Y-%m-%dT%H:%M:%S%z"; }
_emit(){
  local lvl="$1"; shift; local msg="$*"
  [[ -n "$LOG_FILE" ]] && printf "%s %s %s\n" "$(_ts)" "$lvl" "$msg" >>"$LOG_FILE"
  if [[ $JSON -eq 1 ]]; then
    printf '{ "ts":"%s","level":"%s","msg":%q }\n' "$(_ts)" "$lvl" "$msg"
  else
    [[ $QUIET -eq 1 && "$lvl" != "ERR" ]] && return 0
    if [[ $COLOR -eq 1 ]]; then
      case "$lvl" in
        INFO) printf "\033[1;34m[INFO]\033[0m %s\n" "$msg" ;;
        WARN) printf "\033[1;33m[WARN]\033[0m %s\n" "$msg" ;;
        DONE) printf "\033[1;32m[DONE]\033[0m %s\n" "$msg" ;;
        ERR)  printf "\033[1;31m[ERR ]\033[0m %s\n" "$msg" ;;
        *)    printf "[%s] %s\n" "$lvl" "$msg" ;;
      esac
    else
      printf "[%s] %s\n" "$lvl" "$msg"
    fi
  fi
}
log()  { _emit INFO "$*"; }
warn() { _emit WARN "$*"; }
ok()   { _emit DONE "$*"; }
err()  { _emit ERR  "$*"; }

# --------------------------- Usage ------------------------------
usage(){
cat <<EOF
pi-image-capture.sh v$VERSION
Capture a powered-off Raspberry Pi SD card to a distributable image, shrink, verify, and compress.
Safe, non-interactive shrink using sfdisk fallback. Auto-unmounts desktop auto-mounts. TUI available.

Usage:
  sudo $0 -s /dev/sdX -o /path/raspi.img[.xz|.gz|.zst] [options]
  sudo $0 --tui                                  # guided selection with fzf (if installed) or plain prompts

Required:
  -s, --source DEV           Source block device (e.g. /dev/sdb, /dev/mmcblk0)
  -o, --output FILE          Output image path. Suffix .xz/.gz/.zst sets compression when --compress=auto

Options:
      --compress MODE        auto|xz|gz|zst|none  (default auto)
      --fast-dd              Prefer dd over ddrescue
      --no-shrink            Skip ext4 shrink/partition resize
      --verify               Run fsck -n and read-only mount checks on image
      --force                Do not prompt for confirmations
      --tui                  Launch minimal TUI for device/options selection
      --no-color             Disable colored logs
      --quiet                Suppress non-error logs
      --json                 JSON log lines
      --log-file PATH        Append logs to file
      --report-dir PATH      Directory for per-host Markdown report (default: OUT_IMG dir)
  -h, --help                 Show help

Env:
  TIMEOUT_SECS=N             Timeout seconds for long steps (0 = none)

Examples:
  sudo $0 --tui
  sudo $0 -s /dev/sdb -o ./raspi.img.xz --verify
  sudo $0 -s /dev/mmcblk0 -o ./raspi.img --compress zst --fast-dd --report-dir ./reports
EOF
}

# --------------------------- Argparse ---------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--source) SRC_DEV="${2:-}"; shift 2;;
    -o|--output) OUT_IMG="${2:-}"; shift 2;;
    --compress)  COMPRESS="${2:-}"; shift 2;;
    --fast-dd)   FAST_DD=1; shift;;
    --no-shrink) NO_SHRINK=1; shift;;
    --verify)    VERIFY=1; shift;;
    --force)     FORCE=1; shift;;
    --tui)       TUI=1; shift;;
    --no-color)  COLOR=0; shift;;
    --quiet)     QUIET=1; shift;;
    --json)      JSON=1; shift;;
    --log-file)  LOG_FILE="${2:-}"; shift 2;;
    --report-dir) REPORT_DIR="${2:-}"; shift 2;;
    -h|--help)   usage; exit 0;;
    *) err "Unknown arg: $1"; usage; exit 2;;
  esac
done

[[ $EUID -eq 0 ]] || { err "Run as root."; exit 2; }

# --------------------------- Helpers ----------------------------
need(){ command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }; }
settle(){ command -v udevadm >/dev/null 2>&1 && udevadm settle || true; }
run_to(){ if [[ "${TIMEOUT_SECS}" -gt 0 ]]; then timeout --foreground "${TIMEOUT_SECS}" "$@"; else "$@"; fi }
ask_yes(){
  [[ $FORCE -eq 1 ]] && return 0
  read -r -p "${1:-Proceed?} [y/N]: " ans
  [[ "$ans" == "y" || "$ans" == "Y" ]]
}
CLEANUP_CMDS=()
push_cleanup(){ CLEANUP_CMDS+=("$*"); }
on_exit(){ set +e; for (( i=${#CLEANUP_CMDS[@]}-1; i>=0; i-- )); do eval "${CLEANUP_CMDS[$i]}" || true; done; }
trap on_exit EXIT

pkg_install(){
  local pkgs=("$@")
  local mgr=""
  command -v apt-get >/dev/null 2>&1 && mgr="apt-get"
  command -v dnf     >/dev/null 2>&1 && mgr="dnf"
  command -v yum     >/dev/null 2>&1 && mgr="yum"
  command -v pacman  >/dev/null 2>&1 && mgr="pacman"
  [[ -z "$mgr" ]] && { warn "No known package manager detected. Install deps manually."; return 0; }
  log "Installing prerequisites: ${pkgs[*]} via $mgr"
  case "$mgr" in
    apt-get) DEBIAN_FRONTEND=noninteractive apt-get update -y && apt-get install -y "${pkgs[@]}" ;;
    dnf)     dnf install -y "${pkgs[@]}" ;;
    yum)     yum install -y "${pkgs[@]}" ;;
    pacman)  pacman -Sy --noconfirm "${pkgs[@]}" ;;
  esac
}

ensure_deps(){
  local core=(lsblk sfdisk partprobe blkid losetup fdisk parted truncate sha256sum)
  local shrink=(e2fsck resize2fs dumpe2fs)
  local opt=(ddrescue pv xz gzip zstd udevadm fsck.fat dosfsck fzf)
  local missing=()
  for b in "${core[@]}"; do command -v "$b" >/dev/null 2>&1 || missing+=("$b"); done
  if [[ $NO_SHRINK -eq 0 ]]; then
    for b in "${shrink[@]}"; do command -v "$b" >/dev/null 2>&1 || missing+=("$b"); done
  fi
  # Prefer fsck.fat; dosfsck acceptable
  command -v fsck.fat >/dev/null 2>&1 || command -v dosfsck >/dev/null 2>&1 || missing+=("dosfstools")
  if ((${#missing[@]})); then
    ask_yes "Install missing packages: ${missing[*]}?" && pkg_install "${missing[@]}" || warn "Continuing without installing."
  fi
}

# MarkDown report
report_init(){
  local outdir="${REPORT_DIR:-$(dirname "$(readlink -f "$OUT_IMG")")}"
  mkdir -p "$outdir"
  REPORT_PATH="$outdir/${HOST_ID}-pi-image-capture-$(date -u +%Y%m%dT%H%M%SZ).md"
  {
    echo "# Pi Image Capture Report"
    echo ""
    echo "- Host: \`$HOST_ID\`"
    echo "- Script: \`pi-image-capture.sh\` v$VERSION"
    echo "- Started: \`$START_TS\`"
    echo "- Kernel: \`$(uname -srmo)\`"
    echo ""
    echo "## Parameters"
    echo "- Source: \`${SRC_DEV:-TBD}\`"
    echo "- Output: \`${OUT_IMG:-TBD}\`"
    echo "- Compress: \`$COMPRESS\`  FastDD: \`$FAST_DD\`  Verify: \`$VERIFY\`  NoShrink: \`$NO_SHRINK\`"
    echo ""
    echo "## Steps"
  } >"$REPORT_PATH"
}
report_step(){ echo "- $*" >>"$REPORT_PATH"; }
report_kv(){ printf "  - %s: \`%s\`\n" "$1" "$2" >>"$REPORT_PATH"; }
report_done(){
  {
    echo ""
    echo "## Results"
    printf "- Image: \`%s\`\n" "$OUT_IMG"
    [[ -f "${OUT_IMG}.sha256" ]] && printf "- SHA256: \`%s\`\n" "$(cut -d' ' -f1 "${OUT_IMG}.sha256")"
    echo "- Finished: \`$(date -u +"%Y-%m-%dT%H:%M:%SZ")\`"
  } >>"$REPORT_PATH"
  ok "Report written: $REPORT_PATH"
}

# Unmount anything auto-mounted from a device or loop
auto_unmount_all(){
  local target="$1"
  local base="$(basename "$target")"
  local m
  while read -r m; do
    [[ -z "$m" ]] && continue
    log "Auto-unmount: $m"
    umount -f "$m" 2>/dev/null || true
  done < <(mount | awk -v b="$base" '$1 ~ b {print $3}')
}

# TUI for device and options
tui_select(){
  log "Launching TUI"
  local choices
  choices="$(lsblk -dpno NAME,SIZE,MODEL,TRAN,RM | awk '{print $1 "  (" $2 ")  " $3 " " $4 " RM=" $5}' | grep -E '/dev/sd|/dev/mmcblk' || true)"
  if command -v fzf >/dev/null 2>&1; then
    SRC_DEV="$(printf "%s\n" "$choices" | fzf --prompt="Select source device > " | awk '{print $1}')"
  else
    echo "Available devices:"
    echo "$choices"
    read -r -p "Enter source device (e.g. /dev/sdb): " SRC_DEV
  fi
  [[ -b "$SRC_DEV" ]] || { err "Invalid selection: $SRC_DEV"; exit 2; }
  read -r -p "Output image path [default ./raspi.img.xz]: " OUT_IMG
  OUT_IMG="${OUT_IMG:-./raspi.img.xz}"
  read -r -p "Compression [auto|xz|gz|zst|none] (default auto): " COMPRESS || true
  COMPRESS="${COMPRESS:-auto}"
  read -r -p "Verify image after capture? [y/N]: " v
  [[ "$v" =~ ^[Yy]$ ]] && VERIFY=1 || VERIFY=0
}

# --------------------------- Begin ------------------------------
ensure_deps

if [[ $TUI -eq 1 || -z "${SRC_DEV:-}" || -z "${OUT_IMG:-}" ]]; then
  tui_select
fi

[[ -b "${SRC_DEV:-}" ]] || { err "Missing or invalid --source device."; usage; exit 2; }
[[ -n "${OUT_IMG:-}"  ]] || { err "Missing --output path."; usage; exit 2; }
report_init
report_step "Input validation"
report_kv "Source" "$SRC_DEV"
report_kv "Output" "$OUT_IMG"

# Refuse output on same physical disk
OUT_DIR="$(dirname "$(readlink -f "$OUT_IMG")")"
SRC_PDEV="$(lsblk -no PKNAME "$SRC_DEV" 2>/dev/null || true)"
OUT_SRC="$(df --output=source "$OUT_DIR" | tail -n1 || true)"
if [[ -n "$SRC_PDEV" && "$OUT_SRC" == *"$SRC_PDEV"* ]]; then
  err "Output directory is on the source device. Choose another destination."
  exit 4
fi

# Unmount source auto-mounts
log "Unmounting any mounted partitions on $SRC_DEV"
while read -r P; do [[ -n "$P" && "$P" != "$SRC_DEV" ]] && umount -f "$P" 2>/dev/null || true; done < <(lsblk -lnpo NAME "$SRC_DEV")
settle; sync
report_step "Unmounted source partitions"

# --------------------------- Sizing -----------------------------
SECT_SIZE="$(cat "/sys/class/block/$(basename "$SRC_DEV")/queue/logical_block_size")"
LAST_END_SECT="$(sfdisk -d "$SRC_DEV" | awk -F'[ ,]+' '/start=/ { e=$4+$6-1 } END { print e+1 }')"
[[ -n "$LAST_END_SECT" ]] || { err "Failed to read partition table."; exit 5; }
RAW_BYTES=$(( LAST_END_SECT * SECT_SIZE ))
DISK_BYTES="$(blockdev --getsize64 "$SRC_DEV")"
diff_abs=$(( RAW_BYTES>DISK_BYTES ? RAW_BYTES-DISK_BYTES : DISK_BYTES-RAW_BYTES ))
(( diff_abs > 1048576 )) && warn "Partition end vs device size differ by ${diff_abs} bytes."
log "Size to last partition end: $RAW_BYTES bytes"
report_step "Sizing"
report_kv "SectorSize" "$SECT_SIZE"
report_kv "EndOfLastPartition" "$LAST_END_SECT"
report_kv "RawBytes" "$RAW_BYTES"

# --------------------------- Capture ----------------------------
TMP_IMG="$OUT_IMG"; case "$OUT_IMG" in *.xz|*.gz|*.zst) TMP_IMG="${OUT_IMG%.*}";; esac
log "Capturing $SRC_DEV to $TMP_IMG"
report_step "Capture started"
if command -v ddrescue >/dev/null 2>&1 && [[ $FAST_DD -eq 0 ]]; then
  run_to ddrescue -v --force --size="$RAW_BYTES" --sector-size="$SECT_SIZE" "$SRC_DEV" "$TMP_IMG" "${TMP_IMG}.map"
else
  # bytes-limited dd to avoid trailing unused card space beyond last partition
  if command -v pv >/dev/null 2>&1; then
    run_to bash -c 'pv -tpreb -s "$0" "$1" | dd of="$2" bs=4M status=none conv=fsync' "$RAW_BYTES" "$SRC_DEV" "$TMP_IMG"
  else
    run_to dd if="$SRC_DEV" of="$TMP_IMG" bs=4M count="$RAW_BYTES" iflag=count_bytes status=progress conv=fsync
  fi
fi
sync; ok "Capture complete"
report_step "Capture complete"

# --------------------------- Loop attach ------------------------
log "Attaching loop"
LOOP="$(losetup --show -fP "$TMP_IMG")"; push_cleanup "losetup -d '$LOOP' >/dev/null 2>&1"; settle
# Desktop auto-mounts of loop partitions? Unmount them now.
auto_unmount_all "$LOOP"
settle

# --------------------------- Detect FS --------------------------
log "Detecting partitions"
BOOT_PART=""; ROOT_PART=""; ROOT_SIZE=0; BOOT_SIZE=0
while read -r name fstype size; do
  [[ "$name" == "$LOOP" ]] && continue
  [[ -z "$fstype" ]] && continue
  if [[ "$fstype" =~ ^(vfat|fat)$ ]]; then [[ -z "$BOOT_PART" || "$size" -lt "$BOOT_SIZE" ]] && BOOT_PART="$name" BOOT_SIZE="$size"
  elif [[ "$fstype" =~ ^ext ]]; then [[ "$size" -gt "$ROOT_SIZE" ]] && ROOT_PART="$name" ROOT_SIZE="$size"
  fi
done < <(lsblk -b -lnpo NAME,FSTYPE,SIZE "$LOOP")
LAST_NUM="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | sed -E 's/.*[^0-9]([0-9]+)$/\1/' | tail -n1)"
ROOT_NUM=""; [[ -n "$ROOT_PART" ]] && ROOT_NUM="$(echo "$ROOT_PART" | sed -E 's/.*[^0-9]([0-9]+)$/\1/')"
log "Boot: ${BOOT_PART:-unknown}  Root: ${ROOT_PART:-unknown}"
report_step "Detected filesystems"
report_kv "Boot" "${BOOT_PART:-unknown}"
report_kv "Root" "${ROOT_PART:-unknown}"

# --------------------------- Shrink ext4 root -------------------
if [[ $NO_SHRINK -eq 0 && -n "$ROOT_PART" && -n "$ROOT_NUM" && "$ROOT_NUM" == "$LAST_NUM" ]]; then
  # Ensure nothing mounted from loop again
  auto_unmount_all "$LOOP"; settle
  log "e2fsck on $ROOT_PART"
  run_to e2fsck -fy "$ROOT_PART"
  log "resize2fs -M on $ROOT_PART"
  run_to resize2fs -M "$ROOT_PART"
  # ext4 geometry
  BS=""; BC=""
  eval "$(dumpe2fs -h "$ROOT_PART" 2>/dev/null | awk '/Block size:/ {bs=$3} /Block count:/ {bc=$3} END{printf "BS=%d;BC=%d;\n",bs,bc }')"
  [[ -n "$BS" && -n "$BC" ]] || { err "Failed to read ext4 geometry."; exit 6; }
  FS_BYTES=$(( BS * BC ))
  START_SECT="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' -v p="$(basename "$ROOT_PART")" '$1==p { print $4 }')"
  [[ -n "$START_SECT" ]] || { err "Failed to read root start sector."; exit 7; }
  NEEDED_SECT=$(( (FS_BYTES + SECT_SIZE - 1) / SECT_SIZE ))
  NEW_END=$(( START_SECT + NEEDED_SECT - 1 ))
  log "Target end sector for root: $NEW_END"
  report_step "Shrink ext4"
  report_kv "BlockSize" "$BS"
  report_kv "BlockCount" "$BC"
  report_kv "StartSect" "$START_SECT"
  report_kv "NeededSect" "$NEEDED_SECT"

  # Try parted scripted; if prompts, fallback to sfdisk non-interactive
  if ! run_to parted -s "$LOOP" unit s resizepart "$ROOT_NUM" "${NEW_END}s"; then
    warn "parted resize prompted or failed. Falling back to sfdisk."
    run_to sfdisk -d "$LOOP" > table.backup
    # Resize partition N to NEEDED_SECT (keep start fixed). --no-reread avoids immediate kernel re-read errors.
    echo ",${NEEDED_SECT}" | run_to sfdisk --no-reread -N "$ROOT_NUM" "$LOOP"
  fi
  partprobe "$LOOP" || losetup -c "$LOOP" || true
  settle
  ok "Root shrink complete"
else
  if [[ $NO_SHRINK -eq 1 ]]; then
    warn "--no-shrink set. Shrink skipped."
  elif [[ -z "$ROOT_PART" ]]; then
    warn "No ext* root detected. Shrink skipped."
  else
    warn "Root partition is not last. Shrink skipped."
  fi
  report_step "Shrink skipped"
fi

# --------------------------- Truncate ---------------------------
LAST_END_IMG="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' '/start=/ { e=$4+$6-1 } END { print e }')"
[[ -n "$LAST_END_IMG" ]] || { err "Failed to compute image end sector."; exit 8; }
FINAL_BYTES=$(( (LAST_END_IMG + 1) * SECT_SIZE ))
log "Detaching loop and truncating image to $FINAL_BYTES bytes"
losetup -d "$LOOP" || true
CLEANUP_CMDS=("${CLEANUP_CMDS[@]:0:${#CLEANUP_CMDS[@]}-1}")
# Ensure we can truncate if file is root-owned
chown --reference="$(dirname "$TMP_IMG")" "$TMP_IMG" 2>/dev/null || true
run_to truncate -s "$FINAL_BYTES" "$TMP_IMG"
ok "Truncate complete"
report_step "Truncated image"
report_kv "FinalBytes" "$FINAL_BYTES"

# --------------------------- Verify -----------------------------
if [[ $VERIFY -eq 1 ]]; then
  log "Verification: fsck -n and read-only mount"
  LOOP_VERIFY="$(losetup --show -fP "$TMP_IMG")"; push_cleanup "losetup -d '$LOOP_VERIFY' >/dev/null 2>&1"
  settle; auto_unmount_all "$LOOP_VERIFY"; settle
  while read -r p; do
    [[ "$p" == "$LOOP_VERIFY" ]] && continue
    fstype="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
    case "$fstype" in
      ext*) run_to e2fsck -fn "$p" >/dev/null ;;
      vfat|fat) command -v fsck.fat >/dev/null 2>&1 && run_to fsck.fat -n "$p" >/dev/null || command -v dosfsck >/dev/null 2>&1 && run_to dosfsck -n "$p" >/dev/null || true ;;
    esac
  done < <(lsblk -lnpo NAME "$LOOP_VERIFY")
  MNT_TMP="$(mktemp -d)"; push_cleanup "umount '$MNT_TMP' >/dev/null 2>&1; rmdir '$MNT_TMP' >/dev/null 2>&1"
  # Mount first ext* partition read-only just to list contents
  FIRST_EXT="$(lsblk -lnpo NAME,FSTYPE "$LOOP_VERIFY" | awk '$2 ~ /^ext/ {print $1; exit}')"
  if [[ -n "$FIRST_EXT" ]]; then
    run_to mount -o ro,norecover,noload "$FIRST_EXT" "$MNT_TMP" 2>/dev/null || true
    ls -A "$MNT_TMP" | head -n 10 >/dev/null 2>&1 || true
    umount "$MNT_TMP" >/dev/null 2>&1 || true
  fi
  losetup -d "$LOOP_VERIFY" || true
  ok "Verify complete"
  report_step "Verification complete"
fi

# --------------------------- Compression ------------------------
decide_comp(){
  case "$1" in
    auto) [[ "$OUT_IMG" == *.xz ]] && echo xz || { [[ "$OUT_IMG" == *.gz ]] && echo gz || { [[ "$OUT_IMG" == *.zst ]] && echo zst || echo xz; }; } ;;
    xz|gz|zst|none) echo "$1" ;;
    *) err "Invalid --compress"; exit 9;;
  esac
}
do_c="$(decide_comp "$COMPRESS")"
# If user asked for none but OUT_IMG has compressed suffix, honor suffix by moving name after no-compress
if [[ "$do_c" == "none" ]]; then
  if [[ "$TMP_IMG" != "$OUT_IMG" ]]; then
    log "No compression selected; renaming '$TMP_IMG' -> '$OUT_IMG'"
    mv -f "$TMP_IMG" "$OUT_IMG"
  else
    warn "No compression selected."
  fi
else
  log "Compressing -> $OUT_IMG ($do_c)"
  case "$do_c" in
    xz)  need xz;  run_to xz   -T0 -9e -f -c "$TMP_IMG" > "$OUT_IMG" ;;
    gz)  need gzip;run_to gzip -9    -f -c "$TMP_IMG" > "$OUT_IMG" ;;
    zst) need zstd;run_to zstd -T0 -19 -f -c "$TMP_IMG" > "$OUT_IMG" ;;
  esac
  rm -f "$TMP_IMG"
fi
report_step "Compression"
report_kv "Compressor" "$do_c"

# --------------------------- Digest & Report --------------------
log "Computing SHA-256"
sha256sum "$OUT_IMG" | tee "${OUT_IMG}.sha256" >/dev/null
ok "All done."
printf "%s\n%s\n" "Image: $OUT_IMG" "SHA256: $(cut -d' ' -f1 "${OUT_IMG}.sha256")"
report_step "Checksum"
report_kv "SHA256" "$(cut -d' ' -f1 "${OUT_IMG}.sha256")"
report_done