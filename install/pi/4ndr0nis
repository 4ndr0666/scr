#!/usr/bin/env bash
# pi-image-capture.sh — Zero-touch Raspberry Pi SD → distributable image tool
# Author: 4ndr0666
# Version: 1.6.1
# License: MIT
#
# Modes:
#   --auto               Detect source, stop automount, capture → shrink → resize → truncate → verify → compress → checksum
#   --shrink-img <IMG>   Offline-shrink an existing image file and safely truncate (no source device needed)
#
# Guarantees:
#   - Refuses dangerous truncates (final size < 1 MiB or > file size)
#   - Non-interactive partition resize (sfdisk first, parted as fallback)
#   - Auto-unmounts any auto-mounted loop partitions
#   - Stops udisks2 during capture (if systemd present), restarts on exit
#   - Works without prompts when --auto is used

set -Eeuo pipefail

VERSION="1.6.1"

# --------------------------- Defaults ---------------------------
SRC_DEV=""
OUT_IMG=""
COMPRESS="auto"         # auto|xz|gz|zst|none
FAST_DD=0               # prefer dd over ddrescue
NO_SHRINK=0             # skip shrink stage
VERIFY=0                # fsck -n on partitions and optional RO mount check
QUIET=0
JSON=0
COLOR=1
LOG_FILE=""
FORCE=0
TUI=0
AUTO=0
SHRINK_IMG=""
TIMEOUT_SECS="${TIMEOUT_SECS:-0}"  # 0 = none

# --------------------------- Logging ----------------------------
ts(){ date +"%Y-%m-%dT%H:%M:%S%z"; }
emit(){
  local L="$1"; shift
  local M="$*"
  if [[ -n "$LOG_FILE" ]]; then
    printf "%s %s %s\n" "$(ts)" "$L" "$M" >>"$LOG_FILE"
  fi
  if [[ $JSON -eq 1 ]]; then
    printf '{ "ts":"%s","level":"%s","msg":%q }\n' "$(ts)" "$L" "$M"
    return
  fi
  if [[ $QUIET -eq 1 && "$L" != "ERR" ]]; then return; fi
  if [[ $COLOR -eq 1 ]]; then
    case "$L" in
      INFO) printf "\033[1;34m[INFO]\033[0m %s\n" "$M" ;;
      WARN) printf "\033[1;33m[WARN]\033[0m %s\n" "$M" ;;
      DONE) printf "\033[1;32m[DONE]\033[0m %s\n" "$M" ;;
      ERR ) printf "\033[1;31m[ERR ]\033[0m %s\n" "$M" ;;
      *)    printf "[%s] %s\n" "$L" "$M" ;;
    esac
  else
    printf "[%s] %s\n" "$L" "$M"
  fi
}
log(){ emit INFO "$*"; }
warn(){ emit WARN "$*"; }
ok(){ emit DONE "$*"; }
err(){ emit ERR "$*"; }

# --------------------------- Usage ------------------------------
usage(){
  cat <<EOF
pi-image-capture.sh v$VERSION

Usage:
  sudo $0 --auto
  sudo $0 --shrink-img ./file.img[.xz|.gz] [--compress auto|xz|gz|zst|none] [--verify]
  sudo $0 -s /dev/sdX -o ./raspi.img[.xz|.gz|.zst] [--verify] [--fast-dd] [--no-shrink]

Options:
  --auto                 Zero-touch: autodetect source and run full pipeline
  --shrink-img IMG       Offline-shrink and truncate an existing image file
  -s, --source DEV       Source device (/dev/sdX or /dev/mmcblk0)
  -o, --output FILE      Output image path (suffix controls compression when --compress=auto)
      --compress MODE    auto|xz|gz|zst|none  (default auto)
      --fast-dd          Prefer dd over ddrescue
      --no-shrink        Skip ext4 shrink (partition resize + truncate still safe)
      --verify           Run fsck -n on image partitions (and RO mount for ext*)
      --force            Auto-confirm any prompts (currently none in --auto)
      --tui              Simple device selection UI (fzf if present, else prompts)
      --no-color         Disable colored logs
      --quiet            Suppress non-error logs
      --json             JSON logs
      --log-file PATH    Append logs to file
  -h, --help             Show help

Env:
  TIMEOUT_SECS=N         Timeout for long steps (0 = none)

Examples:
  sudo $0 --auto
  sudo $0 -s /dev/mmcblk0 -o ./my-pi.img.xz --verify
  sudo $0 --shrink-img ./my-pi.img --compress zst --verify
EOF
}

# --------------------------- Argparse ---------------------------
[[ $EUID -eq 0 ]] || { err "Run as root."; exit 2; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --auto) AUTO=1; shift;;
    --shrink-img) SHRINK_IMG="${2:-}"; shift 2;;
    -s|--source) SRC_DEV="${2:-}"; shift 2;;
    -o|--output) OUT_IMG="${2:-}"; shift 2;;
    --compress)  COMPRESS="${2:-}"; shift 2;;
    --fast-dd)   FAST_DD=1; shift;;
    --no-shrink) NO_SHRINK=1; shift;;
    --verify)    VERIFY=1; shift;;
    --force)     FORCE=1; shift;;
    --tui)       TUI=1; shift;;
    --no-color)  COLOR=0; shift;;
    --quiet)     QUIET=1; shift;;
    --json)      JSON=1; shift;;
    --log-file)  LOG_FILE="${2:-}"; shift 2;;
    -h|--help)   usage; exit 0;;
    *) err "Unknown arg: $1"; usage; exit 2;;
  esac
done

# --------------------------- Helpers ----------------------------
need(){ command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }; }
settle(){ command -v udevadm >/dev/null 2>&1 && udevadm settle || true; }
run_to(){ if [[ "$TIMEOUT_SECS" -gt 0 ]]; then timeout --foreground "$TIMEOUT_SECS" "$@"; else "$@"; fi; }
ask_yes(){ [[ $FORCE -eq 1 ]] && return 0; read -r -p "${1:-Proceed?} [y/N]: " a; [[ "$a" =~ ^[Yy]$ ]]; }

CLEANUP=()
pushc(){ CLEANUP+=("$*"); }
on_exit(){
  set +e
  for ((i=${#CLEANUP[@]}-1;i>=0;i--)); do
    eval "${CLEANUP[$i]}" || true
  done
}
trap on_exit EXIT

stop_automount(){
  if command -v systemctl >/dev/null 2>&1; then
    if systemctl is-active --quiet udisks2.service; then
      log "Stopping udisks2"
      systemctl stop udisks2.service || true
      pushc "systemctl start udisks2.service || true"
    fi
  fi
}

auto_unmount_all(){
  local t="$1"
  local b
  b="$(basename "$t")"
  while IFS= read -r mnt; do
    [[ -n "$mnt" ]] || continue
    umount -f "$mnt" 2>/dev/null || true
  done < <(mount | awk -v b="$b" '$1 ~ b {print $3}')
}

decide_comp(){
  case "$1" in
    auto)
      if [[ "$OUT_IMG" == *.xz ]]; then echo "xz"
      elif [[ "$OUT_IMG" == *.gz ]]; then echo "gz"
      elif [[ "$OUT_IMG" == *.zst ]]; then echo "zst"
      else echo "xz"
      fi
      ;;
    xz|gz|zst|none) echo "$1" ;;
    *) err "Invalid --compress"; exit 9;;
  esac
}

tui(){
  log "TUI mode"
  local choices
  choices="$(lsblk -bdpno NAME,SIZE,RM,TYPE,MOUNTPOINT,MODEL,TRAN | awk '$3==1 && $4=="disk" && $5!="/" {printf "%s  (%d bytes)  %s %s\n",$1,$2,$6,$7}')"
  if command -v fzf >/dev/null 2>&1; then
    SRC_DEV="$(printf "%s\n" "$choices" | fzf --prompt="Select source device > " | awk '{print $1}')"
  else
    printf "%s\n" "$choices"
    read -r -p "Source device (e.g. /dev/sdb): " SRC_DEV
  fi
  [[ -b "$SRC_DEV" ]] || { err "Invalid source: $SRC_DEV"; exit 2; }
  read -r -p "Output image path [./raspi.img.xz]: " OUT_IMG; OUT_IMG="${OUT_IMG:-./raspi.img.xz}"
  read -r -p "Compression [auto|xz|gz|zst|none] (auto): " COMPRESS; COMPRESS="${COMPRESS:-auto}"
  read -r -p "Verify after capture? [y/N]: " v; [[ "$v" =~ ^[Yy]$ ]] && VERIFY=1 || VERIFY=0
}

# --------------------------- Dependencies -----------------------
for b in lsblk sfdisk partprobe blkid losetup fdisk truncate sha256sum stat; do need "$b"; done
command -v ddrescue >/dev/null 2>&1 || true
command -v pv       >/dev/null 2>&1 || true
command -v xz       >/dev/null 2>&1 || true
command -v gzip     >/dev/null 2>&1 || true
command -v zstd     >/dev/null 2>&1 || true
command -v parted   >/dev/null 2>&1 || true
command -v udevadm  >/dev/null 2>&1 || true
FSCK_FAT_BIN="$(command -v fsck.fat || true)"
if [[ -z "$FSCK_FAT_BIN" ]]; then
  FSCK_FAT_BIN="$(command -v dosfsck || true)"
fi

# --------------------------- Core routines ----------------------
detect_src_auto(){
  # pick largest removable disk not mounted as /
  local line dev
  line="$(lsblk -bdpno NAME,SIZE,RM,TYPE,MOUNTPOINT | awk '$3==1 && $4=="disk" && $5!="/" {print $0}' | sort -k2,2n | tail -n1 || true)"
  dev="$(awk '{print $1}' <<<"$line")"
  [[ -b "$dev" ]] || { err "No removable source device found."; exit 2; }
  SRC_DEV="$dev"
}

prepare_output_auto(){
  local outdir file
  outdir="$PWD"
  file="pi-$(date -u +%Y%m%dT%H%M%SZ).img.xz"
  OUT_IMG="${OUT_IMG:-$outdir/$file}"
  COMPRESS="${COMPRESS:-auto}"
  VERIFY=1
}

calc_copy_span(){
  local dev="$1"
  local ss
  if [[ -r "/sys/class/block/$(basename "$dev")/queue/logical_block_size" ]]; then
    ss="$(cat "/sys/class/block/$(basename "$dev")/queue/logical_block_size")"
  else
    ss="$(blockdev --getss "$dev")"
  fi
  SECT_SIZE="$ss"
  LAST_END_SECT="$(sfdisk -d "$dev" | awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e+1}')"
  [[ -n "$LAST_END_SECT" ]] || { err "Cannot read partition table on $dev"; exit 5; }
  RAW_BYTES=$(( LAST_END_SECT * SECT_SIZE ))
}

capture_device(){
  local dev="$1"
  local out="$2"
  log "Capturing $dev → $out"
  case "$out" in
    *.xz|*.gz|*.zst) TMP_IMG="${out%.*}" ;;
    *)               TMP_IMG="$out" ;;
  esac
  if command -v ddrescue >/dev/null 2>&1 && [[ $FAST_DD -eq 0 ]]; then
    run_to ddrescue -v --force --size="$RAW_BYTES" --sector-size="$SECT_SIZE" "$dev" "$TMP_IMG" "${TMP_IMG}.map"
  else
    if command -v pv >/dev/null 2>&1; then
      run_to bash -c 'pv -tpreb -s "$0" "$1" | dd of="$2" bs=4M status=none conv=fsync' "$RAW_BYTES" "$dev" "$TMP_IMG"
    else
      run_to dd if="$dev" of="$TMP_IMG" bs=4M count="$RAW_BYTES" iflag=count_bytes status=progress conv=fsync
    fi
  fi
  sync
  ok "Capture complete"
}

attach_loop(){
  local img="$1"
  LOOP="$(losetup --show -fP "$img")"
  pushc "losetup -d '$LOOP' >/dev/null 2>&1"
  settle
  auto_unmount_all "$LOOP"
  settle
  local lsz
  lsz="$(blockdev --getsize64 "$LOOP" 2>/dev/null || echo 0)"
  if [[ -z "$lsz" || "$lsz" -lt 512 ]]; then
    err "Loop device size reports <512 bytes; aborting"
    exit 10
  fi
}

detect_fs(){
  BOOT_PART=""
  ROOT_PART=""
  ROOT_SIZE=0
  BOOT_SIZE=0
  while IFS= read -r line; do
    local name fstype size
    name="$(awk '{print $1}' <<<"$line")"
    fstype="$(awk '{print $2}' <<<"$line")"
    size="$(awk '{print $3}' <<<"$line")"
    [[ "$name" == "$LOOP" || -z "$fstype" ]] && continue
    if [[ "$fstype" =~ ^(vfat|fat|exfat)$ ]]; then
      if [[ -z "$BOOT_PART" || "$size" -lt "$BOOT_SIZE" ]]; then BOOT_PART="$name"; BOOT_SIZE="$size"; fi
    elif [[ "$fstype" =~ ^ext ]]; then
      if [[ "$size" -gt "$ROOT_SIZE" ]]; then ROOT_PART="$name"; ROOT_SIZE="$size"; fi
    fi
  done < <(lsblk -b -lnpo NAME,FSTYPE,SIZE "$LOOP")
  LAST_NUM="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | sed -E 's/.*[^0-9]([0-9]+)$/\1/' | tail -n1 || true)"
  ROOT_NUM=""
  if [[ -n "$ROOT_PART" ]]; then
    ROOT_NUM="$(echo "$ROOT_PART" | sed -E 's/.*[^0-9]([0-9]+)$/\1/')"
  fi
  log "Boot: ${BOOT_PART:-unknown}  Root: ${ROOT_PART:-unknown}"
}

shrink_ext4_if_last(){
  if [[ $NO_SHRINK -eq 1 ]]; then
    warn "--no-shrink set"
    return 0
  fi
  if [[ -z "$ROOT_PART" || -z "$ROOT_NUM" || -z "$LAST_NUM" || "$ROOT_NUM" != "$LAST_NUM" ]]; then
    warn "Skip shrink (no ext* root last)"
    return 0
  fi
  auto_unmount_all "$LOOP"
  settle
  log "e2fsck $ROOT_PART"
  run_to e2fsck -fy "$ROOT_PART"
  log "resize2fs -M $ROOT_PART"
  run_to resize2fs -M "$ROOT_PART"

  local BS="" BC=""
  eval "$(dumpe2fs -h "$ROOT_PART" 2>/dev/null | awk '/Block size:/ {bs=$3} /Block count:/ {bc=$3} END{printf "BS=%d;BC=%d;\n",bs,bc }')"
  if [[ -z "$BS" || -z "$BC" ]]; then
    warn "Cannot read ext4 geometry; skipping partition resize"
    return 0
  fi

  local FS_BYTES START_SECT NEEDED_SECT NEW_END
  FS_BYTES=$(( BS * BC ))
  START_SECT="$(sfdisk -d "$LOOP" | awk -v p="$ROOT_PART" -F'[ ,]+' '$1==p {print $4}')"
  if [[ -z "$START_SECT" ]]; then
    warn "Cannot read root start sector; skipping partition resize"
    return 0
  fi
  NEEDED_SECT=$(( (FS_BYTES + SECT_SIZE - 1) / SECT_SIZE ))
  NEW_END=$(( START_SECT + NEEDED_SECT - 1 ))
  log "Resize root end → sector $NEW_END (sfdisk)"

  if echo ",${NEEDED_SECT}" | run_to sfdisk --no-reread -N "$ROOT_NUM" "$LOOP"; then
    partprobe "$LOOP" || losetup -c "$LOOP" || true
    settle
    ok "Partition resized (sfdisk)"
  else
    warn "sfdisk failed; trying parted"
    if run_to parted -s "$LOOP" unit s resizepart "$ROOT_NUM" "${NEW_END}s"; then
      partprobe "$LOOP" || losetup -c "$LOOP" || true
      settle
      ok "Partition resized (parted)"
    else
      warn "Partition resize failed; continuing unshrunk"
    fi
  fi
}

truncate_image_safely(){
  local img="$1"
  local LAST_END_IMG FINAL_BYTES FILE_BYTES
  LAST_END_IMG="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e}')"
  [[ -n "$LAST_END_IMG" ]] || { err "Cannot compute last end sector; refusing to truncate"; exit 8; }
  FINAL_BYTES=$(( (LAST_END_IMG + 1) * SECT_SIZE ))
  FILE_BYTES="$(stat -c %s "$img")"
  if (( FINAL_BYTES < 1048576 )); then err "Final size < 1 MiB ($FINAL_BYTES). Abort."; exit 11; fi
  if (( FINAL_BYTES > FILE_BYTES )); then err "Final size ($FINAL_BYTES) > file size ($FILE_BYTES). Abort."; exit 12; fi
  log "Detach loop and truncate to $FINAL_BYTES bytes"
  losetup -d "$LOOP" || true
  # pop the last cleanup (detaching loop) because it's already detached
  if (( ${#CLEANUP[@]} > 0 )); then unset 'CLEANUP[${#CLEANUP[@]}-1]'; fi
  run_to truncate -s "$FINAL_BYTES" "$img"
  ok "Truncate complete"
}

verify_image(){
  local img="$1"
  [[ $VERIFY -eq 1 ]] || return 0
  log "Verify image"
  local L
  L="$(losetup --show -fP "$img")"
  pushc "losetup -d '$L' >/dev/null 2>&1"
  settle
  auto_unmount_all "$L"
  settle
  while IFS= read -r p; do
    [[ "$p" == "$L" ]] && continue
    local t
    t="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
    case "$t" in
      ext*) run_to e2fsck -fn "$p" >/dev/null ;;
      vfat|fat|exfat)
        if [[ -n "$FSCK_FAT_BIN" ]]; then
          run_to "$FSCK_FAT_BIN" -n "$p" >/dev/null || true
        fi
        ;;
      *) : ;;
    esac
  done < <(lsblk -lnpo NAME "$L" | tail -n +2)
  losetup -d "$L" || true
  ok "Verify complete"
}

compress_and_hash(){
  local img="$1"
  local mode
  mode="$(decide_comp "$COMPRESS")"
  if [[ "$mode" == "none" ]]; then
    OUT_IMG="${OUT_IMG:-$img}"
    if [[ "$img" != "$OUT_IMG" ]]; then mv -f -- "$img" "$OUT_IMG"; fi
    warn "No compression selected"
  else
    [[ -n "$OUT_IMG" ]] || OUT_IMG="${img}.${mode}"
    log "Compress → $OUT_IMG ($mode)"
    case "$mode" in
      xz)  need xz;  run_to xz   -T0 -9e -f -c -- "$img" > "$OUT_IMG" ;;
      gz)  need gzip;run_to gzip -9    -f -c -- "$img" > "$OUT_IMG" ;;
      zst) need zstd;run_to zstd -T0 -19 -f -c -- "$img" > "$OUT_IMG" ;;
    esac
    rm -f -- "$img"
  fi
  log "SHA-256"
  sha256sum "$OUT_IMG" | tee "${OUT_IMG}.sha256" >/dev/null
  ok "All done."
  printf "%s\n%s\n" "Image: $OUT_IMG" "SHA256: $(cut -d' ' -f1 "${OUT_IMG}.sha256")"
}

# --------------------------- Shrink existing image mode ---------
if [[ -n "$SHRINK_IMG" ]]; then
  local_img=""
  case "$SHRINK_IMG" in
    *.xz) need xz;    xz -dkf -- "$SHRINK_IMG";  local_img="${SHRINK_IMG%.xz}" ;;
    *.gz) need gzip;  gunzip -kf -- "$SHRINK_IMG"; local_img="${SHRINK_IMG%.gz}" ;;
    *)    local_img="$SHRINK_IMG" ;;
  esac
  [[ -f "$local_img" ]] || { err "Image not found: $local_img"; exit 2; }
  attach_loop "$local_img"
  # For images, sector size is almost always 512; if we cannot read, default to 512.
  if [[ -r "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size" ]]; then
    SECT_SIZE="$(cat "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size")"
  else
    SECT_SIZE="512"
  fi
  detect_fs
  shrink_ext4_if_last
  truncate_image_safely "$local_img"
  verify_image "$local_img"
  compress_and_hash "$local_img"
  exit 0
fi

# --------------------------- Input/TUI/AUTO ---------------------
if [[ $TUI -eq 1 || ( $AUTO -eq 0 && ( -z "${SRC_DEV:-}" || -z "${OUT_IMG:-}" ) ) ]]; then
  tui
fi

if [[ $AUTO -eq 1 ]]; then
  stop_automount
  detect_src_auto
  prepare_output_auto
fi

# Validate manual inputs if not auto
if [[ $AUTO -eq 0 ]]; then
  [[ -b "${SRC_DEV:-/dev/null}" ]] || { err "Missing/invalid --source"; usage; exit 2; }
  [[ -n "${OUT_IMG:-}" ]] || OUT_IMG="./pi-$(date -u +%Y%m%dT%H%M%SZ).img.xz"
fi

# Refuse destination on same physical device
OUT_DIR="$(dirname "$(readlink -f "$OUT_IMG")")"
SRC_PDEV="$(lsblk -no PKNAME "$SRC_DEV" 2>/dev/null || true)"
OUT_SRC="$(df --output=source "$OUT_DIR" 2>/dev/null | tail -n1 || true)"
if [[ -n "$SRC_PDEV" && "$OUT_SRC" == *"$SRC_PDEV"* ]]; then
  err "Destination directory resides on the source device. Choose a different path."
  exit 4
fi

# Unmount source partitions
log "Unmounting any mounted partitions on $SRC_DEV"
while IFS= read -r P; do
  [[ -n "$P" && "$P" != "$SRC_DEV" ]] && umount -f "$P" 2>/dev/null || true
done < <(lsblk -lnpo NAME "$SRC_DEV")
settle
sync

# Compute copy span and capture
calc_copy_span "$SRC_DEV"
capture_device "$SRC_DEV" "$OUT_IMG"

# Attach, shrink if possible, truncate, verify, compress, hash
attach_loop "$TMP_IMG"
detect_fs
shrink_ext4_if_last
truncate_image_safely "$TMP_IMG"
verify_image "$TMP_IMG"
compress_and_hash "$TMP_IMG"