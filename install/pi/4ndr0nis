#!/usr/bin/env bash
# Author: 4ndr0666
#VERSION="1.3.0"
set -euo pipefail
# ======================= // 4NDR0NIS //
# Description: Captures a Raspberry Pi SD card into a true img, 
# shrinks, and compresses it. Host-side, safe, partition-aware. 
# Supports MBR/ GPT. Shrinks ext4 root when it is the last partition.
# -------------------------------------------------------------
# Constants
SRC_DEV=""
OUT_IMG=""
COMPRESS="auto"      # auto|xz|gz|zst|none
FAST_DD=0            # prefer dd over ddrescue
NO_SHRINK=0          # skip shrinking root filesystem
VERIFY=0             # run fsck -n and optional read-only mount smoke test
QUIET=0
JSON=0
COLOR=1
LOG_FILE=""

# --------------------------- Logging ----------------------------
_ts() { date +"%Y-%m-%dT%H:%M:%S%z"; }
_out() {
  local level="$1"; shift
  local msg="$*"
  [[ -n "$LOG_FILE" ]] && printf "%s %s %s\n" "$(_ts)" "$level" "$msg" >>"$LOG_FILE"
  if [[ $JSON -eq 1 ]]; then
    # minimal JSON; escape quotes
    local esc="${msg//\"/\\\"}"
    printf '{ "ts":"%s","level":"%s","msg":"%s" }\n' "$(_ts)" "$level" "$esc"
  else
    if [[ $QUIET -eq 1 && "$level" != "ERR" ]]; then return 0; fi
    if [[ $COLOR -eq 1 ]]; then
      case "$level" in
        INFO) printf "\033[1;34m[INFO]\033[0m %s\n" "$msg" ;;
        WARN) printf "\033[1;33m[WARN]\033[0m %s\n" "$msg" ;;
        DONE) printf "\033[1;32m[DONE]\033[0m %s\n" "$msg" ;;
        ERR)  printf "\033[1;31m[ERR ]\033[0m %s\n" "$msg" ;;
        *)    printf "[%s] %s\n" "$level" "$msg" ;;
      esac
    else
      printf "[%s] %s\n" "$level" "$msg"
    fi
  fi
}
log()  { _out INFO "$*"; }
warn() { _out WARN "$*"; }
ok()   { _out DONE "$*"; }
err()  { _out ERR  "$*"; }

# --------------------------- Usage ------------------------------
usage() {
cat <<EOF
pi-image-capture.sh v$VERSION
Capture a powered-off Raspberry Pi SD card to a distributable image, shrink, and compress.

Usage:
  sudo $0 -s /dev/sdX -o /path/raspi.img[.xz|.gz|.zst] [options]

Required:
  -s, --source   Block device of the SD card (e.g. /dev/sdb or /dev/mmcblk0)
  -o, --output   Output image path. If ends with .xz/.gz/.zst, compression follows the suffix.

Options:
      --compress {auto|xz|gz|zst|none}  Default: auto (from -o suffix, else xz)
      --fast-dd                         Prefer dd over ddrescue
      --no-shrink                       Skip shrinking root filesystem/partition
      --verify                          Run fsck -n and basic read-only mount checks on image
      --no-color                        Disable colored logs
      --quiet                           Suppress non-error logs
      --json                            Emit JSON log lines
      --log-file <path>                 Append logs to file
  -h, --help                            Show help

Examples:
  sudo $0 -s /dev/sdb -o ./raspi.img.xz
  sudo $0 -s /dev/mmcblk0 -o ./raspi.img --compress zst --verify
EOF
}

# --------------------------- Argparse ---------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--source) SRC_DEV="${2:-}"; shift 2;;
    -o|--output) OUT_IMG="${2:-}"; shift 2;;
    --compress)  COMPRESS="${2:-}"; shift 2;;
    --fast-dd)   FAST_DD=1; shift;;
    --no-shrink) NO_SHRINK=1; shift;;
    --verify)    VERIFY=1; shift;;
    --no-color)  COLOR=0; shift;;
    --quiet)     QUIET=1; shift;;
    --json)      JSON=1; shift;;
    --log-file)  LOG_FILE="${2:-}"; shift 2;;
    -h|--help)   usage; exit 0;;
    *) err "Unknown arg: $1"; usage; exit 2;;
  esac
done

[[ $EUID -eq 0 ]] || { err "Run as root."; exit 2; }
[[ -b "${SRC_DEV:-}" ]] || { err "Missing or invalid --source device."; usage; exit 2; }
[[ -n "${OUT_IMG:-}"  ]] || { err "Missing --output path."; usage; exit 2; }

# --------------------------- Deps -------------------------------
need() { command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }; }
# core
for bin in lsblk sfdisk partprobe blkid losetup fdisk parted truncate sha256sum; do need "$bin"; done
# shrink stack (optional but required unless --no-shrink)
if [[ $NO_SHRINK -eq 0 ]]; then
  for bin in e2fsck resize2fs dumpe2fs; do need "$bin"; done
fi
# optional
command -v ddrescue >/dev/null 2>&1 || true
command -v pv       >/dev/null 2>&1 || true
command -v xz       >/dev/null 2>&1 || true
command -v gzip     >/dev/null 2>&1 || true
command -v zstd     >/dev/null 2>&1 || true
command -v udevadm  >/dev/null 2>&1 || true
FSCK_FAT_BIN="$(command -v fsck.fat || true)"
[[ -z "$FSCK_FAT_BIN" ]] && FSCK_FAT_BIN="$(command -v dosfsck || true)"

# --------------------------- Helpers ----------------------------
settle() { command -v udevadm >/dev/null 2>&1 && udevadm settle || true; }

CLEANUP_CMDS=()
on_exit() {
  set +e
  for (( idx=${#CLEANUP_CMDS[@]}-1 ; idx>=0 ; idx-- )); do eval "${CLEANUP_CMDS[$idx]}" || true; done
}
trap on_exit EXIT

push_cleanup() { CLEANUP_CMDS+=("$*"); }

# --------------------------- Guards -----------------------------
# Refuse writing image to the same physical device
OUT_DIR="$(dirname "$(readlink -f "$OUT_IMG")")"
SRC_PDEV="$(lsblk -no PKNAME "$SRC_DEV" 2>/dev/null || true)"
OUT_SRC="$(df --output=source "$OUT_DIR" | tail -n1 || true)"
if [[ -n "$SRC_PDEV" && "$OUT_SRC" == *"$SRC_PDEV"* ]]; then
  err "Refusing to write image onto the same physical device as the source."
  exit 4
fi

# Unmount any mounted partitions on source
log "Unmounting any mounted partitions on $SRC_DEV"
while read -r P; do
  [[ -n "$P" && "$P" != "$SRC_DEV" ]] && umount -f "$P" 2>/dev/null || true
done < <(lsblk -lnpo NAME "$SRC_DEV")
settle
sync

# --------------------------- Sizing -----------------------------
SECT_SIZE="$(cat "/sys/class/block/$(basename "$SRC_DEV")/queue/logical_block_size")"
LAST_END_SECT="$(sfdisk -d "$SRC_DEV" | awk '/start=/{e=$3+$5-1} END{print e+1}')"
[[ -n "$LAST_END_SECT" ]] || { err "Failed to read partition table."; exit 5; }
RAW_BYTES=$(( LAST_END_SECT * SECT_SIZE ))
DISK_BYTES="$(blockdev --getsize64 "$SRC_DEV")"
# sanity check
diff_abs=$(( RAW_BYTES>DISK_BYTES ? RAW_BYTES-DISK_BYTES : DISK_BYTES-RAW_BYTES ))
if (( diff_abs > 1048576 )); then
  warn "End-of-last-partition differs from device size by $diff_abs bytes. Proceeding, but check table."
fi
log "Source size to end-of-last-partition: $RAW_BYTES bytes"

# --------------------------- Capture ----------------------------
TMP_IMG="$OUT_IMG"
case "$OUT_IMG" in
  *.xz|*.gz|*.zst) TMP_IMG="${OUT_IMG%.*}" ;;
esac

log "Capturing $SRC_DEV to $TMP_IMG"
if command -v ddrescue >/dev/null 2>&1 && [[ $FAST_DD -eq 0 ]]; then
  ddrescue -v --force --sector-size="$SECT_SIZE" "$SRC_DEV" "$TMP_IMG" "${TMP_IMG}.map"
else
  if command -v pv >/dev/null 2>&1; then
    pv -tpreb "$SRC_DEV" | dd of="$TMP_IMG" bs=4M status=none conv=fsync
  else
    dd if="$SRC_DEV" of="$TMP_IMG" bs=4M status=progress conv=fsync
  fi
fi
sync
ok "Capture complete"

# --------------------------- Loop attach ------------------------
log "Attaching loop device"
LOOP="$(losetup --show -fP "$TMP_IMG")"
push_cleanup "losetup -d '$LOOP' >/dev/null 2>&1"
settle

# --------------------------- Detect FS --------------------------
log "Detecting partitions and filesystems"
BOOT_PART=""; ROOT_PART=""; ROOT_SIZE=0; BOOT_SIZE=0
# Use lsblk -b for byte sizes; skip the parent device line
while read -r name fstype size; do
  [[ "$name" == "$LOOP" ]] && continue
  [[ -z "$fstype" ]] && continue
  # smallest FAT as boot
  if [[ "$fstype" =~ ^(vfat|fat)$ ]]; then
    if [[ -z "$BOOT_PART" || "$size" -lt "$BOOT_SIZE" ]]; then
      BOOT_PART="$name"; BOOT_SIZE="$size"
    fi
  fi
  # largest ext* as root
  if [[ "$fstype" =~ ^ext ]]; then
    if [[ "$size" -gt "$ROOT_SIZE" ]]; then
      ROOT_PART="$name"; ROOT_SIZE="$size"
    fi
  fi
done < <(lsblk -b -lnpo NAME,FSTYPE,SIZE "$LOOP")

LAST_NUM="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | sed -E 's/.*[^0-9]([0-9]+)$/\1/' | tail -n1)"
ROOT_NUM=""
[[ -n "$ROOT_PART" ]] && ROOT_NUM="$(echo "$ROOT_PART" | sed -E 's/.*[^0-9]([0-9]+)$/\1/')"

log "Boot: ${BOOT_PART:-unknown}  Root: ${ROOT_PART:-unknown}"

# --------------------------- Shrink ext4 root -------------------
if [[ $NO_SHRINK -eq 0 && -n "$ROOT_PART" ]]; then
  if [[ -n "$ROOT_NUM" && -n "$LAST_NUM" && "$ROOT_NUM" == "$LAST_NUM" ]]; then
    log "Shrinking ext4 filesystem on $ROOT_PART to minimum"
    e2fsck -fy "$ROOT_PART"
    resize2fs -M "$ROOT_PART"

    # Compute new end sector
    BS=""; BC=""
    eval "$(dumpe2fs -h "$ROOT_PART" 2>/dev/null | awk '
      /Block size:/ {bs=$3}
      /Block count:/ {bc=$3}
      END{printf "BS=%d;BC=%d;\n",bs,bc }')"
    [[ -n "$BS" && -n "$BC" ]] || { err "Failed to read ext4 geometry."; exit 6; }
    FS_BYTES=$(( BS * BC ))

    START_SECT="$(sfdisk -d "$LOOP" | awk -v rp="$(basename "$ROOT_PART")" '$0 ~ rp {gsub(/,/, "", $4); print $4}')"
    [[ -n "$START_SECT" ]] || { err "Failed to read root start sector."; exit 7; }
    NEEDED_SECT=$(( (FS_BYTES + SECT_SIZE - 1) / SECT_SIZE ))
    NEW_END=$(( START_SECT + NEEDED_SECT - 1 ))
    log "Resizing root partition end to sector $NEW_END"
    parted -s "$LOOP" unit s resizepart "$ROOT_NUM" "${NEW_END}s"
    partprobe "$LOOP"
    settle
    ok "Root shrink complete"
  else
    warn "Root partition is not the last partition. Skipping shrink."
  fi
elif [[ $NO_SHRINK -eq 1 ]]; then
  warn "--no-shrink set. Skipping shrink."
else
  warn "No ext* root detected. Skipping shrink."
fi

# --------------------------- Truncate ---------------------------
LAST_END_IMG="$(sfdisk -d "$LOOP" | awk '/start=/{e=$3+$5-1} END{print e}')"
[[ -n "$LAST_END_IMG" ]] || { err "Failed to compute image end sector."; exit 8; }
FINAL_BYTES=$(( (LAST_END_IMG + 1) * SECT_SIZE ))
log "Detaching loop and truncating image to $FINAL_BYTES bytes"
losetup -d "$LOOP" || true
# remove pending cleanup for loop (already detached)
unset 'CLEANUP_CMDS[${#CLEANUP_CMDS[@]}-1]'
truncate -s "$FINAL_BYTES" "$TMP_IMG"
ok "Truncate complete"

# --------------------------- Verify (pre-compress) --------------
if [[ $VERIFY -eq 1 ]]; then
  log "Verifying image structure (fsck -n and read-only mounts)"
  LOOP_VERIFY="$(losetup --show -fP "$TMP_IMG")"
  push_cleanup "losetup -d '$LOOP_VERIFY' >/dev/null 2>&1"
  settle
  # fsck pass
  while read -r p; do
    [[ "$p" == "$LOOP_VERIFY" ]] && continue
    fstype="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
    case "$fstype" in
      ext*) e2fsck -fn "$p" >/dev/null ;;
      vfat|fat) [[ -n "$FSCK_FAT_BIN" ]] && "$FSCK_FAT_BIN" -n "$p" >/dev/null || true ;;
      *) : ;;
    esac
  done < <(lsblk -lnpo NAME "$LOOP_VERIFY" | tail -n +1)

  # smoke read-only mount for ext*
  MNT_TMP="$(mktemp -d)"
  push_cleanup "umount '$MNT_TMP' >/dev/null 2>&1; rmdir '$MNT_TMP' >/dev/null 2>&1"
  while read -r p; do
    [[ "$p" == "$LOOP_VERIFY" ]] && continue
    fstype="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
    if [[ "$fstype" =~ ^ext ]]; then
      mount -o ro,norecover,noload "$p" "$MNT_TMP" 2>/dev/null || true
      ls -A "$MNT_TMP" >/dev/null 2>&1 || true
      umount "$MNT_TMP" >/dev/null 2>&1 || true
    fi
  done < <(lsblk -lnpo NAME "$LOOP_VERIFY" | tail -n +1)
  ok "Verify complete"
fi

# --------------------------- Compression ------------------------
do_compress="none"
case "$COMPRESS" in
  auto)
    if [[ "$OUT_IMG" == *.xz ]]; then do_compress="xz"
    elif [[ "$OUT_IMG" == *.gz ]]; then do_compress="gz"
    elif [[ "$OUT_IMG" == *.zst ]]; then do_compress="zst"
    else do_compress="xz"
    fi
    ;;
  xz|gz|zst|none) do_compress="$COMPRESS" ;;
  *) err "Invalid --compress option"; exit 9;;
esac

if [[ "$TMP_IMG" != "$OUT_IMG" || "$do_compress" != "none" ]]; then
  case "$do_compress" in
    xz)
      need xz
      log "Compressing to $OUT_IMG with xz -T0 -9e"
      xz -T0 -9e -f -c "$TMP_IMG" > "$OUT_IMG"
      ;;
    gz)
      need gzip
      log "Compressing to $OUT_IMG with gzip -9"
      gzip -9 -f -c "$TMP_IMG" > "$OUT_IMG"
      ;;
    zst)
      need zstd
      log "Compressing to $OUT_IMG with zstd -T0 -19"
      zstd -T0 -19 -f -c "$TMP_IMG" > "$OUT_IMG"
      ;;
    none)
      OUT_IMG="$TMP_IMG"
      warn "No compression selected."
      ;;
  esac
else
  OUT_IMG="$TMP_IMG"
fi

# --------------------------- Digest -----------------------------
log "Computing SHA-256 checksum"
sha256sum "$OUT_IMG" | tee "${OUT_IMG}.sha256" >/dev/null
ok "All done."
printf "%s\n%s\n" "Image: $OUT_IMG" "SHA256: $(cut -d' ' -f1 "${OUT_IMG}.sha256")"
