#!/usr/bin/env bash
# pi-image-capture.sh — Zero-touch Raspberry Pi SD → distributable image
# Author: 4ndr0666
# Version: 1.6.2
# License: MIT
#
# Highlights:
# - Auto-detect source (never hardcodes /dev/sde). Falls back to TUI if ambiguous/none.
# - Strict loop hygiene: unmounts and detaches loop partitions we create; also reaps
#   any stale loops pointing at the target image path on start and on failure.
# - Non-interactive shrink (sfdisk first, parted fallback), safe truncate guards,
#   verify, compress, checksum. Stops udisks2 during capture, restarts on exit.

set -Eeuo pipefail
VERSION="1.6.2"

# -------- defaults --------
SRC_DEV=""; OUT_IMG=""; COMPRESS="auto"; FAST_DD=0; NO_SHRINK=0; VERIFY=0
QUIET=0; JSON=0; COLOR=1; LOG_FILE=""; FORCE=0; TUI=0; AUTO=0; SHRINK_IMG=""
TIMEOUT_SECS="${TIMEOUT_SECS:-0}"

# -------- logging --------
ts(){ date +"%Y-%m-%dT%H:%M:%S%z"; }
emit(){ local L="$1"; shift; local M="$*"; [[ -n "$LOG_FILE" ]] && printf "%s %s %s\n" "$(ts)" "$L" "$M" >>"$LOG_FILE"
  if [[ $JSON -eq 1 ]]; then printf '{ "ts":"%s","level":"%s","msg":%q }\n' "$(ts)" "$L" "$M"; return; fi
  [[ $QUIET -eq 1 && "$L" != "ERR" ]] && return
  if [[ $COLOR -eq 1 ]]; then case "$L" in
    INFO) printf "\033[1;34m[INFO]\033[0m %s\n" "$M" ;; WARN) printf "\033[1;33m[WARN]\033[0m %s\n" "$M" ;;
    DONE) printf "\033[1;32m[DONE]\033[0m %s\n" "$M" ;; ERR)  printf "\033[1;31m[ERR ]\033[0m %s\n" "$M" ;;
    *)    printf "[%s] %s\n" "$L" "$M" ;; esac
  else printf "[%s] %s\n" "$L" "$M"; fi; }
log(){ emit INFO "$*"; } warn(){ emit WARN "$*"; } ok(){ emit DONE "$*"; } err(){ emit ERR "$*"; }

# -------- usage --------
usage(){ cat <<EOF
pi-image-capture.sh v$VERSION
Usage:
  sudo $0 --auto
  sudo $0 --shrink-img ./file.img[.xz|.gz] [--compress auto|xz|gz|zst|none] [--verify]
  sudo $0 -s /dev/sdX -o ./raspi.img[.xz|.gz|.zst] [--verify] [--fast-dd] [--no-shrink]
EOF
}

# -------- args --------
[[ $EUID -eq 0 ]] || { err "Run as root."; exit 2; }
while [[ $# -gt 0 ]]; do case "$1" in
  --auto) AUTO=1; shift;;
  --shrink-img) SHRINK_IMG="${2:-}"; shift 2;;
  -s|--source) SRC_DEV="${2:-}"; shift 2;;
  -o|--output) OUT_IMG="${2:-}"; shift 2;;
  --compress) COMPRESS="${2:-}"; shift 2;;
  --fast-dd) FAST_DD=1; shift;;
  --no-shrink) NO_SHRINK=1; shift;;
  --verify) VERIFY=1; shift;;
  --force) FORCE=1; shift;;
  --tui) TUI=1; shift;;
  --no-color) COLOR=0; shift;;
  --quiet) QUIET=1; shift;;
  --json) JSON=1; shift;;
  --log-file) LOG_FILE="${2:-}"; shift 2;;
  -h|--help) usage; exit 0;;
  *) err "Unknown arg: $1"; usage; exit 2;;
esac; done

# -------- helpers --------
need(){ command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }; }
settle(){ command -v udevadm >/dev/null 2>&1 && udevadm settle || true; }
run_to(){ if [[ "$TIMEOUT_SECS" -gt 0 ]]; then timeout --foreground "$TIMEOUT_SECS" "$@"; else "$@"; fi; }
ask_yes(){ [[ $FORCE -eq 1 ]] && return 0; read -r -p "${1:-Proceed?} [y/N]: " a; [[ "$a" =~ ^[Yy]$ ]]; }

CLEANUP=()
pushc(){ CLEANUP+=("$*"); }
on_exit(){ set +e; for ((i=${#CLEANUP[@]}-1;i>=0;i--)); do eval "${CLEANUP[$i]}" || true; done; }
trap on_exit EXIT

stop_automount(){
  if command -v systemctl >/dev/null 2>&1 && systemctl is-active --quiet udisks2.service; then
    log "Stopping udisks2"; systemctl stop udisks2.service || true; pushc "systemctl start udisks2.service || true"
  fi
}

auto_unmount_any(){
  local node="$1" base; base="$(basename "$node")"
  # unmount by lsblk and mount output for both disk and its partitions
  lsblk -lnpo NAME,MOUNTPOINT "$node" | awk '$2!=""{print $2}' | while read -r m; do umount -f "$m" 2>/dev/null || true; done
  mount | awk -v b="$base" '$1 ~ b {print $3}' | while read -r m; do umount -f "$m" 2>/dev/null || true; done
}

detach_loops_by_backfile(){
  # detach any loop whose back-file equals the given path
  local path="$1"; [[ -z "${path:-}" ]] && return 0
  losetup -l -O NAME,BACK-FILE 2>/dev/null | awk -v p="$path" 'NR>1 && $0 ~ p {print $1}' | while read -r L; do
    auto_unmount_any "$L"; losetup -d "$L" 2>/dev/null || true
  done
}

# extra GC: detach any loops pointing to non-existent back-files under CWD
gc_orphan_loops(){
  losetup -l -O NAME,BACK-FILE 2>/dev/null | tail -n +2 | while read -r name back; do
    [[ -n "$back" && "$back" != "-" ]] || continue
    if [[ "$back" == "$PWD/"* && ! -e "$back" ]]; then
      auto_unmount_any "$name"; losetup -d "$name" 2>/dev/null || true
    fi
  done
}

decide_comp(){
  case "$1" in
    auto) [[ "$OUT_IMG" == *.xz ]]&&echo xz||{ [[ "$OUT_IMG" == *.gz ]]&&echo gz||{ [[ "$OUT_IMG" == *.zst ]]&&echo zst||echo xz; }; };;
    xz|gz|zst|none) echo "$1" ;;
    *) err "Invalid --compress"; exit 9;;
  esac
}

tui(){
  log "TUI"
  local choices; choices="$(lsblk -bdpno NAME,SIZE,RM,TYPE,MOUNTPOINT,MODEL,TRAN | awk '$3==1 && $4=="disk" {printf "%s  (%d bytes)  %s %s\n",$1,$2,$6,$7}')"
  if command -v fzf >/dev/null 2>&1; then SRC_DEV="$(printf "%s\n" "$choices" | fzf --prompt="Select source > " | awk '{print $1}')"
  else printf "%s\n" "$choices"; read -r -p "Source device: " SRC_DEV; fi
  [[ -b "$SRC_DEV" ]] || { err "Invalid source: $SRC_DEV"; exit 2; }
  read -r -p "Output image path [./raspi.img.xz]: " OUT_IMG; OUT_IMG="${OUT_IMG:-./raspi.img.xz}"
  read -r -p "Compression [auto|xz|gz|zst|none] (auto): " COMPRESS; COMPRESS="${COMPRESS:-auto}"
  read -r -p "Verify after capture? [y/N]: " v; [[ "$v" =~ ^[Yy]$ ]] && VERIFY=1 || VERIFY=0
}

# -------- deps --------
for b in lsblk sfdisk partprobe blkid losetup fdisk truncate sha256sum stat; do need "$b"; done
command -v ddrescue >/dev/null || true; command -v pv >/dev/null || true
command -v xz >/dev/null || true; command -v gzip >/dev/null || true; command -v zstd >/dev/null || true
command -v parted >/dev/null || true; command -v udevadm >/dev/null || true
if [[ -z "$SHRINK_IMG" && $NO_SHRINK -eq 0 ]] || [[ -n "$SHRINK_IMG" ]]; then
  for b in e2fsck resize2fs dumpe2fs; do need "$b"; done
fi
FSCK_FAT_BIN="$(command -v fsck.fat || command -v dosfsck || true)"

# -------- core routines --------
detect_src_auto(){
  # consider removable disks; if exactly one, pick; if >1 or 0, drop into TUI
  mapfile -t CAND < <(lsblk -bdpno NAME,RM,TYPE,MOUNTPOINT | awk '$2==1 && $3=="disk"{print $1}' || true)
  if (( ${#CAND[@]} == 1 )); then SRC_DEV="${CAND[0]}"
  else
    warn "Ambiguous or no removable disks found; opening chooser."
    TUI=1; tui
  fi
}

prepare_output_auto(){ OUT_IMG="${OUT_IMG:-$PWD/pi-$(date -u +%Y%m%dT%H%M%SZ).img.xz}"; COMPRESS="${COMPRESS:-auto}"; VERIFY=1; }

calc_copy_span(){
  local dev="$1" ss last
  if [[ -r "/sys/class/block/$(basename "$dev")/queue/logical_block_size" ]]; then ss="$(cat "/sys/class/block/$(basename "$dev")/queue/logical_block_size")"
  else ss="$(blockdev --getss "$dev")"; fi
  SECT_SIZE="$ss"
  last="$(sfdisk -d "$dev" 2>/dev/null | awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e+1}')"
  [[ -n "$last" ]] || { err "$dev: no recognized partition table"; exit 5; }
  LAST_END_SECT="$last"; RAW_BYTES=$(( LAST_END_SECT * SECT_SIZE ))
}

capture_device(){
  local dev="$1" out="$2"
  log "Capturing $dev → $out"
  case "$out" in *.xz|*.gz|*.zst) TMP_IMG="${out%.*}" ;; *) TMP_IMG="$out" ;; esac
  # pre-clean any stale loops on this path
  detach_loops_by_backfile "$TMP_IMG"
  if command -v ddrescue >/dev/null 2>&1 && [[ $FAST_DD -eq 0 ]]; then
    run_to ddrescue -v --force --size="$RAW_BYTES" --sector-size="$SECT_SIZE" "$dev" "$TMP_IMG" "${TMP_IMG}.map"
  else
    if command -v pv >/dev/null 2>&1; then run_to bash -c 'pv -tpreb -s "$0" "$1" | dd of="$2" bs=4M status=none conv=fsync' "$RAW_BYTES" "$dev" "$TMP_IMG"
    else run_to dd if="$dev" of="$TMP_IMG" bs=4M count="$RAW_BYTES" iflag=count_bytes status=progress conv=fsync; fi
  fi
  sync; ok "Capture complete"
}

attach_loop(){
  local img="$1"
  LOOP="$(losetup --show -fP "$img")"; pushc "losetup -d '$LOOP' >/dev/null 2>&1"
  settle; auto_unmount_any "$LOOP"; settle
  local lsz; lsz="$(blockdev --getsize64 "$LOOP" 2>/dev/null || echo 0)"; [[ "$lsz" -ge 512 ]] || { err "Loop <512 B; aborting"; exit 10; }
}

detect_fs(){
  BOOT_PART=""; ROOT_PART=""; ROOT_SIZE=0; BOOT_SIZE=0
  while read -r n f s; do
    [[ "$n" == "$LOOP" || -z "$f" ]] && continue
    if [[ "$f" =~ ^(vfat|fat|exfat)$ ]]; then [[ -z "$BOOT_PART" || "$s" -lt "$BOOT_SIZE" ]] && BOOT_PART="$n" BOOT_SIZE="$s"
    elif [[ "$f" =~ ^ext ]]; then [[ "$s" -gt "$ROOT_SIZE" ]] && ROOT_PART="$n" ROOT_SIZE="$s"; fi
  done < <(lsblk -b -lnpo NAME,FSTYPE,SIZE "$LOOP")
  LAST_NUM="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | sed -E 's/.*[^0-9]([0-9]+)$/\1/' | tail -n1 || true)"
  ROOT_NUM=""; [[ -n "$ROOT_PART" ]] && ROOT_NUM="$(echo "$ROOT_PART" | sed -E 's/.*[^0-9]([0-9]+)$/\1/')"
  log "Boot: ${BOOT_PART:-unknown}  Root: ${ROOT_PART:-unknown}"
}

shrink_ext4_if_last(){
  [[ $NO_SHRINK -eq 1 ]] && { warn "--no-shrink set"; return 0; }
  [[ -n "$ROOT_PART" && -n "$ROOT_NUM" && -n "$LAST_NUM" && "$ROOT_NUM" == "$LAST_NUM" ]] || { warn "Skip shrink (no ext* root last)"; return 0; }
  auto_unmount_any "$LOOP"; settle
  log "e2fsck $ROOT_PART"; run_to e2fsck -fy "$ROOT_PART"
  log "resize2fs -M $ROOT_PART"; run_to resize2fs -M "$ROOT_PART"
  local BS="" BC=""; eval "$(dumpe2fs -h "$ROOT_PART" 2>/dev/null | awk '/Block size:/ {bs=$3} /Block count:/ {bc=$3} END{printf "BS=%d;BC=%d;\n",bs,bc }')"
  [[ -n "$BS" && -n "$BC" ]] || { warn "No ext4 geometry; skip partition resize"; return 0; }
  local FS_BYTES=$(( BS * BC ))
  local START_SECT; START_SECT="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' -v p="$(basename "$ROOT_PART")" '$1==p {print $4}')"
  [[ -n "$START_SECT" ]] || { warn "No start sector; skip partition resize"; return 0; }
  local NEEDED_SECT=$(( (FS_BYTES + SECT_SIZE - 1) / SECT_SIZE )); local NEW_END=$(( START_SECT + NEEDED_SECT - 1 ))
  log "Resize root end → sector $NEW_END (sfdisk)"
  if echo ",${NEEDED_SECT}" | run_to sfdisk --no-reread -N "$ROOT_NUM" "$LOOP"; then partprobe "$LOOP" || losetup -c "$LOOP" || true; settle; ok "Partition resized (sfdisk)"
  else warn "sfdisk failed; trying parted"; if run_to parted -s "$LOOP" unit s resizepart "$ROOT_NUM" "${NEW_END}s"; then partprobe "$LOOP" || losetup -c "$LOOP" || true; settle; ok "Partition resized (parted)"; else warn "Partition resize failed; continuing unshrunk"; fi; fi
}

truncate_image_safely(){
  local img="$1" last final filebytes
  last="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e}')" || true
  [[ -n "$last" ]] || { err "Cannot compute end sector; refusing to truncate"; exit 8; }
  final=$(( (last + 1) * SECT_SIZE )); filebytes="$(stat -c %s "$img")"
  (( final >= 1048576 )) || { err "Final size <1MiB ($final). Abort."; exit 11; }
  (( final <= filebytes )) || { err "Final size ($final) > file size ($filebytes). Abort."; exit 12; }
  log "Detach loop and truncate to $final bytes"; losetup -d "$LOOP" || true; [[ ${#CLEANUP[@]} -gt 0 ]] && unset 'CLEANUP[${#CLEANUP[@]}-1]'
  run_to truncate -s "$final" "$img"; ok "Truncate complete"
}

verify_image(){
  local img="$1"; [[ $VERIFY -eq 1 ]] || return 0
  log "Verify image"
  local L; L="$(losetup --show -fP "$img")"; pushc "losetup -d '$L' >/dev/null 2>&1"; settle; auto_unmount_any "$L"; settle
  while read -r p; do [[ "$p" == "$L" ]] && continue
    local t; t="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
    case "$t" in ext*) run_to e2fsck -fn "$p" >/dev/null ;; vfat|fat|exfat) [[ -n "$FSCK_FAT_BIN" ]] && run_to "$FSCK_FAT_BIN" -n "$p" >/dev/null || true ;; esac
  done < <(lsblk -lnpo NAME "$L" | tail -n +2)
  losetup -d "$L" || true; ok "Verify complete"
}

compress_and_hash(){
  local img="$1" mode; mode="$(decide_comp "$COMPRESS")"
  if [[ "$mode" == "none" ]]; then OUT_IMG="${OUT_IMG:-$img}"; [[ "$img" != "$OUT_IMG" ]] && mv -f -- "$img" "$OUT_IMG"; warn "No compression selected"
  else
    [[ -n "$OUT_IMG" ]] || OUT_IMG="${img}.${mode}"
    log "Compress → $OUT_IMG ($mode)"
    case "$mode" in xz) need xz;  run_to xz   -T0 -9e -f -c -- "$img" > "$OUT_IMG" ;;
                      gz) need gzip;run_to gzip -9    -f -c -- "$img" > "$OUT_IMG" ;;
                     zst) need zstd;run_to zstd -T0 -19 -f -c -- "$img" > "$OUT_IMG" ;; esac
    rm -f -- "$img"
  fi
  log "SHA-256"; sha256sum "$OUT_IMG" | tee "${OUT_IMG}.sha256" >/dev/null
  ok "All done."; printf "%s\n%s\n" "Image: $OUT_IMG" "SHA256: $(cut -d' ' -f1 "${OUT_IMG}.sha256")"
}

# -------- shrink-existing-image mode --------
if [[ -n "$SHRINK_IMG" ]]; then
  gc_orphan_loops
  case "$SHRINK_IMG" in
    *.xz) need xz;   xz -dkf -- "$SHRINK_IMG";  TMP_IMG="${SHRINK_IMG%.xz}" ;;
    *.gz) need gzip; gunzip -kf -- "$SHRINK_IMG"; TMP_IMG="${SHRINK_IMG%.gz}" ;;
    *)    TMP_IMG="$SHRINK_IMG" ;;
  esac
  [[ -f "$TMP_IMG" ]] || { err "Image not found: $TMP_IMG"; exit 2; }
  detach_loops_by_backfile "$TMP_IMG"
  attach_loop "$TMP_IMG"
  if [[ -r "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size" ]]; then SECT_SIZE="$(cat "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size")"; else SECT_SIZE="512"; fi
  detect_fs; shrink_ext4_if_last; truncate_image_safely "$TMP_IMG"; verify_image "$TMP_IMG"; compress_and_hash "$TMP_IMG"; exit 0
fi

# -------- input / auto / tui --------
gc_orphan_loops
if [[ $TUI -eq 1 || ( $AUTO -eq 0 && ( -z "${SRC_DEV:-}" || -z "${OUT_IMG:-}" ) ) ]]; then tui; fi
if [[ $AUTO -eq 1 ]]; then stop_automount; detect_src_auto; prepare_output_auto; fi
if [[ $AUTO -eq 0 ]]; then [[ -b "${SRC_DEV:-/dev/null}" ]] || { err "Missing/invalid --source"; usage; exit 2; }; [[ -n "${OUT_IMG:-}" ]] || OUT_IMG="./pi-$(date -u +%Y%m%dT%H%M%SZ).img.xz"; fi

# refuse destination on same physical device
OUT_DIR="$(dirname "$(readlink -f "$OUT_IMG")")"
SRC_PDEV="$(lsblk -no PKNAME "$SRC_DEV" 2>/dev/null || true)"
OUT_SRC="$(df --output=source "$OUT_DIR" 2>/dev/null | tail -n1 || true)"
if [[ -n "$SRC_PDEV" && "$OUT_SRC" == *"$SRC_PDEV"* ]]; then err "Destination is on source device"; exit 4; fi

# unmount source and capture
log "Unmounting any mounted partitions on $SRC_DEV"; while read -r P; do [[ -n "$P" && "$P" != "$SRC_DEV" ]] && umount -f "$P" 2>/dev/null || true; done < <(lsblk -lnpo NAME "$SRC_DEV"); settle; sync
calc_copy_span "$SRC_DEV"
capture_device "$SRC_DEV" "$OUT_IMG"

# loop workflow
attach_loop "$TMP_IMG"
detect_fs
shrink_ext4_if_last
truncate_image_safely "$TMP_IMG"
verify_image "$TMP_IMG"
compress_and_hash "$TMP_IMG"