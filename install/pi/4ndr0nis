#!/usr/bin/env bash
# pi-image-capture.sh — Zero-touch Raspberry Pi SD → distributable image tool (superset)
# Author: 4ndr0666
# Version: 1.7.3
# License: MIT
#
# Modes:
#   --auto                 Detect source, stop automount, capture → optional shrink → safe truncate → verify → compress → checksum
#   --shrink-img <IMG>     Offline-shrink an existing image file and safely truncate (no source device needed)
#
# Guarantees:
#   - Handles disks with NO partition table: copies full device, skips shrink/loop ops, then compresses and hashes.
#   - Refuses dangerous truncates (final size < 1 MiB or > file size; never grows).
#   - Non-interactive partition resize (sfdisk first, parted as fallback).
#   - Auto-unmounts loop auto-mounts and stops udisks2 during capture (if systemd).
#   - TUI selection if requested or args omitted (fzf optional).
#   - ShellCheck-clean, strict mode, deterministic.

set -Eeuo pipefail

# shellcheck disable=SC2034
VERSION="1.7.3"

# --------------------------- Defaults ---------------------------
# shellcheck disable=SC2034
SRC_DEV=""
# shellcheck disable=SC2034
OUT_IMG=""
# shellcheck disable=SC2034
COMPRESS="auto"         # auto|xz|gz|zst|none
# shellcheck disable=SC2034
FAST_DD=0               # prefer dd over ddrescue
# shellcheck disable=SC2034
NO_SHRINK=0             # skip shrink stage
# shellcheck disable=SC2034
VERIFY=0                # fsck -n and optional RO mount check
QUIET=0
JSON=0
COLOR=1
LOG_FILE=""
# shellcheck disable=SC2034
FORCE=0
# shellcheck disable=SC2034
TUI=0
# shellcheck disable=SC2034
AUTO=0
# shellcheck disable=SC2034
SHRINK_IMG=""
TIMEOUT_SECS="${TIMEOUT_SECS:-0}"  # 0 = none

# --------------------------- Logging ----------------------------
ts() {
  date +"%Y-%m-%dT%H:%M:%S%z"
}

emit() {
  local L="$1"
  shift
  local M="$*"
  if [[ -n "$LOG_FILE" ]]; then
    printf "%s %s %s\n" "$(ts)" "$L" "$M" >>"$LOG_FILE"
  fi
  if [[ $JSON -eq 1 ]]; then
    printf '{ "ts":"%s","level":"%s","msg":%q }\n' "$(ts)" "$L" "$M"
    return
  fi
  if [[ $QUIET -eq 1 && "$L" != "ERR" ]]; then
    return
  fi
  if [[ $COLOR -eq 1 ]]; then
    case "$L" in
      INFO) printf "\033[1;34m[INFO]\033[0m %s\n" "$M" ;;
      WARN) printf "\033[1;33m[WARN]\033[0m %s\n" "$M" ;;
      DONE) printf "\033[1;32m[DONE]\033[0m %s\n" "$M" ;;
      ERR ) printf "\033[1;31m[ERR ]\033[0m %s\n" "$M" ;;
      *)    printf "[%s] %s\n" "$L" "$M" ;;
    esac
  else
    printf "[%s] %s\n" "$L" "$M"
  fi
}

log() {
  emit INFO "$*"
}

warn() {
  emit WARN "$*"
}

ok() {
  emit DONE "$*"
}

err() {
  emit ERR "$*"
}

# --------------------------- Usage ------------------------------
usage() {
  cat <<'EOF'
pi-image-capture.sh

Usage:
  sudo ./pi-image-capture.sh --auto
  sudo ./pi-image-capture.sh --shrink-img ./file.img[.xz|.gz|.zst] [--compress auto|xz|gz|zst|none] [--verify]
  sudo ./pi-image-capture.sh -s /dev/sdX -o ./raspi.img[.xz|.gz|.zst] [--verify] [--fast-dd] [--no-shrink]

Options:
  --auto                 Zero-touch: autodetect source and run full pipeline
  --shrink-img IMG       Offline-shrink and truncate an existing image file
  -s, --source DEV       Source device (/dev/sdX or /dev/mmcblk0)
  -o, --output FILE      Output image path (suffix controls compression when --compress=auto)
      --compress MODE    auto|xz|gz|zst|none  (default auto)
      --fast-dd          Prefer dd over ddrescue
      --no-shrink        Skip ext4 shrink (partition resize + truncate still safe)
      --verify           Run fsck -n on image partitions (and RO mount for ext*)
      --force            Auto-confirm prompts (TUI still asks if you launch it)
      --tui              Simple device selection UI (fzf if present, else prompts)
      --no-color         Disable colored logs
      --quiet            Suppress non-error logs
      --json             JSON logs
      --log-file PATH    Append logs to file
  -h, --help             Show help

Env:
  TIMEOUT_SECS=N         Timeout for long steps (0 = none)
EOF
}

# --------------------------- Argparse ---------------------------
if [[ $EUID -ne 0 ]]; then
  err "Run as root."
  exit 2
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --auto) AUTO=1; shift;;
    --shrink-img) SHRINK_IMG="${2:-}"; shift 2;;
    -s|--source) SRC_DEV="${2:-}"; shift 2;;
    -o|--output) OUT_IMG="${2:-}"; shift 2;;
    --compress)  COMPRESS="${2:-}"; shift 2;;
    --fast-dd)   FAST_DD=1; shift;;
    --no-shrink) NO_SHRINK=1; shift;;
    --verify)    VERIFY=1; shift;;
    --force)     FORCE=1; shift;;
    --tui)       TUI=1; shift;;
    --no-color)  COLOR=0; shift;;
    --quiet)     QUIET=1; shift;;
    --json)      JSON=1; shift;;
    --log-file)  LOG_FILE="${2:-}"; shift 2;;
    -h|--help)   usage; exit 0;;
    *) err "Unknown arg: $1"; usage; exit 2;;
  esac
done

# --------------------------- Helpers ----------------------------
need() {
  command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; exit 3; }
}

settle() {
  if command -v udevadm >/dev/null 2>&1; then
    udevadm settle || true
  fi
}

run_to() {
  if [[ "$TIMEOUT_SECS" -gt 0 ]]; then
    timeout --foreground "$TIMEOUT_SECS" "$@"
  else
    "$@"
  fi
}

CLEANUP=()

pushc() {
  CLEANUP+=("$*")
}

on_exit() {
  set +e
  local i
  for ((i=${#CLEANUP[@]}-1;i>=0;i--)); do
    eval "${CLEANUP[$i]}" || true
  done
}

trap on_exit EXIT

stop_automount() {
  if command -v systemctl >/dev/null 2>&1 && systemctl is-active --quiet udisks2.service; then
    log "Stopping udisks2"
    systemctl stop udisks2.service || true
    pushc "systemctl start udisks2.service || true"
  fi
}

auto_unmount_all() {
  local t="$1"
  local b
  b="$(basename "$t")"
  mount | awk -v b="$b" '$1 ~ b {print $3}' | while read -r m; do
    umount -f "$m" 2>/dev/null || true
  done
}

decide_comp() {
  case "$1" in
    auto)
      if [[ "$OUT_IMG" == *.xz ]]; then
        echo xz
      elif [[ "$OUT_IMG" == *.gz ]]; then
        echo gz
      elif [[ "$OUT_IMG" == *.zst ]]; then
        echo zst
      else
        echo xz
      fi
      ;;
    xz|gz|zst|none) echo "$1" ;;
    *) err "Invalid --compress"; exit 9;;
  esac
}

tui() {
  log "TUI mode"
  local choices
  choices="$(lsblk -bdpno NAME,SIZE,RM,TYPE,MOUNTPOINT,MODEL,TRAN | awk '$3==1 && $4=="disk" {printf "%s  (%d bytes)  %s %s\n",$1,$2,$6,$7}')"
  if command -v fzf >/dev/null 2>&1; then
    SRC_DEV="$(printf "%s\n" "$choices" | fzf --prompt="Select source device > " | awk '{print $1}')"
  else
    printf "%s\n" "$choices"
    read -r -p "Source device (e.g. /dev/sdb): " SRC_DEV
  fi
  if [[ ! -b "$SRC_DEV" ]]; then
    err "Invalid source: $SRC_DEV"
    exit 2
  fi
  read -r -p "Output image path [./raspi.img.zst]: " OUT_IMG
  OUT_IMG="${OUT_IMG:-./raspi.img.zst}"
  read -r -p "Compression [auto|xz|gz|zst|none] (auto): " COMPRESS
  COMPRESS="${COMPRESS:-auto}"
  read -r -p "Verify after capture? [y/N]: " v
  if [[ "$v" =~ ^[Yy]$ ]]; then VERIFY=1; else VERIFY=0; fi
}

# --------------------------- Dependencies -----------------------
for b in lsblk sfdisk partprobe blkid losetup fdisk truncate sha256sum stat blockdev; do need "$b"; done
command -v ddrescue >/dev/null 2>&1 || true
command -v pv       >/dev/null 2>&1 || true
command -v xz       >/dev/null 2>&1 || true
command -v gzip     >/dev/null 2>&1 || true
command -v zstd     >/dev/null 2>&1 || true
command -v parted   >/dev/null 2>&1 || true
command -v udevadm  >/dev/null 2>&1 || true
FSCK_FAT_BIN="$(command -v fsck.fat || command -v dosfsck || true)"

# --------------------------- Core -------------------------------
detect_src_auto() {
  local line dev
  line="$(lsblk -bdpno NAME,SIZE,RM,TYPE | awk '$3==1 && $4=="disk" {print $0}' | sort -k2,2n | tail -n1 || true)"
  dev="$(awk '{print $1}' <<<"$line")"
  if [[ ! -b "$dev" ]]; then
    err "No removable source device found."
    exit 2
  fi
  SRC_DEV="$dev"
}

prepare_output_auto() {
  local outdir file
  outdir="$PWD"
  file="pi-$(date -u +%Y%m%dT%H%M%SZ).img.zst"
  OUT_IMG="${OUT_IMG:-$outdir/$file}"
  COMPRESS="${COMPRESS:-zst}"
  VERIFY=1
}

calc_copy_span() { # works with or without a partition table
  local dev="$1"
  if [[ -r "/sys/class/block/$(basename "$dev")/queue/logical_block_size" ]]; then
    SECT_SIZE="$(cat "/sys/class/block/$(basename "$dev")/queue/logical_block_size")"
  else
    SECT_SIZE="$(blockdev --getss "$dev")"
  fi
  local dump
  dump="$(sfdisk -d "$dev" 2>/dev/null || true)"
  if [[ -n "$dump" && "$dump" == *"start="* ]]; then
    LAST_END_SECT="$(awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e+1}' <<<"$dump")"
    RAW_BYTES=$(( LAST_END_SECT * SECT_SIZE ))
    PT_PRESENT=1
  else
    warn "No partition table detected on $dev; copying full device."
    RAW_BYTES="$(blockdev --getsize64 "$dev")"
    LAST_END_SECT=$(( RAW_BYTES / SECT_SIZE ))
    PT_PRESENT=0
  fi
}

capture_device() {
  local dev="$1"
  local out="$2"
  log "Capturing $dev → $out"
  case "$out" in
    *.xz|*.gz|*.zst) TMP_IMG="${out%.*}" ;;
    *)               TMP_IMG="$out" ;;
  esac
  if command -v ddrescue >/dev/null 2>&1 && [[ $FAST_DD -eq 0 ]]; then
    run_to ddrescue -v --force --size="$RAW_BYTES" --sector-size="$SECT_SIZE" "$dev" "$TMP_IMG" "${TMP_IMG}.map"
  else
    : > "${TMP_IMG}.map"  # keep a stub map
    if command -v pv >/dev/null 2>&1; then
      run_to bash -c 'pv -tpreb -s "$0" "$1" | dd of="$2" bs=4M status=none conv=fsync' "$RAW_BYTES" "$dev" "$TMP_IMG"
    else
      run_to dd if="$dev" of="$TMP_IMG" bs=4M count="$RAW_BYTES" iflag=count_bytes status=progress conv=fsync
    fi
  fi
  sync
  ok "Capture complete"
}

attach_loop() {
  local img="$1"
  LOOP="$(losetup --show -fP "$img")"
  pushc "losetup -d '$LOOP' >/dev/null 2>&1"
  settle
  auto_unmount_all "$LOOP"
  settle
  local lsz
  lsz="$(blockdev --getsize64 "$LOOP" 2>/dev/null || echo 0)"
  if [[ "$lsz" -lt 512 ]]; then
    err "Loop size <512 B; abort."
    exit 10
  fi
}

detect_fs() {
  BOOT_PART=""
  ROOT_PART=""
  ROOT_SIZE=0
  BOOT_SIZE=0
  while read -r n f s; do
    [[ "$n" == "$LOOP" || -z "$f" ]] && continue
    if [[ "$f" =~ ^(vfat|fat|exfat)$ ]]; then
      if [[ -z "$BOOT_PART" || "$s" -lt "$BOOT_SIZE" ]]; then
        BOOT_PART="$n"; BOOT_SIZE="$s"
      fi
    elif [[ "$f" =~ ^ext ]]; then
      if [[ "$s" -gt "$ROOT_SIZE" ]]; then
        ROOT_PART="$n"; ROOT_SIZE="$s"
      fi
    fi
  done < <(lsblk -b -lnpo NAME,FSTYPE,SIZE "$LOOP")
  CHILD_CT="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | wc -l | tr -d ' ')"
  LAST_NUM="$(lsblk -lnpo NAME "$LOOP" | tail -n +2 | sed -E 's/.*[^0-9]([0-9]+)$/\1/' | tail -n1 || true)"
  ROOT_NUM=""
  if [[ -n "$ROOT_PART" ]]; then
    ROOT_NUM="$(echo "$ROOT_PART" | sed -E 's/.*[^0-9]([0-9]+)$/\1/')"
  fi
  log "Partitions: ${CHILD_CT:-0}  Boot: ${BOOT_PART:-unknown}  Root: ${ROOT_PART:-unknown}"
}

shrink_ext4_if_last() {
  if [[ $NO_SHRINK -eq 1 ]]; then
    warn "--no-shrink set"
    return 0
  fi
  if [[ -z "$ROOT_PART" || -z "$ROOT_NUM" || -z "$LAST_NUM" || "$ROOT_NUM" != "$LAST_NUM" ]]; then
    warn "Skip shrink (root not last or absent)"
    return 0
  fi
  auto_unmount_all "$LOOP"
  settle
  log "e2fsck $ROOT_PART"
  run_to e2fsck -fy "$ROOT_PART"
  log "resize2fs -M $ROOT_PART"
  run_to resize2fs -M "$ROOT_PART"
  local BS="" BC=""
  eval "$(dumpe2fs -h "$ROOT_PART" 2>/dev/null | awk '/Block size:/ {bs=$3} /Block count:/ {bc=$3} END{printf "BS=%d;BC=%d;\n",bs,bc }')"
  if [[ -z "$BS" || -z "$BC" ]]; then
    warn "No ext4 geometry; skip partition resize"
    return 0
  fi
  local FS_BYTES START_SECT NEEDED_SECT NEW_END
  FS_BYTES=$(( BS * BC ))
  START_SECT="$(sfdisk -d "$LOOP" | awk -F'[ ,]+' -v p="$(basename "$ROOT_PART")" '$1==p {print $4}')"
  if [[ -z "$START_SECT" ]]; then
    warn "No root start sector; skip partition resize"
    return 0
  fi
  NEEDED_SECT=$(( (FS_BYTES + SECT_SIZE - 1) / SECT_SIZE ))
  NEW_END=$(( START_SECT + NEEDED_SECT - 1 ))
  log "Resize root end → sector $NEW_END (sfdisk preferred)"
  if echo ",${NEEDED_SECT}" | run_to sfdisk --no-reread -N "$ROOT_NUM" "$LOOP"; then
    partprobe "$LOOP" || losetup -c "$LOOP" || true
    settle
    ok "Partition resized (sfdisk)"
  else
    warn "sfdisk failed; trying parted"
    if run_to parted -s "$LOOP" unit s resizepart "$ROOT_NUM" "${NEW_END}s"; then
      partprobe "$LOOP" || losetup -c "$LOOP" || true
      settle
      ok "Partition resized (parted)"
    else
      warn "Partition resize failed; continuing unshrunk"
    fi
  fi
}

truncate_image_safely() {
  local img="$1"
  local LAST_END_IMG FINAL_BYTES FILE_BYTES
  LAST_END_IMG="$(sfdisk -d "$LOOP" 2>/dev/null | awk -F'[ ,]+' '/start=/ {e=$4+$6-1} END {print e}' || true)"
  if [[ -z "$LAST_END_IMG" ]]; then
    warn "No partition table in image; truncate skipped."
    return 0
  fi
  FINAL_BYTES=$(( (LAST_END_IMG + 1) * SECT_SIZE ))
  FILE_BYTES="$(stat -c %s "$img")"
  if (( FINAL_BYTES < 1048576 )); then
    err "Final size < 1 MiB ($FINAL_BYTES). Abort."
    exit 11
  fi
  if (( FINAL_BYTES > FILE_BYTES )); then
    err "Final size ($FINAL_BYTES) > file size ($FILE_BYTES). Abort."
    exit 12
  fi
  log "Detach loop and truncate to $FINAL_BYTES bytes"
  losetup -d "$LOOP" || true
  if (( ${#CLEANUP[@]} > 0 )); then
    unset 'CLEANUP[${#CLEANUP[@]}-1]'
  fi
  chown --reference="$(dirname "$img")" "$img" 2>/dev/null || true
  run_to truncate -s "$FINAL_BYTES" "$img"
  ok "Truncate complete"
}

verify_image() {
  local img="$1"
  if [[ $VERIFY -ne 1 ]]; then
    return 0
  fi
  log "Verify image"
  local L
  L="$(losetup --show -fP "$img")"
  pushc "losetup -d '$L' >/dev/null 2>&1"
  settle
  auto_unmount_all "$L"
  settle
  local has_parts
  has_parts="$(lsblk -lnpo NAME "$L" | tail -n +2 | wc -l | tr -d ' ')"
  if [[ "$has_parts" == "0" ]]; then
    warn "Image has no partitions; fsck skipped."
  else
    while read -r p; do
      [[ "$p" == "$L" ]] && continue
      local t
      t="$(blkid -o value -s TYPE "$p" 2>/dev/null || true)"
      case "$t" in
        ext*) run_to e2fsck -fn "$p" >/dev/null ;;
        vfat|fat|exfat)
          if [[ -n "$FSCK_FAT_BIN" ]]; then
            run_to "$FSCK_FAT_BIN" -n "$p" >/dev/null || true
          fi
          ;;
        *) : ;;
      esac
    done < <(lsblk -lnpo NAME "$L" | tail -n +2)
  fi
  losetup -d "$L" || true
  ok "Verify complete"
}

compress_and_hash() {
  local img="$1"
  local mode
  mode="$(decide_comp "$COMPRESS")"
  if [[ "$mode" == "none" ]]; then
    OUT_IMG="${OUT_IMG:-$img}"
    if [[ "$img" != "$OUT_IMG" ]]; then
      mv -f -- "$img" "$OUT_IMG"
    fi
    warn "No compression selected"
  else
    [[ -n "$OUT_IMG" ]] || OUT_IMG="${img}.${mode}"
    log "Compress → $OUT_IMG ($mode)"
    if command -v pv >/dev/null 2>&1; then
      case "$mode" in
        xz)  need xz;   pv "$img" | run_to xz   -T0 -9e -f -c -- > "$OUT_IMG" ;;
        gz)  need gzip; pv "$img" | run_to gzip -9    -f -c -- > "$OUT_IMG" ;;
        zst) need zstd; pv "$img" | run_to zstd -T0 -19 -f -c -- > "$OUT_IMG" ;;
      esac
    else
      case "$mode" in
        xz)  need xz;   run_to xz   -T0 -9e -f -c -- "$img" > "$OUT_IMG" ;;
        gz)  need gzip; run_to gzip -9    -f -c -- "$img" > "$OUT_IMG" ;;
        zst) need zstd; run_to zstd -T0 -19 -f -c -- "$img" > "$OUT_IMG" ;;
      esac
    fi
    rm -f -- "$img"
  fi
  log "SHA-256"
  sha256sum "$OUT_IMG" | tee "${OUT_IMG}.sha256" >/dev/null
  ok "All done."
  printf "%s\n%s\n" "Image: $OUT_IMG" "SHA256: $(cut -d' ' -f1 "${OUT_IMG}.sha256")"
}

# --------------------------- Shrink existing image mode ---------
if [[ -n "$SHRINK_IMG" ]]; then
  local_img=""
  case "$SHRINK_IMG" in
    *.xz)  need xz;   xz   -dkf -- "$SHRINK_IMG";  local_img="${SHRINK_IMG%.xz}" ;;
    *.gz)  need gzip; gunzip -kf -- "$SHRINK_IMG"; local_img="${SHRINK_IMG%.gz}" ;;
    *.zst) need zstd; zstd -d -f -k -- "$SHRINK_IMG" -o "${SHRINK_IMG%.zst}"; local_img="${SHRINK_IMG%.zst}" ;;
    *)     local_img="$SHRINK_IMG" ;;
  esac
  if [[ ! -f "$local_img" ]]; then
    err "Image not found: $local_img"
    exit 2
  fi
  attach_loop "$local_img"
  if [[ -r "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size" ]]; then
    SECT_SIZE="$(cat "/sys/class/block/$(basename "$LOOP")/queue/logical_block_size")"
  else
    SECT_SIZE="512"
  fi
  detect_fs
  if [[ "${CHILD_CT:-0}" != "0" ]]; then
    shrink_ext4_if_last
    truncate_image_safely "$local_img"
  else
    warn "No partitions; shrink/truncate skipped."
    losetup -d "$LOOP" || true
    if (( ${#CLEANUP[@]} > 0 )); then
      unset 'CLEANUP[${#CLEANUP[@]}-1]'
    fi
  fi
  verify_image "$local_img"
  compress_and_hash "$local_img"
  exit 0
fi

# --------------------------- Input/TUI/AUTO ---------------------
if [[ $TUI -eq 1 || ( $AUTO -eq 0 && ( -z "${SRC_DEV:-}" || -z "${OUT_IMG:-}" ) ) ]]; then
  tui
fi
if [[ $AUTO -eq 1 ]]; then
  stop_automount
  detect_src_auto
  prepare_output_auto
fi
if [[ $AUTO -eq 0 ]]; then
  if [[ ! -b "${SRC_DEV:-/dev/null}" ]]; then
    err "Missing/invalid --source"
    usage
    exit 2
  fi
  if [[ -z "${OUT_IMG:-}" ]]; then
    OUT_IMG="./pi-$(date -u +%Y%m%dT%H%M%SZ).img.zst"
  fi
fi

# Refuse destination on same physical device
OUT_DIR="$(dirname "$(readlink -f "$OUT_IMG")")"
SRC_PDEV="$(lsblk -no PKNAME "$SRC_DEV" 2>/dev/null || true)"
OUT_SRC="$(df --output=source "$OUT_DIR" 2>/dev/null | tail -n1 || true)"
if [[ -n "$SRC_PDEV" && "$OUT_SRC" == *"$SRC_PDEV"* ]]; then
  err "Destination directory is on the source device"
  exit 4
fi

# Unmount source partitions
log "Unmounting any mounted partitions on $SRC_DEV"
while read -r P; do
  if [[ -n "$P" && "$P" != "$SRC_DEV" ]]; then
    umount -f "$P" 2>/dev/null || true
  fi
done < <(lsblk -lnpo NAME "$SRC_DEV")
settle
sync

# Compute span and capture
PT_PRESENT=0
SECT_SIZE=512
LAST_END_SECT=0
RAW_BYTES=0
calc_copy_span "$SRC_DEV"
capture_device "$SRC_DEV" "$OUT_IMG"

# If no partition table on source, skip loop/shrink/truncate; just compress/hash
if [[ "$PT_PRESENT" -eq 0 ]]; then
  warn "Source had no partition table; skipping shrink and truncate."
  TMP_IMG_REAL="$TMP_IMG"
  VERIFY=0
  compress_and_hash "$TMP_IMG_REAL"
  exit 0
fi

# Attach, detect, shrink if possible, truncate, verify, compress, hash
attach_loop "$TMP_IMG"
detect_fs
if [[ "${CHILD_CT:-0}" != "0" ]]; then
  shrink_ext4_if_last
  truncate_image_safely "$TMP_IMG"
else
  warn "Image shows no partitions; skipping shrink/truncate."
  losetup -d "$LOOP" || true
  if (( ${#CLEANUP[@]} > 0 )); then
    unset 'CLEANUP[${#CLEANUP[@]}-1]'
  fi
fi
verify_image "$TMP_IMG"
compress_and_hash "$TMP_IMG"