#!/usr/bin/env bash
#Author: 4ndr0666
set -euo pipefail
set -E
# ======================== // MERGE //

## XDG Compliance

declare -x XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
declare -x XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
declare -x XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
declare -r APP_NAME="merge"
declare -r MERGE_CONF="$XDG_CONFIG_HOME/$APP_NAME/merge.conf"

mkdir -p "$XDG_CONFIG_HOME/$APP_NAME" "$XDG_CACHE_HOME/$APP_NAME" "$XDG_DATA_HOME/$APP_NAME" || {
	echo "Error: Failed to create XDG directories." >&2
	exit 1
}

declare -a TEMP_DIRS=()
declare -a TEMP_FILES=()
declare BASE_TMP_DIR

if ! BASE_TMP_DIR="$(mktemp -d -p "${TMPDIR:-/tmp}" "$APP_NAME.XXXXXXXX")"; then
	echo "Error: Could not create base temporary directory." >&2
	exit 1
fi

TEMP_DIRS+=("$BASE_TMP_DIR")
declare _CLEANUP_DONE=0

register_temp_file() {
	local file_path="$1"
	[[ -n "$file_path" ]] && TEMP_FILES+=("$file_path")
}

register_temp_dir() {
	local dir_path="$1"
	[[ -n "$dir_path" ]] && TEMP_DIRS+=("$dir_path")
}

cleanup_all() {
	# Prevent double execution
	[[ "${_CLEANUP_DONE}" -eq 1 ]] && return 0
	_CLEANUP_DONE=1

	[[ "${verbose:-0}" -eq 1 ]] && printf '[%s] Cleaning up temporary resources...\n' "$(date +%T)" >&2

	# Remove temporary files (ignore errors, silence output)
	for f in "${TEMP_FILES[@]}"; do
		if [[ -f "$f" ]]; then
			rm -f -- "$f" >/dev/null 2>&1 || true
		fi
	done

	# Remove temporary directories in reverse order (ignore errors, silence output)
	if ((${#TEMP_DIRS[@]} > 0)); then
		printf '%s\0' "${TEMP_DIRS[@]}" | sort -r -z -V | xargs -0 -r -- rm -rf >/dev/null 2>&1 || true
	fi

	[[ "${verbose:-0}" -eq 1 ]] && printf '[%s] Cleanup complete.\n' "$(date +%T)" >&2
}

trap cleanup_all EXIT INT TERM HUP

## Logging & Output

printv() {
	[[ "${verbose:-0}" -eq 1 ]] && printf '[%s] %s\n' "$(date +%T)" "$*" >&2
}

## Dependency Checking

command_exists() {
	command -v "$1" >/dev/null 2>&1
}

declare REALPATH_CMD=""

check_deps() {
	local deps missing_deps
	deps=(ffmpeg ffprobe awk bc stat)
	missing_deps=()

	# Determine the best realpath command
	if command_exists realpath; then
		REALPATH_CMD="realpath"
		printv "Using realpath command: $REALPATH_CMD"
	elif command_exists readlink; then
		local tmp_file
		# Create a temporary file to test readlink -f
		if ! tmp_file=$(mktemp -p "$BASE_TMP_DIR" "readlink_test.XXXXXXXX"); then
			echo "Error: Failed to create temporary file for readlink test." >&2
			exit 1
		fi
		# Test if readlink -f works
		if readlink -f -- "$tmp_file" >/dev/null 2>&1; then
			REALPATH_CMD="readlink -f"
			printv "Using realpath command: $REALPATH_CMD"
		else
			echo "Error: 'readlink -f' not functional." >&2
			exit 1
		fi
		# Clean up the test file
		rm -f -- "$tmp_file" >/dev/null 2>&1 || true
	else
		echo "Error: Neither 'realpath' nor 'readlink' found." >&2
		exit 1
	fi

	# Check for other required commands
	for dep in "${deps[@]}"; do
		command_exists "$dep" || missing_deps+=("$dep")
	done

	# Report missing dependencies and exit if any are found
	if ((${#missing_deps[@]} > 0)); then
		echo "Error: Required command(s) not found: ${missing_deps[*]}" >&2
		exit 1
	fi
}

## File/Path Utilities

absolute_path() {
	local path="$1"
	local abs_path
	if [[ -z "$REALPATH_CMD" ]]; then
		echo "Error: REALPATH_CMD not set. Dependency check might have failed." >&2
		return 1
	fi
	# Execute the realpath command, capturing output and checking for errors
	if ! abs_path=$("$REALPATH_CMD" -- "$path" 2>/dev/null); then
		echo "Error: Could not determine absolute path for '$path'." >&2
		return 1
	fi
	# Print the absolute path to stdout
	printf '%s\n' "$abs_path"
	return 0
}

bytes_to_human() {
	local bytes="${1:-0}"
	local human_readable
	# Use awk for floating-point calculation and formatting
	if ! human_readable=$(printf '%s' "$bytes" | awk 'BEGIN {split("B KiB MiB GiB TiB PiB EiB ZiB YiB",u);b=ARGV[1]+0;p=0;while(b>=1024&&p<8){b/=1024;p++}printf "%.2f %s\n",b,u[p+1]}' 2>/dev/null); then
		echo "Error: Awk failed during bytes conversion for '$bytes'." >&2
		printf 'N/A\n' # Print N/A on error
		return 1
	fi
	# Check if awk produced any output
	if [[ -z "$human_readable" ]]; then
		echo "Error: Could not convert bytes '$bytes' to human-readable format." >&2
		printf 'N/A\n' # Print N/A on error
		return 1
	fi
	# Print the human-readable size to stdout
	printf '%s\n' "$human_readable"
	return 0
}

portable_stat() {
	local file="$1"
	local size
	# Try GNU stat format
	if size=$(stat -c '%s' "$file" 2>/dev/null); then
		printf '%s\n' "$size"
		return 0
	fi
	# Try BSD/macOS stat format
	if size=$(stat -f '%z' "$file" 2>/dev/null); then
		printf '%s\n' "$size"
		return 0
	fi
	# If neither works, print error and return failure
	echo "Error: Could not get file size for '$file'." >&2
	return 1
}

## Input Validation

validate_resolution() {
	local res="$1"
	if ! [[ "$res" =~ ^[0-9]+x[0-9]+$ ]]; then
		echo "Error: Invalid resolution format '$res'. Expected WxH (e.g., 1920x1080)." >&2
		return 1
	fi
	return 0
}

## Validate FPS value (positive integer)

validate_fps() {
	local fps="$1"
	if ! [[ "$fps" =~ ^[0-9]+$ ]] || ((fps <= 0)); then
		echo "Error: Invalid FPS '$fps'. Expected a positive integer." >&2
		return 1
	fi
	return 0
}

## Validate numeric factor (positive float or integer)

validate_factor() {
	local factor="$1"
	local factor_float bc_result
	# Basic regex check for number format (allows optional decimal)
	if ! [[ "$factor" =~ ^[0-9]*\.?[0-9]+$ ]]; then
		echo "Error: Invalid numeric format for factor '$factor'. Expected a positive number (e.g., 2, 0.5, 1.5)." >&2
		return 1
	fi

	# Use bc to check if the value is positive
	# Format to high precision for bc comparison
	factor_float=$(printf "%.8f" "$factor")
	if ! bc_result=$(bc -l <<<"$factor_float <= 0" 2>/dev/null); then
		echo "Error: bc calculation failed during factor validation for '$factor'." >&2
		return 1
	fi
	if [[ "$bc_result" -eq 1 ]]; then
		echo "Error: Factor must be positive '$factor'." >&2
		return 1
	fi
	return 0
}

## Config Loader

load_config() {
	if [[ -f "$MERGE_CONF" ]]; then
		printv "Loading configuration from $MERGE_CONF"
		# shellcheck source=/dev/null # Source file path is dynamic
		source "$MERGE_CONF" || {
			echo "Warning: Could not source configuration file '$MERGE_CONF'." >&2
		}
	else
		printv "No configuration file found at $MERGE_CONF"
	fi
}

## Output Filename

get_default_filename() {
	local base="$1"
	local suf="$2"
	local ext="$3"
	local dir="${4:-.}" # Default directory is current directory
	local name full_path n=1

	name="${base}_${suf}.${ext}"
	full_path="$dir/$name"

	while [[ -e "$full_path" ]]; do
		name="${base}_${suf}${n}.${ext}"
		full_path="$dir/$name"
		n=$((n + 1))
	done

	if [[ -z "$full_path" ]]; then
		echo "Error: Failed to generate a unique filename for base '$base'." >&2
		return 1
	fi

	printf '%s\n' "$full_path"
	return 0
}

## File Selection

select_files() {
	local selected_output selected_array manual_input abs_f file_found_count
	selected_array=()

	if command_exists fzf; then
		printv "Using fzf for file selection..."
		local find_cmd xargs_cmd fzf_cmd
		# Find video files (mp4, mov, mkv, webm) in the current directory
		find_cmd=(find . -maxdepth 1 -type f \( -iname '.mp4' -o -iname '.mov' -o -iname '.mkv' -o -iname '.webm' \))
		# Use xargs with the determined REALPATH_CMD to get absolute paths
		xargs_cmd=(xargs -0 "$REALPATH_CMD" --)
		# Use fzf for interactive selection with preview and multi-select
		fzf_cmd=(fzf --multi --preview 'ffprobe -hide_banner -loglevel error {}' --preview-window=right:60% --bind='ctrl-a:select-all+accept' --height=40% --print0)

		# Execute the pipeline: find -> xargs (realpath) -> fzf
		# Capture null-delimited output from fzf
		if ! selected_output=$("${find_cmd[@]}" -print0 | "${xargs_cmd[@]}" 2>/dev/null | "${fzf_cmd[@]}" 2>/dev/null); then
			echo "No files selected or fzf interrupted." >&2
			return 1
		fi
		# Read null-delimited output into an array
		mapfile -d '' -t selected_array < <(printf '%s' "$selected_output")
	else
		# Fallback to manual input if fzf is not found
		echo "fzf not found. Please manually specify file paths (space-separated, quote paths with spaces):" >&2
		read -r manual_input
		if [[ -z "$manual_input" ]]; then
			echo "No files entered." >&2
			return 1
		fi
		local -a temp_array abs_selected_array
		abs_selected_array=()
		file_found_count=0
		# Read space-separated input into a temporary array (handles quoted paths)
		read -r -a temp_array <<<"$manual_input"
		# Validate each entered path
		for f in "${temp_array[@]}"; do
			if [[ -f "$f" ]]; then
				# Get absolute path and add to the result array
				if abs_f=$(absolute_path "$f"); then
					abs_selected_array+=("$abs_f")
					file_found_count=$((file_found_count + 1))
				else
					# absolute_path prints error, continue loop
					continue
				fi
			else
				echo "Error: Input file not found: '$f'" >&2
				continue
			fi
		done
		# Check if any valid files were found after manual input
		if ((file_found_count == 0)); then
			echo "Error: No valid files entered." >&2
			return 1
		fi
		selected_array=("${abs_selected_array[@]}")
	fi

	# Final check if any files were selected/validated
	if ((${#selected_array[@]} == 0)); then
		echo "No files selected." >&2
		return 1
	fi

	# Print selected absolute paths, one per line
	printf '%s\n' "${selected_array[@]}"
	return 0
}

## Video/Audio Opts

get_video_opts() {
	local codec="${1:-libx264}"
	local preset="${2:-slow}"
	local crf_val="$3" # Can be empty
	local qp_val="$4"  # Can be empty
	local -a opts=("-c:v" "$codec" "-preset" "$preset" "-pix_fmt" "yuv420p" "-movflags" "+faststart")

	if [[ -n "$qp_val" ]]; then
		opts+=("-qp" "$qp_val")
	elif [[ -n "$crf_val" ]]; then
		opts+=("-crf" "$crf_val")
	else
		opts+=("-crf" "18")
	fi

	printf '%s\0' "${opts[@]}"
	return 0
}

## Generate FFmpeg audio encoding options

get_audio_opts() {
	local remove_audio="${1:-false}"
	local -a opts=()

	# Add audio options or disable audio
	if [[ "$remove_audio" = "true" ]]; then
		opts+=("-an") # No audio
	else
		opts+=("-c:a" "aac" "-b:a" "128k") # AAC audio at 128k bitrate
	fi

	# Print options null-delimited for safe parsing into an array
	printf '%s\0' "${opts[@]}"
	return 0
}

## Filter Chain

generate_atempo_filter() {
	local target_speed="$1"
	local rem_speed="$target_speed"
	local -a atempo_parts=()
	local formatted_rem_speed bc_is_one bc_result is_in_range

	# Validate the input speed factor
	if ! validate_factor "$target_speed"; then
		return 1
	fi

	# Format speed for bc calculations
	formatted_rem_speed=$(printf "%.8f" "$rem_speed")

	# Check if speed is exactly 1.0 (no filter needed)
	if ! bc_is_one=$(bc -l <<<"$formatted_rem_speed == 1.0" 2>/dev/null); then
		echo "Error: bc calculation failed (comparison == 1.0) for speed '$target_speed'." >&2
		return 1
	fi
	if [[ "$bc_is_one" -eq 1 ]]; then
		printf '' # Return empty string if speed is 1.0
		return 0
	fi

	# Chain atempo=2.0 filters until speed is <= 2.0
	if ! bc_result=$(bc -l <<<"$formatted_rem_speed > 2.0" 2>/dev/null); then
		echo "Error: bc calculation failed (> 2.0) for speed '$target_speed'." >&2
		return 1
	fi
	while [[ "$bc_result" -eq 1 ]]; do
		atempo_parts+=(atempo=2.0)
		if ! rem_speed=$(bc -l <<<"$formatted_rem_speed / 2.0" 2>/dev/null); then
			echo "Error: bc calculation failed (division by 2.0) for speed '$target_speed'." >&2
			return 1
		fi
		formatted_rem_speed=$(printf "%.8f" "$rem_speed")
		if ! bc_result=$(bc -l <<<"$formatted_rem_speed > 2.0" 2>/dev/null); then
			echo "Error: bc calculation failed (> 2.0) in loop for speed '$target_speed'." >&2
			return 1
		fi
	done

	# Chain atempo=0.5 filters until speed is >= 0.5
	if ! bc_result=$(bc -l <<<"$formatted_rem_speed < 0.5" 2>/dev/null); then
		echo "Error: bc calculation failed (< 0.5) for speed '$target_speed'." >&2
		return 1
	fi
	while [[ "$bc_result" -eq 1 ]]; do
		atempo_parts+=(atempo=0.5)
		if ! rem_speed=$(bc -l <<<"$formatted_rem_speed / 0.5" 2>/dev/null); then
			echo "Error: bc calculation failed (division by 0.5) for speed '$target_speed'." >&2
			return 1
		fi
		formatted_rem_speed=$(printf "%.8f" "$rem_speed")
		if ! bc_result=$(bc -l <<<"$formatted_rem_speed < 0.5" 2>/dev/null); then
			echo "Error: bc calculation failed (< 0.5) in loop for speed '$target_speed'." >&2
			return 1
		fi
	done

	# Check if the remaining speed is within the valid range [0.5, 2.0]
	if ! is_in_range=$(bc -l <<<"$formatted_rem_speed >= 0.5 && $formatted_rem_speed <= 2.0" 2>/dev/null); then
		echo "Error: bc calculation failed (range check) for speed '$target_speed'." >&2
		return 1
	fi
	if [[ "$is_in_range" -eq 1 ]]; then
		# Add the final atempo filter with the remaining speed
		atempo_parts+=(atempo="$(printf "%.4f" "$rem_speed")")
	else
		echo "Error: Calculated final atempo speed '$rem_speed' is out of the expected [0.5, 2.0] range after chaining." >&2
		return 1
	fi

	# Join the filter parts with commas and print the resulting filter string
	local atempo_filter_str
	atempo_filter_str=$(
		IFS=,
		printf '%s' "${atempo_parts[*]}"
	)

	# Final check: if target speed wasn't 1.0, the filter string should not be empty
	local bc_is_not_one
	if ! bc_is_not_one=$(bc -l <<<"$formatted_rem_speed != 1.0" 2>/dev/null); then
		echo "Error: bc calculation failed (comparison != 1.0) for speed '$target_speed'." >&2
		return 1
	fi
	if [[ "$bc_is_not_one" -eq 1 && -z "$atempo_filter_str" ]]; then
		echo "Error: Generated empty atempo filter string for speed '$target_speed' (expected non-empty)." >&2
		return 1
	fi

	printf '%s' "$atempo_filter_str"
	return 0
}

## Help Message

usage() {
	local exit_status="${1:-1}" # Default exit status is 1 (error)
	cat <&2 <<EOH
Usage: ${0##*/} [global options] <subcommand> [subcommand options] [args...]

Global Options:
  -v              Verbose output
  -r WxH          Output resolution (e.g., 1280x720) - Required for process, looperang, slowmo
  -f N            Output FPS (integer) - Required for process, looperang, slowmo
  -c <codec>      Video codec (default: libx264)
  -p <preset>     Encoding preset (default: slow)
  --crf <value>   CRF value (default: 18, ignored if --qp is set)
  --qp <value>    QP value (overrides --crf)
  -a <true|false> Remove audio tracks (Default: false for process/looperang/slowmo, true for merge)
  -h, --help      Show this message

Subcommands:
  probe <file>
  process [opts] <in> [out]
  merge   [opts] [<file1> <file2> ...]
  looperang [opts] <in> [out]
  slowmo  [opts] <in> [out]

Subcommand Options:
  merge:
    -o <file>         Output file (default: determined from first input)
    --scale <mode>    Scaling mode for merge: largest, composite, 1080p (default: largest)
                      'largest': Scale all to largest input resolution (or -r if specified), padding if needed.
                      'composite': Scale all to 1280x720 (or -r if specified), padding if needed.
                      '1080p': Scale all to 1920x1080 (or -r if specified), padding if needed.
    --speed <factor>  Playback speed multiplier for merge (default: 1.0)
    --interpolate     Enable frame interpolation for smooth fps in merge (experimental)
    --output-dir <dir> Output directory for merge (default: .)
  slowmo:
    -s <factor>       Slow factor (float, e.g., 2.0 for 2x slow, 0.5 for 0.5x speed)

Configuration File:
  Options can be set in '$MERGE_CONF' (e.g., output_dir="~/Videos", codec="libvpx-vp9").
  Command-line options override config file options.
EOH
	exit "$exit_status"
}

## Subcommands

cmd_probe() {
	local in="${1:-}"
	local sz ffprobe_output probe_data width height res avg_frame_rate fps fps_val dur container

	# Validate input file argument
	if [[ -z "$in" ]]; then
		echo "Error: No input file provided for probe." >&2
		usage >&2 # Show usage on missing argument
		return 1
	fi
	if [[ ! -f "$in" ]]; then
		echo "Error: Input file not found: '$in'" >&2
		return 1
	fi

	# Get file size (optional, continue if fails)
	if ! sz=$(portable_stat "$in"); then
		echo "Warning: Could not get file size for '$in'." >&2
		sz="N/A"
	fi

	# Run ffprobe to get stream and format information
	# Select video stream 0, show specific entries, silence output except errors
	if ! ffprobe_output=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=width,height,avg_frame_rate:format=duration,format_name "$in" 2>&1); then
		echo "Error running ffprobe on '$in':" >&2
		echo "$ffprobe_output" >&2 # Print ffprobe error output
		return 1
	fi

	# Parse ffprobe output using awk
	probe_data=$(printf '%s' "$ffprobe_output" | awk '
        /^width=/ { width=$2 }
        /^height=/ { height=$2 }
        /^avg_frame_rate=/ { avg_frame_rate=$2 }
        /^duration=/ { duration=$2 }
        /^format_name=/ { split($2, a, ","); format_name=a[1] } # Take only the first format name
        END {
            printf "width=%s\n", width ? width : "N/A";
            printf "height=%s\n", height ? height : "N/A";
            printf "avg_frame_rate=%s\n", avg_frame_rate ? avg_frame_rate : "N/A";
            printf "duration=%s\n", duration ? duration : "N/A";
            printf "format_name=%s\n", format_name ? format_name : "N/A";
        }
    ')

	# Extract parsed data
	width=$(printf '%s' "$probe_data" | awk -F'=' '/^width=/ {print $2}')
	height=$(printf '%s' "$probe_data" | awk -F'=' '/^height=/ {print $2}')
	res="N/A"
	[[ "$width" != "N/A" && "$height" != "N/A" ]] && res="${width}x${height}"

	avg_frame_rate=$(printf '%s' "$probe_data" | awk -F'=' '/^avg_frame_rate=/ {print $2}')
	fps="N/A"
	# Calculate FPS as a float if avg_frame_rate is available
	if [[ "$avg_frame_rate" != "N/A" ]]; then
		if fps_val=$(bc -l <<<"$(printf "%.8f" "$avg_frame_rate")" 2>/dev/null); then
			fps=$(printf "%.2f" "$fps_val")
		fi
	fi

	dur=$(printf '%s' "$probe_data" | awk -F'=' '/^duration=/ {print $2}')
	container=$(printf '%s' "$probe_data" | awk -F'=' '/^format_name=/ {print $2}')

	# Print the probe report
	cat <<EOF
=== PROBE REPORT ===

File: '$in'
Container: ${container}
Size: $(bytes_to_human "$sz")
Resolution: ${res}
Frame Rate: ${fps}
Duration: ${dur}s
EOF
	return 0
}

cmd_process() {
	local in="${1:-}"
	local out="${2:-${in%.*}.processed.mp4}" # Default output name
	local current_res="${resolution:-}"
	local current_fps="${fps:-}"
	local current_codec="${codec:-libx264}"
	local current_preset="${preset:-slow}"
	local current_crf="${crf:-}"
	local current_qp="${qp:-}"
	local current_remove_audio="${remove_audio:-false}" # Default remove_audio is false for process
	local vopts_str aopts_str
	local -a vopts aopts ffmpeg_cmd

	# Validate input file argument
	if [[ -z "$in" ]]; then
		echo "Error: No input file provided for process." >&2
		usage >&2
		return 1
	fi
	if [[ ! -f "$in" ]]; then
		echo "Error: Input file not found: '$in'" >&2
		return 1
	fi

	# Required options for process
	if [[ -z "$current_res" ]]; then
		echo "Error: Output resolution (-r) is required for 'process' command." >&2
		usage >&2
		return 1
	fi
	if [[ -z "$current_fps" ]]; then
		echo "Error: Output FPS (-f) is required for 'process' command." >&2
		usage >&2
		return 1
	fi

	# Validate resolution and FPS format
	if ! validate_resolution "$current_res"; then return 1; fi
	if ! validate_fps "$current_fps"; then return 1; fi

	# Get video and audio options
	if ! vopts_str=$(get_video_opts "$current_codec" "$current_preset" "$current_crf" "$current_qp"); then
		echo "Error getting video options." >&2
		return 1
	fi
	if ! aopts_str=$(get_audio_opts "$current_remove_audio"); then
		echo "Error getting audio options." >&2
		return 1
	fi

	# Parse null-delimited options into arrays
	mapfile -d '' -t vopts < <(printf '%s' "$vopts_str")
	mapfile -d '' -t aopts < <(printf '%s' "$aopts_str")

	printv "Processing '$in' to '$out' (Resolution: $current_res, FPS: $current_fps)..."
	printv "Video Options: ${vopts[*]}"
	printv "Audio Options: ${aopts[*]}"

	# Build the ffmpeg command array
	ffmpeg_cmd=(ffmpeg -hide_banner -loglevel error -y -i "$in")
	# Apply scale and fps filters using -vf (simple filtergraph)
	ffmpeg_cmd+=("-vf" "scale=${current_res/x/:},fps=${current_fps}")
	ffmpeg_cmd+=("${vopts[@]}")
	ffmpeg_cmd+=("${aopts[@]}")
	ffmpeg_cmd+=("$out")

	printv "FFmpeg command: ${ffmpeg_cmd[*]}"

	# Execute the ffmpeg command
	if ! "${ffmpeg_cmd[@]}"; then
		echo "Error: ffmpeg process failed for '$in'." >&2
		return 1
	fi

	echo "✅ Processed: $out"
	return 0
}

cmd_merge() {
	local -a files abs_files video_concat_inputs audio_concat_inputs stream_filters concat_filters
	local valid_file_count num_inputs i input_file v_chain a_chain
	local current_resolution current_fps current_codec current_preset current_crf current_qp
	local current_remove_audio current_scale_mode current_speed_factor current_interpolate
	local current_output_dir current_output target_res target_fps target_res_w target_res_h
	local max_w=0 max_h=0 max_fps=0.0 ffmpeg_cmd filter_complex_str joined_video_concat_inputs joined_audio_concat_inputs
	local vopts_str aopts_str vopts aopts final_output_path base_name abs_output_dir relative_output_path output_dir_path

	# Default remove_audio is true for merge if not specified by config or command line
	: "${remove_audio:=true}"
	current_remove_audio="$remove_audio"

	# Assign options from parsed variables (or their defaults)
	files=("$@")
	current_resolution="${resolution:-}"
	current_fps="${fps:-}"
	current_codec="${codec:-libx264}"
	current_preset="${preset:-slow}"
	current_crf="${crf:-}"
	current_qp="${qp:-}"
	current_scale_mode="${scale_mode:-largest}"
	current_speed_factor="${speed_factor:-1.0}"
	current_interpolate="${interpolate:-0}"
	current_output_dir="${output_dir:-.}"
	current_output="${output:-}"

	# If no files provided as arguments, launch interactive selection
	if ((${#files[@]} == 0)); then
		printv "No files provided; launching interactive selection..."
		local selected_files_str
		if ! selected_files_str=$(select_files); then
			return 1 # select_files prints error if cancelled or no files
		fi
		# Read selected files (one per line) into the files array
		mapfile -t files < <(printf '%s' "$selected_files_str")
	fi

	# Check if at least two files are selected/provided
	if ((${#files[@]} < 2)); then
		echo "Error: Need at least two input files for merge. ${#files[@]} provided." >&2
		usage >&2
		return 1
	fi

	# Validate input files and get their absolute paths
	abs_files=()
	valid_file_count=0
	for f in "${files[@]}"; do
		local abs_f
		if [[ -f "$f" ]]; then
			if abs_f=$(absolute_path "$f"); then
				abs_files+=("$abs_f")
				valid_file_count=$((valid_file_count + 1))
			else
				# absolute_path prints error, continue loop
				continue
			fi
		else
			echo "Error: Input file not found: '$f'" >&2
			continue
		fi
	done
	# Exit if no valid files were found after validation
	if ((valid_file_count == 0)); then
		echo "Error: No valid input files found." >&2
		return 1
	fi
	files=("${abs_files[@]}") # Use the validated absolute paths
	num_inputs=${#files[@]}

	# Analyze input files to determine max resolution and FPS if needed for scaling
	printv "Analyzing input files for max resolution and FPS..."
	for inp in "${files[@]}"; do
		local ffprobe_output w h fr val bc_compare
		# Probe only video stream 0 for width, height, and frame rate
		if ! ffprobe_output=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=width,height,avg_frame_rate "$inp" 2>&1); then
			echo "Warning: Could not probe video stream of '$inp'. Skipping analysis for this file." >&2
			echo "$ffprobe_output" >&2
			continue # Continue to the next file if probing fails
		fi
		# Extract width, height, and frame rate
		w=$(printf '%s' "$ffprobe_output" | awk '/^width=/ {print $2}')
		h=$(printf '%s' "$ffprobe_output" | awk '/^height=/ {print $2}')
		# Update max width and height if current file is larger
		[[ "$w" =~ ^[0-9]+$ ]] && [[ "$h" =~ ^[0-9]+$ ]] && {
			((w > max_w)) && max_w=$w
			((h > max_h)) && max_h=$h
		}
		fr=$(printf '%s' "$ffprobe_output" | awk '/^avg_frame_rate=/ {print $2}')
		# Update max FPS if current file has higher FPS (using bc for float comparison)
		if [[ -n "$fr" ]]; then
			if ! val=$(bc -l <<<"$(printf "%.8f" "$fr")" 2>/dev/null || echo 0.0); then
				echo "Warning: bc calculation failed during FPS analysis for '$inp'." >&2
				continue
			fi
			if ! bc_compare=$(bc -l <<<"$val > $max_fps" 2>/dev/null); then
				echo "Warning: bc comparison failed during FPS analysis for '$inp'." >&2
				continue
			fi
			if [[ "$bc_compare" -eq 1 ]]; then
				max_fps="$val"
			fi
		fi
	done

	# Determine the target resolution based on options and scale mode
	target_res="${current_resolution:-}"
	if [[ -z "$target_res" ]]; then
		case "$current_scale_mode" in
		largest)
			# Use max input resolution if found, otherwise default
			if ((max_w > 0 && max_h > 0)); then
				target_res="${max_w}x${max_h}"
				printv "Target resolution not specified, using max input resolution ($current_scale_mode mode): $target_res"
			else
				target_res="1280x720"
				printv "Could not determine max input resolution, defaulting to $target_res ($current_scale_mode mode)." >&2
			fi
			;;
		composite)
			target_res="1280x720"
			printv "Target resolution not specified, defaulting to $target_res ($current_scale_mode mode)."
			;;
		1080p)
			target_res="1920x1080"
			printv "Target resolution not specified, defaulting to $target_res ($current_scale_mode mode)."
			;;
		*)
			echo "Error: Unknown scale mode '$current_scale_mode'." >&2
			return 1
			;;
		esac
	else
		# Use specified target resolution, validate format
		if ! validate_resolution "$target_res"; then
			return 1 # validate_resolution prints error
		fi
		printv "Target resolution specified: $target_res (scale mode: $current_scale_mode)"
	fi

	# Determine the target FPS based on options and max input FPS
	target_fps="${current_fps:-}"
	if [[ -z "$target_fps" ]]; then
		local bc_max_fps_gt_0
		if ! bc_max_fps_gt_0=$(bc -l <<<"$max_fps > 0" 2>/dev/null); then
			echo "Error: bc comparison failed during target FPS determination." >&2
			return 1
		fi
		# Use rounded max input FPS if found and positive, otherwise default
		if [[ "$bc_max_fps_gt_0" -eq 1 ]]; then
			target_fps=$(printf "%.0f" "$max_fps") # Round to nearest integer FPS
			printv "Target FPS not specified, using rounded max input FPS: $target_fps"
		else
			target_fps=30 # Default FPS
			printv "Could not determine max input FPS, defaulting to: $target_fps" 2>&1
		fi
	else
		# Use specified target FPS, validate format
		if ! validate_fps "$target_fps"; then
			return 1 # validate_fps prints error
		fi
		printv "Target FPS specified: $target_fps"
	fi

	# Extract width and height from target resolution
	target_res_w=$(echo "$target_res" | cut -d'x' -f1)
	target_res_h=$(echo "$target_res" | cut -d'x' -f2)

	# --- Build FFmpeg command and filter_complex graph ---
	ffmpeg_cmd=(ffmpeg -hide_banner -loglevel error -y)
	stream_filters=()      # Array to hold filters for individual input streams
	video_concat_inputs=() # Array to hold output labels for video streams before concat
	audio_concat_inputs=() # Array to hold output labels for audio streams before concat

	# Add input files and build individual stream filter chains
	for i in "${!files[@]}"; do
		input_file="${files[$i]}"
		ffmpeg_cmd+=("-i" "$input_file")

		# Video filter chain:
		# [i:v] - Select video stream from input i
		# setpts=factor*PTS - Adjust playback speed (factor > 1 slows down, < 1 speeds up)
		# scale=W:H:force_original_aspect_ratio=decrease - Scale while maintaining aspect ratio
		# pad=W:H:(ow-iw)/2:(oh-ih)/2 - Add black padding to reach target resolution, centering the video
		# minterpolate - Optional frame interpolation for smooth speed changes/FPS conversion
		# fps=N - Set the final frame rate
		# [v_i] - Label the output of this video chain
		v_chain="[${i}:v],setpts=$(printf "%.8f" "$current_speed_factor")*PTS,scale=${target_res_w}:${target_res_h}:force_original_aspect_ratio=decrease,pad=${target_res_w}:${target_res_h}:(ow-iw)/2:(oh-ih)/2"
		if [[ "$current_interpolate" -eq 1 ]]; then
			# Add minterpolate filter if interpolation is enabled
			v_chain+=",minterpolate='mi_mode=blend:fps=${target_fps}'"
		fi
		v_chain+=",fps=${target_fps}[v${i}]"
		stream_filters+=("$v_chain")
		video_concat_inputs+=("[v${i}]") # Add the output label to the video concat input list

		# Audio filter chain (if audio is not removed):
		# [i:a] - Select audio stream from input i
		# atempo=factor - Adjust audio speed (factor > 1 speeds up, < 1 slows down)
		# [a_i] - Label the output of this audio chain
		if [[ "$current_remove_audio" != "true" ]]; then
			a_chain="[${i}:a]"
			local target_audio_speed_val atempo_filter_str
			# Calculate the required audio speed factor (inverse of video speed factor)
			if ! target_audio_speed_val=$(bc -l <<<"1 / $(printf "%.8f" "$current_speed_factor")" 2>/dev/null) || [[ -z "$target_audio_speed_val" ]]; then
				echo "Error: Could not calculate target audio speed (1 / $current_speed_factor)." >&2
				return 1
			fi
			# Generate chained atempo filters if needed
			if ! atempo_filter_str=$(generate_atempo_filter "$target_audio_speed_val"); then
				return 1 # generate_atempo_filter prints error
			fi
			# Add atempo filter(s) if generated
			if [[ -n "$atempo_filter_str" ]]; then
				a_chain+=",${atempo_filter_str}"
			fi
			a_chain+="[a${i}]"
			stream_filters+=("$a_chain")
			audio_concat_inputs+=("[a${i}]") # Add the output label to the audio concat input list
		fi
	done

	# Concat filter chains:
	# [v0][v1]...[vn]concat=n=N:v=1:a=0[v_out] - Concatenate video streams
	# [a0][a1]...[an]concat=n=N:v=0:a=1[a_out] - Concatenate audio streams (if audio present)
	concat_filters=()
	joined_video_concat_inputs=$(printf '%s' "${video_concat_inputs[*]}")
	concat_filters+=("${joined_video_concat_inputs}concat=n=${num_inputs}:v=1:a=0[v_out]")
	if [[ "$current_remove_audio" != "true" ]]; then
		joined_audio_concat_inputs=$(printf '%s' "${audio_concat_inputs[*]}")
		concat_filters+=("${joined_audio_concat_inputs}concat=n=${num_inputs}:v=0:a=1[a_out]")
	fi

	# Join all filter chains with semicolons for the final filter_complex string
	filter_complex_str=$(
		IFS=';'
		printf '%s' "${stream_filters[@]}" "${concat_filters[@]}"
	)

	# Add the filter_complex argument if filters were generated
	if [[ -n "$filter_complex_str" ]]; then
		ffmpeg_cmd+=("-filter_complex" "$filter_complex_str")
	fi

	# Map the output streams from the filter_complex graph
	ffmpeg_cmd+=("-map" "[v_out]")
	if [[ "$current_remove_audio" != "true" ]]; then
		ffmpeg_cmd+=("-map" "[a_out]")
	fi

	# Get video and audio encoding options
	if ! vopts_str=$(get_video_opts "$current_codec" "$current_preset" "$current_crf" "$current_qp"); then
		echo "Error getting video options." >&2
		return 1
	fi
	if ! aopts_str=$(get_audio_opts "$current_remove_audio"); then
		echo "Error getting audio options." >&2
		return 1
	fi
	# Parse null-delimited options into arrays
	mapfile -d '' -t vopts < <(printf '%s' "$vopts_str")
	mapfile -d '' -t aopts < <(printf '%s' "$aopts_str")
	ffmpeg_cmd+=("${vopts[@]}")
	ffmpeg_cmd+=("${aopts[@]}")

	# Determine the final output file path
	if [[ -z "$current_output" ]]; then
		# Use default filename based on the first input file
		base_name=$(basename "${files[0]%.*}")
		if ! final_output_path=$(get_default_filename "$base_name" "merged" "mp4" "$current_output_dir"); then
			echo "Error determining default output filename." >&2
			return 1
		fi
	else
		# Use specified output file path, resolve absolute path
		if ! abs_output_dir=$(absolute_path "$current_output_dir"); then
			echo "Error: Could not determine absolute path for output directory '$current_output_dir'." >&2
			return 1
		fi
		relative_output_path="$abs_output_dir/$current_output"
		# Note: absolute_path on a non-existent file might fail depending on implementation.
		# Assuming it works correctly for paths including non-existent files within existing dirs.
		if ! final_output_path=$(absolute_path "$relative_output_path"); then
			echo "Error: Could not determine absolute path for output file '$relative_output_path'." >&2
			return 1
		fi
	fi

	# Create the output directory if it doesn't exist
	output_dir_path=$(dirname "$final_output_path")
	if ! mkdir -p "$output_dir_path"; then
		echo "Error: Failed to create output directory '$output_dir_path' for '$final_output_path'." >&2
		return 1
	fi

	# Add the output file path to the ffmpeg command
	ffmpeg_cmd+=("$final_output_path")

	# Print verbose information before execution
	printv "Merging files: ${files[*]}"
	printv "Target Resolution: $target_res, Target FPS: $target_fps"
	printv "Scale Mode: $current_scale_mode, Speed Factor: $current_speed_factor, Interpolate: $current_interpolate"
	printv "Remove Audio: $current_remove_audio"
	printv "Output File: $final_output_path"
	printv "FFmpeg filter_complex: $filter_complex_str"
	printv "FFmpeg command: ${ffmpeg_cmd[*]}"

	# Execute the ffmpeg command
	if ! "${ffmpeg_cmd[@]}"; then
		echo "Error: ffmpeg merge failed." >&2
		return 1
	fi

	echo "✅ Merged: $final_output_path"
	return 0
}

cmd_looperang() {
	local in="${1:-}"
	local out="${2:-${in%.*}.looperang.mp4}" # Default output name
	local current_res="${resolution:-}"
	local current_fps="${fps:-}"
	local current_codec="${codec:-libx264}"
	local current_preset="${preset:-slow}"
	local current_crf="${crf:-}"
	local current_qp="${qp:-}"
	local current_remove_audio="${remove_audio:-false}" # Default remove_audio is false for looperang
	local vopts_str aopts_str
	local -a vopts aopts ffmpeg_cmd stream_filters
	local filter_complex_str map_v map_a audio_filter_chain

	# Validate input file argument
	if [[ -z "$in" ]]; then
		echo "Error: No input file provided for looperang." >&2
		usage >&2
		return 1
	fi
	if [[ ! -f "$in" ]]; then
		echo "Error: Input file not found: '$in'" >&2
		return 1
	fi

	# Required options for looperang
	if [[ -z "$current_res" ]]; then
		echo "Error: Output resolution (-r) is required for 'looperang' command." >&2
		usage >&2
		return 1
	fi
	if [[ -z "$current_fps" ]]; then
		echo "Error: Output FPS (-f) is required for 'looperang' command." >&2
		usage >&2
		return 1
	fi

	# Validate resolution and FPS format
	if ! validate_resolution "$current_res"; then return 1; fi
	if ! validate_fps "$current_fps"; then return 1; fi

	# Get video and audio encoding options
	if ! vopts_str=$(get_video_opts "$current_codec" "$current_preset" "$current_crf" "$current_qp"); then
		echo "Error getting video options." >&2
		return 1
	fi
	if ! aopts_str=$(get_audio_opts "$current_remove_audio"); then
		echo "Error getting audio options." >&2
		return 1
	fi

	# Parse null-delimited options into arrays
	mapfile -d '' -t vopts < <(printf '%s' "$vopts_str")
	mapfile -d '' -t aopts < <(printf '%s' "$aopts_str")

	printv "Creating looperang from '$in' to '$out' (Resolution: $current_res, FPS: $current_fps)..."
	printv "Video Options: ${vopts[*]}"
	printv "Audio Options: ${aopts[*]}"

	# --- Build FFmpeg filter_complex graph ---
	stream_filters=()
	map_v="-map [v_out]"
	map_a=""

	# Video filter chain:
	# [0:v]split[f][r] - Split video stream into two copies (forward [f], reverse [r])
	# [r]reverse[r_rev] - Reverse the second copy
	# [f][r_rev]concat=n=2:v=1:a=0[v_out] - Concatenate forward and reversed copies
	stream_filters+=("[0:v]split[f][r];[r]reverse[r_rev];[f][r_rev]concat=n=2:v=1:a=0[v_out]")

	# Audio filter chain (if audio is not removed):
	# [0:a]asplit[af][ar] - Split audio stream into two copies (forward [af], reverse [ar])
	# [ar]areverse[ar_rev] - Reverse the second copy
	# [af][ar_rev]aconcat=n=2:v=0:a=1[a_out] - Concatenate forward and reversed copies
	if [[ "$current_remove_audio" != "true" ]]; then
		audio_filter_chain="[0:a]asplit[af][ar];[ar]areverse[ar_rev];[af][ar_rev]aconcat=n=2:v=0:a=1[a_out]"
		stream_filters+=("$audio_filter_chain")
		map_a="-map [a_out]" # Map the output audio stream
	fi

	# Join filter chains with semicolons
	filter_complex_str=$(
		IFS=';'
		printf '%s' "${stream_filters[@]}"
	)

	# Build the ffmpeg command array
	local -a ffmpeg_cmd=(ffmpeg -hide_banner -loglevel error -y -i "$in")
	[[ -n "$filter_complex_str" ]] && ffmpeg_cmd+=("-filter_complex" "$filter_complex_str")
	ffmpeg_cmd+=("$map_v")                      # Map the output video stream
	[[ -n "$map_a" ]] && ffmpeg_cmd+=("$map_a") # Map the output audio stream if present

	# Apply scale and fps filters using -vf (simple filtergraph, applied after filter_complex)
	# Note: Applying scale/fps after concat is simpler than applying to each stream before concat.
	ffmpeg_cmd+=("-vf" "scale=${current_res/x/:},fps=${current_fps}")

	ffmpeg_cmd+=("${vopts[@]}")
	ffmpeg_cmd+=("${aopts[@]}")
	ffmpeg_cmd+=("$out")

	printv "FFmpeg filter_complex: $filter_complex_str"
	printv "FFmpeg command: ${ffmpeg_cmd[*]}"

	# Execute the ffmpeg command
	if ! "${ffmpeg_cmd[@]}"; then
		echo "Error: ffmpeg looperang failed for '$in'." >&2
		return 1
	fi

	echo "✅ Looperang created: $out"
	return 0
}

cmd_slowmo() {
	local in="${1:-}"
	local out="${2:-${in%.*}.slowmo.mp4}" # Default output name
	local current_res="${resolution:-}"
	local current_fps="${fps:-}"
	local current_factor="${slowmo_factor:-2.0}" # Default slowmo factor is 2.0 (2x slower)
	local current_codec="${codec:-libx264}"
	local current_preset="${preset:-slow}"
	local current_crf="${crf:-}"
	local current_qp="${qp:-}"
	local current_remove_audio="${remove_audio:-false}" # Default remove_audio is false for slowmo
	local target_audio_speed_val atempo_filter_str audio_filter_chain
	local audio_filter_chain_present=0 # Flag to indicate if audio filter chain was built
	local -a ffmpeg_cmd stream_filters vopts aopts
	local filter_complex_str map_v map_a video_filter_chain vopts_str aopts_str

	# Validate input file argument
	if [[ -z "$in" ]]; then
		echo "Error: No input file provided for slowmo." >&2
		usage >&2
		return 1
	fi
	if [[ ! -f "$in" ]]; then
		echo "Error: Input file not found: '$in'" >&2
		return 1
	fi

	# Required options for slowmo
	if [[ -z "$current_res" ]]; then
		echo "Error: Output resolution (-r) is required for 'slowmo' command." >&2
		usage >&2
		return 1
	fi
	if [[ -z "$current_fps" ]]; then
		echo "Error: Output FPS (-f) is required for 'slowmo' command." >&2
		usage >&2
		return 1
	fi

	# Validate resolution, FPS, and slow factor format/value
	if ! validate_resolution "$current_res"; then return 1; fi
	if ! validate_fps "$current_fps"; then return 1; fi
	if ! validate_factor "$current_factor"; then return 1; fi

	# Calculate the required audio speed factor (inverse of video slow factor)
	# If video is 2x slower (factor=2), audio must be 2x faster (speed=0.5)
	if ! target_audio_speed_val=$(bc -l <<<"1 / $(printf "%.8f" "$current_factor")" 2>/dev/null) || [[ -z "$target_audio_speed_val" ]]; then
		echo "Error: Could not calculate target audio speed (1 / $current_factor)." >&2
		return 1
	fi

	# --- Build FFmpeg filter_complex graph ---
	stream_filters=()
	map_v="-map [v_out]"
	map_a=""

	# Video filter chain:
	# [0:v]setpts=factor*PTS - Adjust playback speed (factor > 1 slows down, < 1 speeds up)
	# scale=W:H - Scale to target resolution
	# fps=N - Set the final frame rate
	# [v_out] - Label the output video stream
	video_filter_chain="[0:v]setpts=$(printf "%.8f" "$current_factor")*PTS,scale=${current_res/x/:},fps=${current_fps}[v_out]"
	stream_filters+=("$video_filter_chain")

	# Audio filter chain (if audio is not removed):
	# [0:a]atempo=factor - Adjust audio speed
	# [a_out] - Label the output audio stream
	if [[ "$current_remove_audio" != "true" ]]; then
		# Generate chained atempo filters if needed
		if ! atempo_filter_str=$(generate_atempo_filter "$target_audio_speed_val"); then
			return 1 # generate_atempo_filter prints error
		fi
		if [[ -n "$atempo_filter_str" ]]; then
			audio_filter_chain="[0:a]${atempo_filter_str}[a_out]"
			stream_filters+=("$audio_filter_chain")
			map_a="-map [a_out]"         # Map the output audio stream
			audio_filter_chain_present=1 # Set flag
		else
			# If atempo filter string is empty (speed is 1.0), just map the original audio stream
			map_a="-map 0:a"
		fi
	fi

	# Join filter chains with semicolons
	filter_complex_str=$(
		IFS=';'
		printf '%s' "${stream_filters[@]}"
	)

	# Build the ffmpeg command array
	local -a ffmpeg_cmd=(ffmpeg -hide_banner -loglevel error -y -i "$in")
	# Add filter_complex only if filters were generated (should always be the case for slowmo video)
	[[ -n "$filter_complex_str" ]] && ffmpeg_cmd+=("-filter_complex" "$filter_complex_str")

	ffmpeg_cmd+=("$map_v")                      # Map the output video stream
	[[ -n "$map_a" ]] && ffmpeg_cmd+=("$map_a") # Map the output audio stream if present

	# Get video and audio encoding options
	if ! vopts_str=$(get_video_opts "$current_codec" "$current_preset" "$current_crf" "$current_qp"); then
		echo "Error getting video options." >&2
		return 1
	fi
	if ! aopts_str=$(get_audio_opts "$current_remove_audio"); then
		echo "Error getting audio options." >&2
		return 1
	fi
	# Parse null-delimited options into arrays
	mapfile -d '' -t vopts < <(printf '%s' "$vopts_str")
	mapfile -d '' -t aopts < <(printf '%s' "$aopts_str")
	ffmpeg_cmd+=("${vopts[@]}")
	ffmpeg_cmd+=("${aopts[@]}")
	ffmpeg_cmd+=("$out")

	# Print verbose information before execution
	printv "Creating slow-motion from '$in' to '$out' (Factor: $current_factor, Resolution: $current_res, FPS: $current_fps)..."
	printv "Video Options: ${vopts[*]}"
	# Print audio filter info only if audio is kept and filter was applied
	[[ "$current_remove_audio" != "true" && "$audio_filter_chain_present" -eq 1 ]] && printv "Audio Filter: $atempo_filter_str"
	printv "Audio Options: ${aopts[*]}"
	printv "FFmpeg filter_complex: $filter_complex_str"
	printv "FFmpeg command: ${ffmpeg_cmd[*]}"

	# Execute the ffmpeg command
	if ! "${ffmpeg_cmd[@]}"; then
		echo "Error: ffmpeg slowmo failed for '$in'." >&2
		return 1
	fi

	echo "✅ Slow-motion processed: $out"
	return 0
}

## Main Entry Point
main() {
	if [[ $# -eq 0 ]]; then
		usage 1
	fi

	declare resolution=""
	declare fps=""
	declare codec="libx264"
	declare preset="slow"
	declare crf=""
	declare qp=""
	declare remove_audio="false"
	declare scale_mode="largest"
	declare speed_factor="1.0"
	declare interpolate="0"
	declare output_dir="."
	declare slowmo_factor="2.0"
	declare verbose="0"
	declare output=""

	check_deps
	load_config

	local subcommand=""
	local -a positional_args=()
	local status=0

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-v)
			verbose=1
			shift
			;;
		-r | --resolution)
			shift
			resolution="$1"
			shift
			;;
		-f | --fps)
			shift
			fps="$1"
			shift
			;;
		-c | --codec)
			shift
			codec="$1"
			shift
			;;
		-p | --preset)
			shift
			preset="$1"
			shift
			;;
		--crf)
			shift
			crf="$1"
			shift
			;;
		--qp)
			shift
			qp="$1"
			shift
			;;
		-a | --remove-audio)
			shift
			remove_audio="$1"
			shift
			;;
		--scale)
			shift
			scale_mode="$1"
			shift
			;;
		--speed)
			shift
			speed_factor="$1"
			shift
			;;
		--interpolate)
			interpolate=1
			shift
			;;
		--output-dir)
			shift
			output_dir="$1"
			shift
			;;
		-o | --output)
			shift
			output="$1"
			shift
			;;
		-s | --slow-factor)
			shift
			slowmo_factor="$1"
			shift
			;;
		-h | --help)
			usage 0
			;;
		--)
			shift
			break
			;;
		-*)
			echo "Error: Unknown option '$1'" >&2
			usage 1
			;;
		*)
			subcommand="$1"
			shift
			positional_args=("$@")
			break
			;;
		esac
	done

	echo "DEBUG: subcommand='$subcommand'" >&2
	echo "DEBUG: positional_args=(${positional_args[*]})" >&2

	case "$subcommand" in
	probe)
		cmd_probe "${positional_args[@]}"
		status=$?
		;;
	process)
		cmd_process "${positional_args[@]}"
		status=$?
		;;
	merge)
		cmd_merge "${positional_args[@]}"
		status=$?
		;;
	looperang)
		cmd_looperang "${positional_args[@]}"
		status=$?
		;;
	slowmo)
		cmd_slowmo "${positional_args[@]}"
		status=$?
		;;
	help | -h | --help)
		usage 0
		;;
	"")
		echo "Error: No subcommand provided." >&2
		usage 1
		;;
	*)
		echo "Error: Unknown subcommand '$subcommand'." >&2
		usage 1
		;;
	esac

	exit "$status"
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
	main "$@"
fi
