
declare TMPDIR="${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}"
Use XDG_RUNTIME_DIR for shared memory if available, otherwise /dev/shm.

/dev/shm is generally preferred for large temporary files due to performance.

declare SHM="${XDG_RUNTIME_DIR:-/dev/shm}"

Check if SHM path is writable before proceeding, as hogs write here.

if [ ! -w "$SHM" ]; then
    # Fallback to TMPDIR if SHM is not writable
    INFO "/dev/shm not writable. Falling back to TMPDIR ($TMPDIR) for hog files."
    SHM="$TMPDIR"
    if [ ! -w "$SHM" ]; then
        BUG "Neither /dev/shm nor $TMPDIR is writable. Cannot proceed."
        exit 1
    fi
fi


Colors & Logging Functions


Check if tput is available and output is a terminal for colored output.

if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
	GLOW() {
		local message="$1" # Declare message as local
		printf '%s\n' "$(tput setaf 6)[✔] ${message}$(tput sgr0)"
	}
	BUG() {
		local message="$1" # Declare message as local
		printf '%s\n' "$(tput setaf 1)[✗] ${message}$(tput sgr0)"
	}
	INFO() {
		local message="$1" # Declare message as local
		printf '%s\n' "$(tput setaf 4)[→] ${message}$(tput sgr0)"
	}
else
	# Fallback to plain text output if colors are not supported.
	GLOW() { printf '[OK] %s\n' "$1"; }
	BUG() { printf '[ERR] %s\n' "$1"; }
	INFO() { printf '[..] %s\n' "$1"; }
fi

Config and File Paths


Path to the mem-police configuration file.

declare CONF="/etc/mem_police.conf"
Log file for mem-police output during the test. Uses $$ for unique PID.

declare LOG="$TMPDIR/mem-police-debug.$$.log"
File to store PIDs of spawned memory hogs. Uses $$ for unique PID.

declare PID_FILE="$TMPDIR/mempolice-hogs.$$.pids"
Path where mem-police is expected to create start files.

This path is assumed based on common daemon practices and the original script.

If mem-police uses a different path, this variable must be updated.

declare MEMPOLICE_START_DIR="/var/run/mem-police"

Sleep duration between checks in loops (seconds).

declare SLEEP_BETWEEN=1

Function to read a specific key's value from the config file.

Handles potential whitespace around the value.

read_config() {
	local key="$1" # Declare key as local
    # Use awk to find the line starting with the key, extract the value after '=',
    # remove trailing whitespace, and print it.
	awk -F'=' -v key="$key" '$1 == key { gsub(/[ \t\r\n]+$/, "", $2); print $2; exit }' "$CONF"
}

Check if the configuration file exists and is readable.

if [ ! -r "$CONF" ]; then
	BUG "Missing or unreadable config file: $CONF"
	exit 1
fi

Variables derived from Config and Calculations


Read daemon's main sleep interval from config, default to 30 if not found or empty.

declare SLEEP
SLEEP=$(read_config "SLEEP")
: "${SLEEP:=30}"

Read daemon's threshold duration from config, default to 60 if not found or empty.

declare THRESHOLD_DURATION
THRESHOLD_DURATION=$(read_config "THRESHOLD_DURATION")
: "${THRESHOLD_DURATION:=60}"

Read daemon's kill grace period from config, default to 5 if not found or empty.

declare KILL_GRACE
KILL_GRACE=$(read_config "KILL_GRACE")
: "${KILL_GRACE:=5}"

Calculate wait times for tests based on daemon configuration.

WAIT_GRACE: Time to wait for the start file to appear (daemon_sleep * 2 provides buffer).

declare WAIT_GRACE=$((SLEEP * 2))
WAIT_TOTAL: Total time to wait for hogs to be killed (daemon_sleep + threshold + kill_grace + buffer).

declare WAIT_TOTAL=$((SLEEP + THRESHOLD_DURATION + KILL_GRACE + 5))

INFO "mem-police config: SLEEP=${SLEEP}s, THRESHOLD_DURATION=${THRESHOLD_DURATION}s, KILL_GRACE=${KILL_GRACE}s"
INFO "Test wait times: WAIT_GRACE=${WAIT_GRACE}s (for startfile), WAIT_TOTAL=${WAIT_TOTAL}s (for kill)"

Cleanup Function


Function to clean up temporary files and processes.

cleanup() {
	INFO "Running cleanup..."

	# Check if TAIL_PID is set and the process exists before attempting to kill.
	# Use ${TAIL_PID:-} to safely check if the variable is set and not empty.
	if [ -n "${TAIL_PID:-}" ] && kill -0 "$TAIL_PID" 2>/dev/null; then
		INFO "Stopping log tail (PID ${TAIL_PID})..."
		# Attempt to kill the tail process, ignore errors if it's already gone.
		kill "$TAIL_PID" 2>/dev/null || true
	fi

	# Check if the PID file exists before trying to read from it.
	if [ -f "$PID_FILE" ]; then
		INFO "Killing hog processes listed in ${PID_FILE}..."
		# Read PIDs line by line from the PID file.
		while read -r pid; do
			# Check if pid is non-empty and the process exists using kill -0.
			if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
				INFO "Killing PID $pid..."
				# Attempt to kill the hog process, ignore errors if it's already gone.
				kill "$pid" 2>/dev/null || true
			fi
		done <"$PID_FILE" # Redirect PID_FILE as input to the while loop.
	fi

	INFO "Removing temporary files..."
    # Remove specific temporary files created by the script.
    # Use -f to ignore errors if files don't exist. Use 2>/dev/null to suppress error messages.
	rm -f "$MEMPOLICE_START_DIR"/mempolice-.start "$SHM"/hog."$$". "$TMPDIR"/hog."$$".* "$PID_FILE" "$LOG" 2>/dev/null || true
	GLOW "Cleanup complete."
}

Set traps to run the cleanup function on script exit, interrupt (Ctrl+C), or terminate signal.

trap cleanup EXIT INT TERM

Start mem-police if not running


INFO "Checking if mem-police is running..."
Check for a running process named 'mem-police'.

if ! pgrep -x mem-police >/dev/null 2>&1; then
	INFO "mem-police not found. Starting mem-police..."
	# Start mem-police in the background, redirecting stdout and stderr to the log file.
	mem-police >"$LOG" 2>&1 &
	declare mem_police_pid=$! # Capture the PID of the background process.
	sleep 2 # Give the daemon a moment to start up.
	# Verify if the daemon process is still running.
	if kill -0 "$mem_police_pid" 2>/dev/null; then
		GLOW "mem-police launched (PID ${mem_police_pid}, logs → $LOG)"
	else
		BUG "Failed to start mem-police. Check logs at $LOG."
		exit 1 # Exit if the daemon failed to start.
	fi
else
	# Report if mem-police was already running.
	INFO "mem-police already running (PID $(pgrep -x mem-police))"
fi

Tail Log File


INFO "Tailing log ($LOG)..."
Ensure the log file exists before tailing it.

touch "$LOG"
Start tailing the log file from the beginning, following it.

tail -n0 -f "$LOG" &
declare TAIL_PID=$! # Capture the PID of the tail process.
sleep 1 # Give tail a moment to start.

Hog Sizes


Get hog sizes from command line arguments. If none provided, default to 800 MB.

declare -a HOG_SIZES_ARRAY=("$@") # Use an array to handle arguments safely.
if [ ${#HOG_SIZES_ARRAY[@]} -eq 0 ]; then
	HOG_SIZES_ARRAY=(800) # Default size if no arguments are given.
fi

INFO "Requested hog sizes (MB): ${HOG_SIZES_ARRAY[*]}"
declare NUM_HOGS=0 # Counter for successfully spawned hogs.

Spawn Memory Hogs


Iterate through the requested hog sizes.

for mb in "${HOG_SIZES_ARRAY[@]}"; do
	# Validate the hog size: must be a positive integer.
	if ! [[ "$mb" =~ ^[1-9][0-9]*$ ]]; then
		BUG "Invalid hog size: '$mb' (must be a positive integer > 0)"
		continue # Skip this invalid size and proceed to the next.
	fi

	# Construct the output file path for the hog.
	declare OUTFILE="$SHM/hog.$$.$mb.mem"
	# Calculate the number of bytes to allocate.
	declare bytes=$((mb  1024  1024))

	INFO "Spawning hog ${mb} MB ($bytes bytes) into $OUTFILE..."
	# Spawn the memory hog process in the background.
	# head -c creates a file of the specified size.
	# exec replaces the current shell process with head.
	(exec head -c "$bytes" </dev/zero >"$OUTFILE") &
	declare hogpid=$! # Capture the PID of the spawned hog process.

	# Check if the hog process was successfully spawned and is running.
	if kill -0 "$hogpid" 2>/dev/null; then
		echo "$hogpid" >>"$PID_FILE" # Record the PID in the PID file for cleanup and testing.
		NUM_HOGS=$((NUM_HOGS + 1))   # Increment the counter for successfully spawned hogs.
		INFO "Spawned hog ${mb} MB (PID $hogpid, OUTFILE $OUTFILE)"
	else
		BUG "Failed to spawn hog ${mb} MB."
		# Clean up the potentially created partial file if spawning failed.
		rm -f "$OUTFILE" 2>/dev/null || true
	fi

	# Add a small delay between spawning hogs if multiple were requested.
	# This prevents overwhelming the system or daemon immediately.
	if [ "${#HOG_SIZES_ARRAY[@]}" -gt 1 ] && [ "$NUM_HOGS" -gt 0 ] && [ "$NUM_HOGS" -lt "${#HOG_SIZES_ARRAY[@]}" ]; then
		sleep "$SLEEP_BETWEEN"
	fi

done

Check if any hogs were successfully spawned. Exit if not.

if [ "$NUM_HOGS" -eq 0 ]; then
	BUG "No valid hog sizes provided or successfully spawned. Exiting."
    # Output TAP plan indicating zero tests run.
	echo "1..0"
	exit 0
fi

TAP Test Plan


Calculate the total number of tests: 2 tests per successfully spawned hog (start file + kill).

declare TOTAL_TESTS=$((NUM_HOGS * 2))
Output the TAP plan header.

echo "1..$TOTAL_TESTS"
declare COUNTER=1 # Initialize TAP test counter.

Test 1: Check for mem-police start files


INFO "Checking for mem-police start files..."
Read the PIDs of the spawned hogs from the PID file.

while read -r pid; do
    # Construct the expected path for the start file for this PID.
	declare START="$MEMPOLICE_START_DIR/mempolice-${pid}.start"
	declare elapsed=0 # Time elapsed waiting for the file.
	declare found=0   # Flag to indicate if the file was found (0=not found, 1=found).

	INFO "Waiting for startfile $START for PID $pid (timeout ${WAIT_GRACE}s)..."
	# Loop to wait for the start file to appear, with a timeout.
	while [ "$elapsed" -lt "$WAIT_GRACE" ]; do
		if [ -f "$START" ]; then
			found=1 # File found, set flag.
			break   # Exit the wait loop.
		fi
		sleep "$SLEEP_BETWEEN"               # Wait a bit before checking again.
		elapsed=$((elapsed + SLEEP_BETWEEN)) # Increment elapsed time.
	done

    # Output TAP result based on whether the start file was found.
	if [ "$found" -eq 1 ]; then
		echo "ok $COUNTER - startfile for PID $pid created"
	else
		echo "not ok $COUNTER - startfile for PID $pid missing after ${WAIT_GRACE}s"
		BUG "Startfile $START for PID $pid was not created within ${WAIT_GRACE}s."
	fi
	COUNTER=$((COUNTER + 1)) # Increment TAP counter for the next test.
done <"$PID_FILE"         # Read PIDs from the file.

Test 2: Wait for mem-police to kill hogs


INFO "Waiting ${WAIT_TOTAL}s for hogs to be killed by mem-police..."
Wait for the total expected time for the daemon to detect and kill the hogs.

sleep "$WAIT_TOTAL"

Test 3: Check if hogs were killed


INFO "Checking if hogs were killed..."
Read the PIDs of the spawned hogs from the PID file again.

while read -r pid; do
    # Check if the process with this PID is still running using kill -0.
	if kill -0 "$pid" 2>/dev/null; then
		# Output TAP result indicating the hog was NOT killed.
		echo "not ok $COUNTER - PID $pid still alive after ${WAIT_TOTAL}s"
		BUG "PID $pid still alive. mem-police may not have killed it."
		INFO "Attempting to kill PID $pid for cleanup..."
		# Attempt to kill the process manually for cleanup, ignore errors.
		kill "$pid" 2>/dev/null || true
	else
		# Output TAP result indicating the hog WAS killed.
		echo "ok $COUNTER - PID $pid was killed"
		GLOW "PID $pid was killed as expected."
	fi
	COUNTER=$((COUNTER + 1)) # Increment TAP counter for the next test.
done <"$PID_FILE"         # Read PIDs from the file.

Test Completion


GLOW "Test run complete."
Exit successfully. The TAP output indicates the test results.

exit 0
