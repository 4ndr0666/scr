#!/usr/bin/python3

import os
import subprocess
import json
import logging
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Dict, Any

# Configure logging
#logging.basicConfig(
#    filename='video_processing.log',
#    level=logging.INFO,
#    format='%(asctime)s [%(levelname)s] %(message)s'
#)

# Global Constants
SUPPORTED_CODECS = ['avc', 'h264', 'hev1', 'h265', 'hevc']
DEFAULT_CODEC = 'libx264'
DEFAULT_AUDIO_CODEC = 'aac'

class VideoFile:
    """Represents a video file and its properties."""

    def __init__(self, filepath: str):
        self.filepath = filepath
        self.basename = os.path.basename(filepath)
        self.width = 0
        self.height = 0
        self.frame_rate = 0.0
        self.codec = ''
        self.audio_codec = ''
        self._get_properties()

    def _get_properties(self):
        """Extract properties using MediaInfo."""
        try:
            command = ['mediainfo', '--Output=JSON', self.filepath]
            result = subprocess.run(command, capture_output=True, text=True, check=True)
            data = json.loads(result.stdout)
            for track in data['media']['track']:
                if track['@type'] == 'Video':
                    self.width = int(track.get('Width', 0))
                    self.height = int(track.get('Height', 0))
                    self.codec = track.get('CodecID', '')
                    self.frame_rate = float(track.get('FrameRate', 0.0))
                elif track['@type'] == 'Audio':
                    self.audio_codec = track.get('CodecID', '')
            if not self.width or not self.height or not self.frame_rate:
                raise ValueError("Invalid video properties obtained")
            logging.info(f"Properties for {self.filepath}: {self.width}x{self.height}, {self.frame_rate}fps, codec={self.codec}")
        except Exception as e:
            logging.error(f"Error getting properties for {self.filepath}: {e}")
            raise

class VideoProcessor:
    """Processes video files based on user commands."""

    def __init__(self):
        self.user_actions = []
        self.executor = ThreadPoolExecutor(max_workers=os.cpu_count())

    def analyze_video(self, video: VideoFile):
        """Analyze a video file using MediaInfo."""
        logging.info(f"Analyzing video {video.filepath}")
        try:
            command = ['mediainfo', video.filepath]
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError as e:
            logging.error(f"Error analyzing video {video.filepath}: {e}")
            print_warning(f"Error analyzing video {video.basename}")

    def normalize_videos(self, videos: List[VideoFile]):
        """Normalize videos to common properties."""
        logging.info("Starting normalization of videos")
        target_props = self.determine_common_properties(videos)
        normalized_files = []

        futures = []
        for video in videos:
            futures.append(self.executor.submit(self._normalize_video, video, target_props))

        for future in futures:
            result = future.result()
            if result:
                normalized_files.append(result)

        return normalized_files

    def _normalize_video(self, video: VideoFile, target_props: Dict[str, Any]):
        """Normalize a single video."""
        output_file = f"normalized_{video.basename}"
        need_reencode = (
            (video.width, video.height) != target_props['resolution'] or
            abs(video.frame_rate - target_props['frame_rate']) > 0.1 or
            video.codec.lower() not in SUPPORTED_CODECS
        )
        try:
            if not need_reencode:
                logging.info(f"{video.basename} matches target properties, copying streams")
                command = [
                    'ffmpeg', '-i', video.filepath, '-c:v', 'copy', '-c:a', 'copy', output_file
                ]
            else:
                logging.info(f"Re-encoding {video.basename} to match target properties")
                width, height = target_props['resolution']
                command = [
                    'ffmpeg', '-i', video.filepath,
                    '-vf', f"scale={width}:{height},fps={target_props['frame_rate']}",
                    '-c:v', DEFAULT_CODEC, '-preset', 'fast', '-crf', '23',
                    '-c:a', DEFAULT_AUDIO_CODEC, '-b:a', '128k', output_file
                ]
            subprocess.run(command, check=True)
            logging.info(f"Normalization complete for {video.basename}")
            return output_file
        except subprocess.CalledProcessError as e:
            logging.error(f"Error normalizing video {video.basename}: {e}")
            print_warning(f"Error normalizing video {video.basename}")
            return None

    def determine_common_properties(self, videos: List[VideoFile]) -> Dict[str, Any]:
        """Determine common properties among videos."""
        logging.info("Determining common properties for normalization")
        resolutions = {}
        frame_rates = {}
        for video in videos:
            res = (video.width, video.height)
            resolutions[res] = resolutions.get(res, 0) + 1
            frame_rates[video.frame_rate] = frame_rates.get(video.frame_rate, 0) + 1
        target_resolution = max(resolutions, key=resolutions.get)
        target_frame_rate = max(frame_rates, key=frame_rates.get)
        logging.info(f"Target resolution: {target_resolution}, frame rate: {target_frame_rate}")
        return {'resolution': target_resolution, 'frame_rate': target_frame_rate}

    # Other methods (concatenate_videos, extract_audio, etc.) would be implemented similarly...

class UserInterface:
    """Handles user interactions."""

    def __init__(self):
        self.processor = VideoProcessor()

    def main_menu(self):
        """Display the main menu and handle user selection."""
        while True:
            self.print_header("VIDEO PROCESSING TOOL")
            menu_options = [
                "1. Analyze video with MediaInfo",
                "2. Normalize videos",
                "3. Concatenate videos",
                "4. Extract audio from video",
                "5. Transcode video",
                "6. Compress video",
                "7. Handle metadata",
                "8. Detect video issues",
                "9. Exit"
            ]
            for option in menu_options:
                print(f"  {option}")
            choice = input("\nSelect an option (or '-h' for help): ")
            try:
                if choice == '1':
                    video = self.select_single_video()
                    if video:
                        self.processor.analyze_video(video)
                elif choice == '2':
                    videos = self.select_multiple_videos()
                    if videos:
                        self.processor.normalize_videos(videos)
                # Implement other choices similarly...
                elif choice == '9':
                    print_status("Exiting program. Goodbye!", "OK")
                    break
                elif choice == '-h':
                    self.print_help()
                else:
                    print_warning(f"Unrecognized option: {choice}")
            except Exception as e:
                logging.error(f"Error in main menu: {e}")
                print_warning(f"An error occurred: {e}")

    def select_single_video(self) -> VideoFile:
        """Select a single video file."""
        files = self.use_fzf_to_select_files()
        if files:
            return VideoFile(files[0])
        return None

    def select_multiple_videos(self) -> List[VideoFile]:
        """Select multiple video files."""
        files = self.use_fzf_to_select_files(multiple=True)
        return [VideoFile(f) for f in files] if files else []

    @staticmethod
    def use_fzf_to_select_files(multiple=False) -> List[str]:
        """Use fzf to select files."""
        fzf_command = ['fzf']
        if multiple:
            fzf_command.append('--multi')
        result = subprocess.run(fzf_command, capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip().split('\n')
        else:
            print_warning("No files selected or error with fzf.")
            return []

    @staticmethod
    def print_header(title: str):
        """Print a header."""
        print("\n" + "="*50)
        print(f"{title.center(50)}")
        print("="*50 + "\n")

    @staticmethod
    def print_help():
        """Display help information."""
        help_message = """
    Available Commands:
    1. Analyze video with MediaInfo
    2. Normalize videos
    3. Concatenate videos
    4. Extract audio from video
    5. Transcode video
    6. Compress video
    7. Handle metadata
    8. Detect video issues
    9. Exit
    
    Instructions:
    - Use the number keys to select an option.
    - Use '-h' to display this help message.
    """
        print(help_message)

# Utility functions for printing messages
def print_warning(message: str):
    """Print a warning message."""
    print(f"⚠️  {message}")

def print_status(message: str, status: str = "OK"):
    """Print a status message."""
    status_symbol = "✓" if status == "OK" else "✗"
    print(f"{message} [{status_symbol}]\n")

# Entry point
if __name__ == "__main__":
    ui = UserInterface()
    ui.main_menu()
