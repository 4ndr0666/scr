#!/usr/bin/env bash
# Author: 4ndr0666
# Final Synthesis by: Ψ-Anarch
set -euo pipefail
# ================== // FFX-VIDLINE v5 (Synthesis) //
## Description: A dual-mode CLI tool and interactive menu to apply
#              ffmpeg filters and operations.
# ---------------------------------------

## Colors
GREEN='\033[0;32m' CYAN='\033[36m' RED='\033[0;31m' RESET='\033[0m'

## Logging
LOGDIR="${XDG_DATA_HOME:-$HOME/.local/share}/vidline"
mkdir -p -- "$LOGDIR"
LOGFILE="$LOGDIR/ffmpeg_operations.log"

## Globals
DRY_RUN=0
INPUT_FILE=""
# Command construction arrays & variables
pre_input_opts=()
post_input_opts=()
filters=()
complex_filter_chain=""
# Encoding params
vcodec="libx264"
acodec="copy"
preset="medium"
rate_control_mode="crf"
crf=23
bitrate=""
two_pass=0
output_format="mp4"
# Special handling flags
stabilize=0
stab_params="shakiness=10:accuracy=15"
stab_smoothing=30
fade_params=""

## TRAP
error_exit() {
  local ts; ts="$(date '+%F %T')"
  printf '%b[%s] ERROR: %s%b\n' "$RED" "$ts" "$1" "$RESET" | tee -a "$LOGFILE" >&2
  exit 1
}
trap 'error_exit "Unexpected script failure near line ${LINENO}"' ERR

## Dependencies
check_deps() {
  printf '%bChecking dependencies...%b\n' "$CYAN" "$RESET"
  # RESTORED: fzf is required for the interactive menu's file picker.
  for cmd in ffmpeg ffprobe bc fzf; do
    command -v "$cmd" &>/dev/null || error_exit "Dependency missing: '$cmd'"
  done
  printf '%bDependencies OK.%b\n' "$GREEN" "$RESET"
}

unique_output_name() {
  local dir=$1 base=$2 ext=$3 counter=1 cand
  cand="$dir/${base}.$ext"
  while [[ -e $cand ]]; do
    cand="$dir/${base}_${counter}.$ext"
    ((counter++))
  done
  printf '%s\n' "$cand"
}

# RESTORED: Function to interactively choose a file.
choose_file() {
  printf '%bSelect input video:%b\n' "$CYAN" "$RESET" >&2
  local f; f="$(fzf)" || return 1
  [[ -f $f ]] || error_exit "Invalid selection: '$f'"
  printf '%s\n' "$f"
}

display_help() {
  cat <<EOF
Usage: ${0##*/} [options] [/path/to/inputfile]

A dual-mode tool to apply ffmpeg filters and operations.
Run without arguments to launch the interactive menu.
If using command-line flags, the input file should be the last argument.

VIDEO FILTERS & OPERATIONS:
  --fps <int>, --scale <p>, --pad <WxH>, --fade <in:out>, --drawtext "..."
  --deflicker, --deinterlace, --denoise, --deband <p>, --sharpen, --deshake
  --edge-detect, --reverse, --ping-pong, --color-enhance, --tonemap-sdr, --stabilize

SPEED & TIME:
  --slo-mo <f>, --speed-up <f>, --cut <start> <end>, --loop <count>

ENCODING & FORMAT:
  --convert <fmt>, --quality <hq|lossless>, --crf <int>, --bitrate <rate>
  --two-pass, --preset <name>, --vcodec <c>, --acodec <c>, --no-audio

METADATA & EXTRACTION:
  --title <"string">, --extract-frame <time>, --extract-thumbs <r> <t>, --extract-mosaic <sc>
EOF
}

# ── Command Runners ────────────────────────────────────────────────────────
run_ffmpeg() {
    # This function is identical to the pure CLI version.
    # It constructs and runs the final ffmpeg command.
    local infile=$1 outfile=$2 pass_opts=()
    local -a cmd filter_args
    cmd=(ffmpeg "${pre_input_opts[@]}" -y -i "$infile")

    if [[ -n $complex_filter_chain ]]; then
        local full_filter_chain="$complex_filter_chain"
        if ((${#filters[@]})); then
        local IFS=,
        full_filter_chain="${full_filter_chain},${filters[*]}"
        fi
        filter_args=(-filter_complex "$full_filter_chain")
    elif ((${#filters[@]})); then
        local IFS=,
        filter_args=(-vf "${filters[*]}")
    fi
    [[ -n "${filter_args:-}" ]] && cmd+=("${filter_args[@]}")

    cmd+=(-c:v "$vcodec" -preset "$preset")
    if [[ "$rate_control_mode" == "bitrate" ]]; then
        cmd+=(-b:v "$bitrate")
        [[ $# -ge 3 ]] && cmd+=("$3")
    else
        cmd+=(-crf "$crf")
    fi
    cmd+=(-c:a "$acodec")
    cmd+=("${post_input_opts[@]}")
    cmd+=(-progress pipe:1 "$outfile")

    if ((DRY_RUN)); then
        printf '%bDRY-RUN:%b %q\n' "$CYAN" "$RESET" "${cmd[@]}"
        return 0
    fi

    printf '%bRunning ffmpeg...%b\n' "$CYAN" "$RESET"
    "${cmd[@]}" 2>&1 | tee -a "$LOGFILE"
    local rv=${PIPESTATUS[0]}
    ((rv == 0)) || error_exit "ffmpeg failed (status $rv), see $LOGFILE"
    printf '%bffmpeg completed successfully.%b\n' "$GREEN" "$RESET"
}

run_stabilization_pass() {
  local infile=$1
  local trf_file; trf_file=$(mktemp)-transforms.trf
  printf '%bRunning stabilization pass 1 (detection)...%b\n' "$CYAN" "$RESET"
  local -a detect_cmd=(ffmpeg -y -i "$infile" -vf "vidstabdetect=${stab_params}:result=${trf_file}" -f null -)

  if ((DRY_RUN)); then
    printf '%bDRY-RUN:%b %q\n' "$CYAN" "$RESET" "${detect_cmd[@]}"
    touch "$trf_file"
  else
    "${detect_cmd[@]}" 2>&1 | tee -a "$LOGFILE"
    local rv=${PIPESTATUS[0]}
    ((rv == 0)) || error_exit "vidstabdetect failed (status $rv), see $LOGFILE"
  fi
  filters+=("vidstabtransform=smoothing=${stab_smoothing}:input=${trf_file}")
  trap 'rm -f -- "$trf_file"' EXIT
}

# ── CLI parser ─────────────────────────────────────────────────────────────
parse_args() {
  while (($#)); do
    case $1 in
      -h|--help) display_help; exit 0 ;;
      --dry-run) DRY_RUN=1 ;;
      # Filters
      --fps)           [ $# -lt 2 ] && error_exit "--fps <int>"; filters+=("fps=$2"); shift ;;
      --scale)         [ $# -lt 2 ] && error_exit "--scale <params>"; filters+=("scale=$2"); shift ;;
      --pad)           [ $# -lt 2 ] && error_exit "--pad <WxH>"; filters+=("pad=$2:(ow-iw)/2:(oh-ih)/2"); shift ;;
      --fade)          [ $# -lt 2 ] && error_exit "--fade <in:out>"; fade_params=$2; shift ;;
      --drawtext)      [ $# -lt 2 ] && error_exit "--drawtext <string>"; filters+=("drawtext=$2"); shift ;;
      --deflicker)     filters+=("deflicker") ;;
      --deinterlace)   filters+=("yadif") ;;
      --denoise)       filters+=("hqdn3d,deblock") ;;
      --deband)        [ $# -lt 2 ] && error_exit "--deband <params>"; filters+=("deband=$2"); shift ;;
      --sharpen)       filters+=("unsharp") ;;
      --deshake)       filters+=("deshake") ;;
      --edge-detect)   filters+=("edgedetect") ;;
      --reverse)       filters+=("reverse") ;;
      --ping-pong)     complex_filter_chain="[0:v]reverse[r];[0:v][r]concat=n=2:v=1"; post_input_opts+=(-map "[v]") ;;
      --color-enhance) filters+=("eq=brightness=0.05:contrast=1.1:saturation=1.1,colorbalance=rs=-0.05:bs=0.05") ;;
      --tonemap-sdr)   filters+=("zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=tonemap=hable,zscale=t=bt709:m=bt709:r=tv,format=yuv420p") ;;
      --stabilize)     stabilize=1 ;;
      # Speed & Time
      --slo-mo)
        [ $# -lt 2 ] && error_exit "--slo-mo <factor>"; (( $(bc -l <<<"$2 <= 1") )) && error_exit "--slo-mo factor must be > 1"
        filters+=("setpts=$2*PTS"); shift ;;
      --speed-up)
        [ $# -lt 2 ] && error_exit "--speed-up <factor>"; (( $(bc -l <<<"$2 <= 1") )) && error_exit "--speed-up factor must be > 1"
        filters+=("setpts=$(bc -l <<<"1/$2")*PTS"); shift ;;
      --cut)
        [ $# -lt 3 ] && error_exit "--cut <start_time> <end_time>"; pre_input_opts+=(-ss "$2"); post_input_opts+=(-to "$3"); shift 2 ;;
      --loop)
        [ $# -lt 2 ] && error_exit "--loop <count>"; pre_input_opts+=(-stream_loop "$2"); shift ;;
      # Encoding & Format
      --convert) [ $# -lt 2 ] && error_exit "--convert <fmt>"; output_format=$2; shift ;;
      --quality)
        [ $# -lt 2 ] && error_exit "--quality <hq|lossless>"; case $2 in hq) crf=18; preset="slow" ;; lossless) crf=0 ;; *) error_exit "Unknown quality: $2" ;; esac; shift ;;
      --crf)      [ $# -lt 2 ] && error_exit "--crf <int>"; rate_control_mode="crf"; crf=$2; shift ;;
      --bitrate)  [ $# -lt 2 ] && error_exit "--bitrate <rate>"; rate_control_mode="bitrate"; bitrate=$2; shift ;;
      --two-pass) two_pass=1 ;;
      --preset)   [ $# -lt 2 ] && error_exit "--preset <name>"; preset=$2; shift ;;
      --vcodec)   [ $# -lt 2 ] && error_exit "--vcodec <codec>"; vcodec=$2; shift ;;
      --acodec)   [ $# -lt 2 ] && error_exit "--acodec <codec>"; acodec=$2; shift ;;
      --no-audio) acodec=""; post_input_opts+=(-an) ;;
      # Metadata
      --title) [ $# -lt 2 ] && error_exit "--title <string>"; post_input_opts+=(-metadata "title=$2"); shift ;;
      --*) error_exit "Unknown option $1" ;;
      *)
        if [[ -z $INPUT_FILE ]]; then INPUT_FILE=$1
        else error_exit "Multiple input files specified."; fi ;;
    esac
    shift
  done
}

# RESTORED: The interactive command forge.
show_menu() {
  local choice v p c s f d t r out=()
  {
    printf '%b--- INTERACTIVE COMMAND BUILDER (d=done, q=quit) ---%b\n' "$CYAN" "$RESET"
    printf '%b--- Filters ---%b\n' "$GREEN" "$RESET"
    printf ' 1) FPS            2) Scale        3) Pad           4) Fade In/Out\n'
    printf ' 5) Draw Text      6) Deflicker    7) Deinterlace   8) Denoise\n'
    printf ' 9) Deband         10) Sharpen     11) Deshake      12) Edge Detect\n'
    printf ' 13) Reverse       14) Ping-Pong   15) Color Enhance 16) Tonemap HDR->SDR\n'
    printf ' 17) Stabilize\n'
    printf '%b--- Speed & Time ---%b\n' "$GREEN" "$RESET"
    printf ' 18) Slow Motion   19) Speed Up    20) Cut / Trim   21) Loop\n'
    printf '%b--- Encoding & Format ---%b\n' "$GREEN" "$RESET"
    printf ' 22) Convert Fmt   23) Quality Preset 24) Set CRF    25) Set Bitrate\n'
    printf ' 26) Enable 2-Pass 27) Set x264 Preset 28) Video Codec 29) Audio Codec\n'
    printf ' 30) No Audio\n'
    printf '%b--- Metadata ---%b\n' "$GREEN" "$RESET"
    printf ' 31) Set Title\n'
  } >&2

  while true; do
    read -r -p "Choice: " choice
    case $choice in
      d) break ;;
      q) exit 1 ;;
      1) read -rp "FPS value: " v; [[ $v =~ ^[0-9]+$ ]] && out+=(--fps "$v") || printf '%bInvalid%b\n' "$RED" "$RESET" >&2 ;;
      2) read -rp "Scale params (e.g. w=-2:h=720): " p; [[ -n $p ]] && out+=(--scale "$p") ;;
      3) read -rp "Pad to WxH (e.g. 1920x1080): " p; [[ -n $p ]] && out+=(--pad "$p") ;;
      4) read -rp "Fade In:Out duration (e.g. 2:3): " p; [[ -n $p ]] && out+=(--fade "$p") ;;
      5) read -rp "Drawtext string: " p; [[ -n $p ]] && out+=(--drawtext "$p") ;;
      6) out+=(--deflicker) ;;
      7) out+=(--deinterlace) ;;
      8) out+=(--denoise) ;;
      9) read -rp "Deband params: " p; [[ -n $p ]] && out+=(--deband "$p") ;;
      10) out+=(--sharpen) ;;
      11) out+=(--deshake) ;;
      12) out+=(--edge-detect) ;;
      13) out+=(--reverse) ;;
      14) out+=(--ping-pong) ;;
      15) out+=(--color-enhance) ;;
      16) out+=(--tonemap-sdr) ;;
      17) out+=(--stabilize) ;;
      18) read -rp "Slow-mo factor (>1): " f; [[ $f =~ ^[0-9.]+$ ]] && (( $(bc <<< "$f > 1") )) && out+=(--slo-mo "$f") || printf '%bInvalid%b\n' "$RED" "$RESET" >&2 ;;
      19) read -rp "Speed-up factor (>1): " f; [[ $f =~ ^[0-9.]+$ ]] && (( $(bc <<< "$f > 1") )) && out+=(--speed-up "$f") || printf '%bInvalid%b\n' "$RED" "$RESET" >&2 ;;
      20) read -rp "Start time: " s; read -rp "End time: " e; [[ -n $s && -n $e ]] && out+=(--cut "$s" "$e") ;;
      21) read -rp "Loop count (-1 for infinite): " c; out+=(--loop "$c") ;;
      22) read -rp "New format (e.g. mkv): " f; [[ $f =~ ^[A-Za-z0-9]+$ ]] && out+=(--convert "$f") ;;
      23) read -rp "Quality (hq|lossless): " q; case $q in hq|lossless) out+=(--quality "$q") ;; *) printf '%bInvalid%b\n' "$RED" "$RESET" >&2 ;; esac ;;
      24) read -rp "CRF value: " c; [[ $c =~ ^[0-9]+$ ]] && out+=(--crf "$c") ;;
      25) read -rp "Bitrate (e.g. 8M, 2500K): " r; [[ -n $r ]] && out+=(--bitrate "$r") ;;
      26) out+=(--two-pass) ;;
      27) read -rp "x264 preset: " p; out+=(--preset "$p") ;;
      28) read -rp "Video codec: " c; out+=(--vcodec "$c") ;;
      29) read -rp "Audio codec: " c; out+=(--acodec "$c") ;;
      30) out+=(--no-audio) ;;
      31) read -rp "Title: " t; [[ -n $t ]] && out+=(--title "$t") ;;
      *)  printf '%bUnknown choice%b\n' "$RED" "$RESET" >&2 ;;
    esac
    printf '%bOperation added.%b\n' "$GREEN" "$RESET" >&2
  done
  printf '%s\n' "${out[@]}"
}


# ── Main ───────────────────────────────────────────────────────────────────
main() {
  check_deps

  # RESTORED: Dual-mode execution logic.
  # If arguments are passed, parse them directly.
  # Otherwise, launch the interactive menu to build the arguments.
  if (($# > 0)); then
    parse_args "$@"
  else
    mapfile -t menu_args < <(show_menu) || {
      printf '%bExiting at user request.%b\n' "$CYAN" "$RESET" >&2
      exit 0
    }
    parse_args "${menu_args[@]}"
  fi

  # After parsing, prompt for a file if it wasn't provided.
  if [[ -z $INPUT_FILE ]]; then
    INPUT_FILE=$(choose_file) || exit 1
  fi
  [[ ! -r $INPUT_FILE ]] && error_exit "Cannot read input file: '$INPUT_FILE'"

  # Process dynamic filters that require probing the input file
  if [[ -n $fade_params ]]; then
    printf '%bProbing video duration for fade effect...%b\n' "$CYAN" "$RESET"
    local duration; duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$INPUT_FILE")
    local in_dur=${fade_params%:*}
    local out_dur=${fade_params#*:}
    local fade_out_start; fade_out_start=$(bc -l <<<"$duration - $out_dur")
    filters+=("fade=t=in:st=0:d=${in_dur},fade=t=out:st=${fade_out_start}:d=${out_dur}")
  fi

  if ((stabilize)); then
    run_stabilization_pass "$INPUT_FILE"
  fi

  local dir base outfile
  dir=$(dirname -- "$INPUT_FILE")
  base=${INPUT_FILE##*/}; base=${base%.*}_processed
  outfile=$(unique_output_name "$dir" "$base" "$output_format")

  if ((two_pass)) && [[ "$rate_control_mode" == "bitrate" ]]; then
    printf '%bStarting two-pass encode...%b\n' "$CYAN" "$RESET"
    local passlogfile; passlogfile="${LOGDIR}/ffmpeg2pass-$(date +%s)"
    trap 'rm -f -- "${passlogfile}-0.log" "${passlogfile}-0.log.mbtree"' EXIT

    printf '%bPass 1...%b\n' "$CYAN" "$RESET"
    run_ffmpeg "$INPUT_FILE" "/dev/null" "-pass 1 -passlogfile ${passlogfile} -f ${output_format}"
    
    printf '%bPass 2...%b\n' "$CYAN" "$RESET"
    run_ffmpeg "$INPUT_FILE" "$outfile" "-pass 2 -passlogfile ${passlogfile}"
  else
    if ((two_pass)); then
      printf '%bWarning: --two-pass only works with --bitrate, falling back to single pass.%b\n' "$RED" "$RESET"
    fi
    run_ffmpeg "$INPUT_FILE" "$outfile"
  fi

  printf '\n%bOutput saved to:%b %s\n' "$GREEN" "$RESET" "$outfile"
}

main "$@"
