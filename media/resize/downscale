#!/usr/bin/env bash
# Author: 4ndr0666
# Revision: Î¨-Anarch (720p)
# ======================= // DOWNSCALE //
# Description: Downscales videos with a resolution higher than 720p.
# This revised version incorporates robust error handling, safe file processing,
# and content-aware video detection.
#---------------------------------------------

# Exit immediately if a command exits with a non-zero status, if a variable is
# unset, and prevent errors in a pipeline from being masked.
set -euo pipefail

# --- Default Settings ---
KEEP_AUDIO="true"
VERBOSE="false"
# Use 'error' for quiet operation, 'info' for verbose.
FFMPEG_LOG_LEVEL="error"
# Use 'medium' preset as a balance between encoding speed and file size.
ENCODE_PRESET="medium"

# --- Functions ---
print_usage() {
  # Use printf for POSIX compliance and predictable behavior.
  printf "Usage: %s [options] <file-or-dir> [more...]\n\n" "$(basename "$0")"
  # MODIFIED: Help text updated to reflect the new 720p default.
  cat <<'EOF'
Downscales videos larger than 720p to a height of 720p using a high-compatibility,
mathematically lossless H.264 encoding, making them suitable for upscaling software.
If a video is already compliant (720p or smaller), it is skipped.

You can pass multiple files or directories as arguments.

Options:
      --no-audio   Remove the audio stream from the output.
  -v, --verbose    Enable verbose FFmpeg logging for debugging.
  -h, --help       Display this help menu and exit.

Arguments:
  <file-or-dir>    Required. Path to a source video file or a directory to process recursively.
EOF
}

# A robust check to see if a file is a video container with a video stream.
# This is superior to checking file extensions, which are unreliable.
is_processable_video() {
  local file="$1"
  # ffprobe will exit with a non-zero status if the file is not a valid media
  # container or does not contain a video stream. We capture that exit code.
  ffprobe -v error -select_streams v:0 -show_entries stream=codec_type "$file" >/dev/null 2>&1
}

process_video() {
  local input_file="$1"

  if ! is_processable_video "$input_file"; then
    # Only log skipped non-video files in verbose mode to reduce noise.
    if [[ "$VERBOSE" == "true" ]]; then
      printf "Skipping non-video file: '%s'\n" "$input_file"
    fi
    return
  fi

  printf -- "--- Processing: '%s' ---\n" "$input_file"

  # --- Get Video Height ---
  local height
  # Ensure ffprobe failure results in an empty string and is handled gracefully.
  height="$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$input_file" 2>/dev/null || true)"

  if [[ -z "$height" ]]; then
    printf "Warning: Could not detect video height for '%s'. Proceeding with conversion anyway.\n" "$input_file" >&2
  else
    printf "Source video height detected: %sp.\n" "$height"
    # MODIFIED: Check if the video is 720p or smaller.
    if (( height <= 720 )); then
      printf "Video is already 720p or smaller. Skipping.\n"
      return 0
    fi
    printf "Source is >720p. Downscaling to 720p.\n"
  fi

  # --- Determine Output File Name ---
  local input_basename="${input_file%.*}"
  # MODIFIED: Suffix changed to reflect the new target resolution.
  local output_file="${input_basename}_720p.mp4"

  # Handle existing files by creating numbered copies (_1, _2, etc.)
  if [[ -e "$output_file" ]]; then
    # MODIFIED: Suffix changed to reflect the new target resolution.
    local base_name="${output_file%.mp4}"
    local counter=1
    # Loop until we find a filename that does not exist.
    while [[ -e "$output_file" ]]; do
      output_file="${base_name}_${counter}.mp4"
      counter=$((counter + 1))
    done
  fi
  printf "Output file will be: '%s'\n" "$output_file"

  # --- FFmpeg Parameter Setup ---
  # Use an array to build ffmpeg arguments. This is the canonical way to avoid
  # word-splitting issues with arguments that might contain spaces.
  local -a ffmpeg_args
  ffmpeg_args=(
    -hide_banner
    -i "$input_file"
    # Explicitly map the first video stream to handle files with multiple
    # video tracks (e.g., picture-in-picture) more predictably.
    -map 0:v:0
    -vf "scale=-2:720:flags=lanczos,format=yuv420p"
    -c:v libx264
    # Use -qp 0 (Quantization Parameter) for true, mathematically lossless encoding.
    -qp 0
    -preset "$ENCODE_PRESET"
  )

  if [[ "$KEEP_AUDIO" == "true" ]]; then
    printf "Keeping original audio stream.\n"
    # Explicitly map the first audio stream. The '?' makes it optional,
    # preventing errors on videos with no audio. This is more robust than
    # copying all audio streams, which can cause issues with complex files.
    ffmpeg_args+=(-map 0:a:0? -c:a copy)
  else
    printf "Discarding audio stream.\n"
    ffmpeg_args+=(-an)
  fi

  ffmpeg_args+=(
    -loglevel "$FFMPEG_LOG_LEVEL"
    "$output_file"
  )

  # --- FFmpeg Execution ---
  printf "Starting downscale...\n"
  if [[ "$VERBOSE" == "true" ]]; then
    # Use 'printf "%q"' to safely print the command for debugging.
    printf "FFmpeg command: ffmpeg %q\n" "${ffmpeg_args[@]}"
  fi

  if ffmpeg "${ffmpeg_args[@]}"; then
    printf "Downscale complete. Output saved to '%s'.\n" "$output_file"
  else
    printf "Error: Downscale process failed for '%s'.\n" "$input_file" >&2
    # Do not exit, just return 1 to allow processing of other files.
    return 1
  fi
}

# --- Main Execution Logic ---
main() {
  local -a targets=()
  # --- Argument Parsing ---
  # A more robust argument parsing loop.
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        print_usage
        exit 0
        ;;
      --no-audio)
        KEEP_AUDIO="false"
        shift
        ;;
      -v|--verbose)
        VERBOSE="true"
        FFMPEG_LOG_LEVEL="info"
        shift
        ;;
      -*)
        printf "Error: Unknown option: %s\n" "$1" >&2
        print_usage
        exit 1
        ;;
      *)
        targets+=("$1")
        shift
        ;;
    esac
  done

  # --- Validation and Dependency Check ---
  if [[ ${#targets[@]} -eq 0 ]]; then
    printf "Error: No input files or directories provided.\n" >&2; print_usage; exit 1
  fi
  if ! command -v ffmpeg >/dev/null 2>&1 || ! command -v ffprobe >/dev/null 2>&1; then
    printf "Error: FFmpeg (including ffprobe) is not installed or not in your PATH.\n" >&2; exit 1
  fi

  # --- Process all targets ---
  local target
  for target in "${targets[@]}"; do
    if [[ ! -e "$target" ]]; then
      printf "Error: Input '%s' does not exist. Skipping.\n" "$target" >&2
      continue
    fi

    if [[ -d "$target" ]]; then
      printf "=== Processing Directory: '%s' ===\n" "$target"
      # Use find -print0 and a while read loop with a null delimiter.
      # This is the only truly safe way to handle all possible filenames,
      # including those with spaces, newlines, and other special characters.
      local file
      while IFS= read -r -d '' file; do
        process_video "$file"
      done < <(find "$target" -type f -print0)
    elif [[ -f "$target" ]]; then
      process_video "$target"
    fi
  done

  printf -- "=========================\n"
  printf "All tasks complete.\n"
}

# Pass all script arguments to the main function.
main "$@"
