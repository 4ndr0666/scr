#!/usr/bin/env bash
# Author: 4ndr0666
# Version: 1.1
set -euo pipefail
# ======================== // MERGE //
# Description: Losslessly merge multiple video files,
# regardless of differences in container, resolution, FPS, 
# or codec.
# ---------------------------------------------------------

declare -a TEMP_FILES=()
cleanup_all() {
	# Suppress errors as cleanup is a best-effort operation
	rm -f "${TEMP_FILES[@]}" >/dev/null 2>&1
}
trap cleanup_all EXIT INT TERM
register_temp_file() {
	TEMP_FILES+=("$1")
}

## Utility Functions
command_exists() {
	command -v "$1" >/dev/null 2>&1
}

absolute_path() {
	# This function uses the globally set REALPATH_CMD
	"$REALPATH_CMD" -- "$1"
}

printv() {
	[ "${verbose:-0}" -eq 1 ] && printf '%s\n' "$@" >&2
}

## Dependency and Environment Check
check_deps() {
	local dep
	for dep in ffmpeg ffprobe awk bc; do
		if ! command_exists "$dep"; then
			echo "Error: Required command '$dep' not found." >&2
			exit 1
		fi
	done

	if command_exists realpath; then
		REALPATH_CMD="realpath"
	elif readlink -f / >/dev/null 2>&1; then
		REALPATH_CMD="readlink -f"
	else
		echo "Error: Neither 'realpath' nor 'readlink -f' found." >&2
		exit 1
	fi
	# Export for use in subshells if needed, and to make it available to absolute_path
	export REALPATH_CMD
}

## Main Merge Logic
run_merge() {
	# --- Option Defaults & Global Variables ---
	local output_file=""
	local fast_encode=0
	local verbose=0
	local -a files=()

	# --- Argument Parsing ---
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-o | --output)
			output_file="$2"
			shift 2
			;;
		--fast-encode)
			fast_encode=1
			shift
			;;
		-v | --verbose)
			verbose=1
			shift
			;;
		-h | --help)
			cat <<EOH
Usage: ${0##*/} [OPTIONS] <file1> <file2> [...]

A dedicated tool to losslessly merge multiple video files, even with
varying containers, resolutions, codecs, or framerates.

Options:
  -o, --output FILE   Set the output filename.
                      (Default: merged_YYYYMMDD_HHMMSS.mp4)
  --fast-encode       On re-encode, use a fast, high-quality (but not
                      lossless) preset instead of the default lossless mode.
  -v, --verbose       Enable verbose output to see ffmpeg commands.
  -h, --help          Show this help message.
EOH
			exit 0
			;;
		--)
			shift
			files+=("$@")
			break
			;;
		-*)
			echo "Error: Unknown option '$1'" >&2
			exit 1
			;;
		*)
			files+=("$1")
			shift
			;;
		esac
	done

	if ((${#files[@]} < 2)); then
		echo "Error: At least two input files are required." >&2
		exit 1
	fi

	# --- File Validation & Path Resolution ---
	local -a abs_files=()
	for f in "${files[@]}"; do
		if [[ -f "$f" ]]; then
			if local abs_f=$(absolute_path "$f"); then
				abs_files+=("$abs_f")
			else
				echo "Warning: Could not resolve path for '$f'. Skipping." >&2
			fi
		else
			echo "Warning: Input file not found: '$f'. Skipping." >&2
		fi
	done

	if ((${#abs_files[@]} < 2)); then
		echo "Error: Fewer than two valid input files were found." >&2
		exit 1
	fi
	files=("${abs_files[@]}")

	# --- Output File Handling ---
	if [[ -z "$output_file" ]]; then
		output_file="merged_$(date +%Y%m%d_%H%M%S).mp4"
	fi
	if [[ -e "$output_file" ]]; then
		echo "Error: Output file '$output_file' already exists. Refusing to overwrite." >&2
		exit 1
	fi

	# --- Create FFmpeg Concat List File ---
	local list_file
	list_file=$(mktemp) || { echo "Failed to create temp list file" >&2; exit 1; }
	register_temp_file "$list_file"
	for f in "${files[@]}"; do
		# Correctly escape single quotes for the concat demuxer format
		printf "file '%s'\n" "$(printf "%s" "$f" | sed "s/'/&\\\\&/g")" >>"$list_file"
	done

	# --- Stage 1: Attempt Lossless Stream Copy ---
	echo "Attempting fast, lossless stream copy..." >&2
	local -a stream_copy_cmd=(ffmpeg -hide_banner -loglevel error -y -f concat -safe 0 -i "$list_file" -c copy "$output_file")
	printv "Executing: ${stream_copy_cmd[*]}"
	if "${stream_copy_cmd[@]}"; then
		echo "✅ Stream copy successful: $output_file"
		exit 0
	else
		echo "⚠️  Stream copy failed. Incompatible streams detected. Falling back to lossless re-encode..." >&2
		rm -f "$output_file" # Clean up failed/zero-byte output
	fi

	# --- Stage 2: Fallback to Robust, Normalizing Re-encode ---
	echo "Analyzing files for re-encode parameters..." >&2
	local max_w=0 max_h=0 max_fps=0.0
	for inp in "${files[@]}"; do
		local ffprobe_output
		ffprobe_output=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=width,height,avg_frame_rate "$inp")
		local w h fr
		w=$(echo "$ffprobe_output" | awk -F= '/^width=/ {print $2}')
		h=$(echo "$ffprobe_output" | awk -F= '/^height=/ {print $2}')
		fr=$(echo "$ffprobe_output" | awk -F= '/^avg_frame_rate=/ {print $2}')
		[[ "$w" =~ ^[0-9]+$ ]] && ((w > max_w)) && max_w=$w
		[[ "$h" =~ ^[0-9]+$ ]] && ((h > max_h)) && max_h=$h
		if [[ -n "$fr" ]] && [[ "$(bc -l <<<"$(echo "$fr" | sed 's/\// /g' | awk '{print $1 / $2}') > $max_fps")" -eq 1 ]]; then
			max_fps=$(echo "$fr" | sed 's/\// /g' | awk '{print $1 / $2}')
		fi
	done

	local target_res="${max_w}x${max_h}"
	local target_fps
	target_fps=$(printf "%.0f" "$max_fps")
	[[ "$target_fps" -eq 0 ]] && target_fps=30 # Fallback if no FPS could be read
	echo "Normalizing all clips to ${target_res} @ ${target_fps}fps..." >&2

	# --- Build Filter Complex Command ---
	local -a ffmpeg_cmd=(ffmpeg -hide_banner -loglevel error -y)
	local filter_complex=""
	local video_maps=""
	local audio_maps=""
	local i
	for i in "${!files[@]}"; do
		ffmpeg_cmd+=(-i "${files[$i]}")
		# Normalize video stream
		filter_complex+="[${i}:v]scale=${target_res}:force_original_aspect_ratio=decrease,pad=${target_res}:(ow-iw)/2:(oh-ih)/2,fps=${target_fps}[v${i}];"
		video_maps+="[v${i}]"
		# Normalize audio stream (resample to a common rate)
		filter_complex+="[${i}:a]aresample=async=1:first_pts=0[a${i}];"
		audio_maps+="[a${i}]"
	done

	local num_inputs=${#files[@]}
	filter_complex+="${video_maps}concat=n=${num_inputs}:v=1:a=0[vout];"
	filter_complex+="${audio_maps}concat=n=${num_inputs}:v=0:a=1[aout]"

	ffmpeg_cmd+=(-filter_complex "$filter_complex" -map "[vout]" -map "[aout]")

	# --- Set Encoding Options (Lossless vs. Fast) ---
	if [[ "$fast_encode" -eq 1 ]]; then
		echo "Using fast re-encode preset (crf=15)..." >&2
		ffmpeg_cmd+=(-c:v libx264 -preset fast -crf 15)
	else
		echo "Using lossless re-encode preset (qp=0)..." >&2
		ffmpeg_cmd+=(-c:v libx264 -preset veryslow -qp 0)
	fi
	ffmpeg_cmd+=(-pix_fmt yuv420p -c:a aac -b:a 192k "$output_file")

	# --- Execute Final Command ---
	printv "Executing: ${ffmpeg_cmd[*]}"
	if "${ffmpeg_cmd[@]}"; then
		echo "✅ Re-encoded merge complete: $output_file"
	else
		echo "❌ Re-encode failed." >&2
		exit 1
	fi
}

# --- Script Entry Point ---
check_deps
run_merge "$@"
