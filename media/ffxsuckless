#!/usr/bin/env bash
# Author: 4ndr0666
# Canonical Source of Truth (CSoT) v1.0.0
# FFX — Lossless, failure-resilient FFmpeg orchestration CLI
set -euo pipefail

# ========================== // FFX Canonical // ==========================

# --- XDG & Directory Setup ---
: "${XDG_CONFIG_HOME:="$HOME/.config"}"
: "${XDG_DATA_HOME:="$HOME/.local/share"}"
: "${XDG_CACHE_HOME:="$HOME/.cache"}"
: "${XDG_RUNTIME_DIR:="${TMPDIR:-/tmp}"}"

FFX_CONFIG_DIR="$XDG_CONFIG_HOME/ffx"
FFX_LOG_DIR="$XDG_DATA_HOME/ffx"
FFX_CACHE_DIR="$XDG_CACHE_HOME/ffx"

# Session-scoped runtime dir (ALL ephemeral artifacts live here)
FFX_RUN_DIR="$(mktemp -d -p "${XDG_RUNTIME_DIR}" "ffx.XXXXXXXX")"

mkdir -p "$FFX_CONFIG_DIR" "$FFX_LOG_DIR" "$FFX_CACHE_DIR"
LOG_FILE="$FFX_LOG_DIR/ffx.log"

# --- Colors and Logging ---
if command -v tput >/dev/null 2>&1 && [[ -t 1 ]]; then
	CYAN="$(tput setaf 6)"
	GREEN="$(tput setaf 2)"
	BOLD="$(tput bold)"
	RED="$(tput setaf 1)"
	RESET="$(tput sgr0)"
else
	CYAN="" GREEN="" BOLD="" RED="" RESET=""
fi

warn() { printf '%b[⚠️] %s%b\n' "${RED}" "$1" "${RESET}" >&2; }
die()  { printf '%b[❌] Error: %s%b\n' "${RED}" "$1" "${RESET}" >&2; exit 1; }

# --- Defaults ---
default_config() {
	VERBOSE_MODE=false
	DRY_RUN=false
	REMOVE_AUDIO=false
	COMPOSITE_MODE=false
	MAX_1080=false
	INTERPOLATE=false

	OUTPUT_DIR="$(pwd)"
	SPECIFIC_FPS=""
	PTS_FACTOR=""

	# Timeout: user-controlled; 0 disables
	FFX_TIMEOUT="${FFX_TIMEOUT:-300}"
	FFX_TIMEOUT_USER_SET=""

	# Canonical encoding policy: LOSSLESS ONLY
	ADV_CONTAINER="mp4"
	ADV_RES="1920x1080"
	ADV_FPS="60"
	ADV_CODEC="libx264"
}
default_config

# --- Cleanup & Lifecycle ---
cleanup_all() {
	# Remove ALL ephemeral artifacts safely
	[ -d "$FFX_RUN_DIR" ] && rm -rf -- "$FFX_RUN_DIR"
}
trap 'cleanup_all' EXIT INT TERM

# --- Validation & Helpers ---
command_exists() { command -v "$1" >/dev/null 2>&1; }
is_nonneg_int() { [[ "${1:-}" =~ ^[0-9]+$ ]]; }

check_deps() {
	for dep in ffmpeg ffprobe awk bc; do
		command_exists "$dep" || die "Required dependency '$dep' is not installed."
	done
	if ! command_exists timeout; then
	fi
}

absolute_path() {
	readlink -f "$1" 2>/dev/null || realpath "$1" 2>/dev/null || (cd "$(dirname "$1")" && printf '%s/%s\n' "$(pwd)" "$(basename "$1")")
}

get_default_filename() {
	local base="${1:-out}" suffix="${2:-tmp}" ext="${3:-mp4}"
	local candidate="${OUTPUT_DIR}/${base}_${suffix}.${ext}"
	local counter=1
	while [ -e "$candidate" ]; do
		candidate="${OUTPUT_DIR}/${base}_${suffix}_${counter}.${ext}"
		counter=$((counter + 1))
	done
	echo "$candidate"
}

mktemp_ffx() { mktemp -p "$FFX_RUN_DIR" --suffix="${1:-.tmp}"; }

# --- Audio Options ---
get_audio_opts_array() {
	if [ "$REMOVE_AUDIO" = true ]; then
		printf '%s\n' "-an"
	else
		printf '%s\n' "-c:a" "copy"
	fi
}

# --- FFmpeg Runner ---
run_ffmpeg() {
	if [ "$DRY_RUN" = true ]; then
		printf "[DRY-RUN] ffmpeg"
		printf " %q" "$@"
		printf "\n"
		return 0
	fi

	is_nonneg_int "${FFX_TIMEOUT}" || die "Invalid timeout '${FFX_TIMEOUT}'. Must be non-negative integer."

	local -a base_cmd=("ffmpeg" "-hide_banner")


	if [ "$ec" -eq 124 ]; then
		die "FFmpeg timed out after ${FFX_TIMEOUT}s. Use --timeout 0 to disable."
	elif [ "$ec" -ne 0 ]; then
		warn "FFmpeg failed (exit $ec). See log: $LOG_FILE"
		tail -n 30 "$LOG_FILE" >&2 || true
		return 1
	fi
	return 0
}

# --- DTS & Timestamp Correction ---
check_dts_for_file() {
	ffprobe -v error -select_streams v -show_entries frame=pkt_dts_time -of csv=p=0 "$1" |
	awk 'NR>1 && $1<prev{exit 1}{prev=$1}'
}

fix_dts() {
	local file="$1" tmpf
	tmpf="$(mktemp_ffx .mp4)"
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)

	# Stage 1: remux
	if ! run_ffmpeg -y -fflags +genpts -i "$file" -c:v copy "${audio_opts[@]}" -movflags +faststart "$tmpf"; then
		# Stage 2: lossless re-encode (MANDATORY -qp 0)
		run_ffmpeg -y -fflags +genpts -i "$file" -c:v "$ADV_CODEC" -qp 0 -preset ultrafast "${audio_opts[@]}" "$tmpf" || return 1
	fi
	echo "$tmpf"
}

ensure_dts_correct() {
	local file="$1"
	[ -f "$file" ] || die "File not found: $file"
	if ! check_dts_for_file "$file"; then
		local fixed; fixed="$(fix_dts "$file")" || return 1
		[ -s "$fixed" ] || die "DTS fix produced empty output."
		echo "$fixed"
	else
		echo "$file"
	fi
}

# =============================================================================
# === COMMANDS ================================================================
# =============================================================================

## probe
cmd_probe() {
	local input="${1:-}"
	if [ -z "$input" ]; then
		command_exists fzf || die "fzf not found."
		input="$(fzf)" || die "No file selected."
	fi
	[ -f "$input" ] || die "File not found: $input"

	local sz hsz res fps dur
	sz="$(stat -c '%s' "$input" 2>/dev/null || echo 0)"
	hsz="$(awk -v b="$sz" 'BEGIN{split("B KiB MiB GiB",u);i=1;while(b>=1024&&i<4){b/=1024;i++}printf"%.2f %s",b,u[i]}')"
	res="$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "$input" || echo unknown)"
	fps="$(ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=nw=1:nk=1 "$input" || echo 0/0)"
	dur="$(ffprobe -v error -show_entries format=duration -of default=nw=1:nk=1 "$input" || echo 0)"

	printf '%b# === FFX Probe ===%b\n' "${CYAN}${BOLD}" "${RESET}"
	printf '%bFile:%b %s\n' "${CYAN}" "${RESET}" "$input"
	printf '%bSize:%b %s\n' "${CYAN}" "${RESET}" "$hsz"
	printf '%bResolution:%b %s\n' "${CYAN}" "${RESET}" "$res"
	printf '%bFPS:%b %s\n' "${CYAN}" "${RESET}" "$fps"
	printf '%bDuration:%b %ss\n' "${CYAN}" "${RESET}" "$dur"
}

## process (LOSSLESS)
cmd_process() {
	local input="${1:-}" output="${2:-}"
	[ -n "$input" ] || die "process requires input."
	[ -s "$input" ] || die "Input missing or empty."

	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "processed" "$ADV_CONTAINER")"
	[ -n "$SPECIFIC_FPS" ] && ADV_FPS="$SPECIFIC_FPS"

	local fixed; fixed="$(ensure_dts_correct "$input")"

	if [ "$MAX_1080" = true ]; then
		local h; h="$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$fixed" || echo 0)"
		[ "$h" -gt 1080 ] && ADV_RES="1920x1080"
	fi

	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	run_ffmpeg -y -i "$fixed" -vf "scale=${ADV_RES}:force_original_aspect_ratio=decrease" -r "$ADV_FPS" \
		-c:v "$ADV_CODEC" -qp 0 -preset medium "${audio_opts[@]}" -movflags +faststart "$output" || die "process failed."
}

## composite helper (LOSSLESS)
composite_pair_lossless() {
	local a="$1" b="$2" out
	out="$(mktemp_ffx .mp4)"

	local ha hb
	ha="$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$a")"
	hb="$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$b")"
	local mh=$(( ha>hb?ha:hb ))

	local fc="[0:v]scale=-2:${mh}[v0];[1:v]scale=-2:${mh}[v1];[v0][v1]hstack=2[v]"
	local -a args=("-y" "-i" "$a" "-i" "$b")
	if [ "$REMOVE_AUDIO" = false ]; then
		fc+=";[0:a][1:a]amerge=inputs=2[a]"
		args+=("-filter_complex" "$fc" "-map" "[v]" "-map" "[a]" "-ac" "2")
	else
		args+=("-filter_complex" "$fc" "-map" "[v]" "-an")
	fi
	args+=("-c:v" "$ADV_CODEC" "-qp" "0" "-preset" "ultrafast" "$out")
	run_ffmpeg "${args[@]}" || die "composite failed."
	echo "$out"
}

## merge
cmd_merge() {
	local files=() output=""
	while [ $# -gt 0 ]; do
		case "$1" in
			-o|--output) output="$2"; shift 2 ;;
			*) files+=("$1"); shift ;;
		esac
	done

	if [ "${#files[@]}" -lt 1 ]; then
		command_exists fzf || die "fzf required."
		mapfile -t files < <(fzf --multi)
	fi
	[ "${#files[@]}" -gt 0 ] || die "No files selected."
	[ -z "$output" ] && output="$(get_default_filename "output" "merged" "$ADV_CONTAINER")"

	local fixed=()
	for f in "${files[@]}"; do fixed+=("$(ensure_dts_correct "$f")"); done

	local segs=()
	if [ "$COMPOSITE_MODE" = true ]; then
		local others=() wides=()
		for f in "${fixed[@]}"; do
			local w h; read -r w h < <(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of default=nw=1:nk=1 "$f" | xargs)
			awk -v w="$w" -v h="$h" 'BEGIN{exit (h>0 && w/h>=1.77)?0:1}' && wides+=("$f") || others+=("$f")
		done
		segs+=("${wides[@]}")
		for ((i=0;i<${#others[@]};i+=2)); do
			if [ $((i+1)) -lt "${#others[@]}" ]; then
				segs+=("$(composite_pair_lossless "${others[i]}" "${others[i+1]}")")
			else
				segs+=("${others[i]}")
			fi
		done
	else
		local first res uniform=true
		first="${fixed[0]}"
		res="$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "$first")"
		for f in "${fixed[@]:1}"; do
			[ "$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "$f")" = "$res" ] || { uniform=false; break; }
		done
		if [ "$uniform" = true ]; then
			segs=("${fixed[@]}")
		else
			for f in "${fixed[@]}"; do
				local t; t="$(mktemp_ffx .mp4)"
				local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
				run_ffmpeg -y -i "$f" -vf "scale=$res" -c:v "$ADV_CODEC" -qp 0 -preset ultrafast "${audio_opts[@]}" "$t" || die "normalize failed."
				segs+=("$t")
			done
		fi
	fi

	local list; list="$(mktemp_ffx .txt)"
	for f in "${segs[@]}"; do printf "file '%s'\n" "$(absolute_path "$f")" >>"$list"; done
	run_ffmpeg -y -f concat -safe 0 -i "$list" -c copy "$output" || die "merge failed."
}

## looperang
cmd_looperang() {
	local input="${1:-}" output="${2:-}"
	[ -n "$input" ] || die "looperang requires input."
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "looperang" "$ADV_CONTAINER")"

	local fixed; fixed="$(ensure_dts_correct "$input")"
	local rev; rev="$(mktemp_ffx .mp4)"
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	run_ffmpeg -y -i "$fixed" -vf reverse -af areverse "${audio_opts[@]}" -c:v "$ADV_CODEC" -qp 0 -preset ultrafast "$rev" || die "reverse failed."

	local list; list="$(mktemp_ffx .txt)"
	printf "file '%s'\nfile '%s'\n" "$(absolute_path "$fixed")" "$(absolute_path "$rev")" >"$list"
	run_ffmpeg -y -f concat -safe 0 -i "$list" -c copy "$output" || die "looperang failed."
}

## slowmo (LOSSLESS)
cmd_slowmo() {
	local input="${1:-}" output="${2:-}" factor="${3:-2}"
	[ -n "$PTS_FACTOR" ] && factor="$PTS_FACTOR"
	[ -n "$input" ] || die "slowmo requires input."
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "slowmo" "$ADV_CONTAINER")"

	local fixed; fixed="$(ensure_dts_correct "$input")"
	local fps="$ADV_FPS"; [ -n "$SPECIFIC_FPS" ] && fps="$SPECIFIC_FPS"

	local v="setpts=${factor}*PTS" a=""
	if [ "$INTERPOLATE" = true ]; then
		[ -z "$SPECIFIC_FPS" ] && fps="120"
		v="minterpolate=fps=${fps}:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:vsbmc=1,${v}"
	fi

	local -a args=("-y" "-i" "$fixed")
	if [ "$REMOVE_AUDIO" = false ]; then
		local sp; sp="$(bc -l <<<"1/$factor")"
		while (( $(echo "$sp < 0.5" | bc -l) )); do a+="atempo=0.5,"; sp="$(bc -l <<<"$sp/0.5")"; done
		while (( $(echo "$sp > 2.0" | bc -l) )); do a+="atempo=2.0,"; sp="$(bc -l <<<"$sp/2.0")"; done
		a+="atempo=$sp"
		args+=("-filter_complex" "[0:v]${v}[v];[0:a]${a}[a]" "-map" "[v]" "-map" "[a]")
	else
		args+=("-vf" "$v" "-an")
	fi
	args+=("-r" "$fps" "-c:v" "$ADV_CODEC" "-qp" "0" "-preset" "medium" "$output")
	run_ffmpeg "${args[@]}" || die "slowmo failed."
}

## fix
cmd_fix() {
	local input="${1:-}" output="${2:-}"
	[ -n "$input" ] || die "fix requires input."
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "fixed" "$ADV_CONTAINER")"
	local fixed; fixed="$(ensure_dts_correct "$input")"
	if [ "$fixed" != "$input" ]; then mv "$fixed" "$output"; else cp "$input" "$output"; fi
}

## clean
cmd_clean() {
	local input="${1:-}" output="${2:-}"
	[ -n "$input" ] || die "clean requires input."
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "cleaned" "$ADV_CONTAINER")"
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	run_ffmpeg -y -i "$input" -map_metadata -1 -c copy "${audio_opts[@]}" "$output" || die "clean failed."
}

# =============================================================================
# === PARSING & DISPATCH ======================================================
# =============================================================================

display_usage() {
	cat <<EOF
Usage: ffx [global options] <command> [arguments]

Global Options:
  -v, --verbose         Verbose logging
  --dry-run             Print ffmpeg commands only
  -an, --remove-audio   Remove audio tracks
  -C, --composite       Composite mode for merge
  -P, --max-1080        Clamp height to 1080p (process)
  -o, --output-dir DIR  Output directory
  -f, --fps N           Force FPS
  -p, --pts N           PTS factor (slowmo)
  -i, --interpolate     Motion interpolation (slowmo)
  --timeout SEC         FFmpeg timeout (0 disables)
  -h, --help            Help

Commands:
  probe <input>
  process <input> [output]
  merge [files...] [-o out]
  looperang <input> [output]
  slowmo <input> [output] [factor]
  fix <input> [output]
  clean <input> [output]
EOF
	exit 0
}

parse_global_options() {
	REMAINING_ARGS=()
	while [ $# -gt 0 ]; do
		case "$1" in
			-v|--verbose) VERBOSE_MODE=true; shift ;;
			--dry-run) DRY_RUN=true; shift ;;
			-an|--remove-audio) REMOVE_AUDIO=true; shift ;;
			-C|--composite) COMPOSITE_MODE=true; shift ;;
			-P|--max-1080) MAX_1080=true; shift ;;
			-o|--output-dir) OUTPUT_DIR="$2"; shift 2 ;;
			-f|--fps) SPECIFIC_FPS="$2"; shift 2 ;;
			-p|--pts) PTS_FACTOR="$2"; shift 2 ;;
			-i|--interpolate) INTERPOLATE=true; shift ;;
			--timeout) FFX_TIMEOUT="$2"; FFX_TIMEOUT_USER_SET=1; shift 2 ;;
			-h|--help) display_usage ;;
			*) REMAINING_ARGS+=("$1"); shift ;;
		esac
	done
}

main_dispatch() {
	local cmd="${1:-help}"; shift || true
	case "$cmd" in
		probe) cmd_probe "$@" ;;
		process) cmd_process "$@" ;;
		merge) cmd_merge "$@" ;;
		looperang) cmd_looperang "$@" ;;
		slowmo) cmd_slowmo "$@" ;;
		fix) cmd_fix "$@" ;;
		clean) cmd_clean "$@" ;;
		help) display_usage ;;
		*) die "Unknown command: $cmd" ;;
	esac
}

main() {
	check_deps
	parse_global_options "$@"
	mkdir -p -- "$OUTPUT_DIR" || die "Cannot create output dir."
	[ -w "$OUTPUT_DIR" ] || die "Output dir not writable."
	[ "${#REMAINING_ARGS[@]}" -gt 0 ] || display_usage
	main_dispatch "${REMAINING_ARGS[@]}"
}

main "$@"