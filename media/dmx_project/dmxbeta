#!/usr/bin/env python3

import os
import subprocess
import json
import logging
import shutil
import tempfile
import textwrap
import re
import sys
import argparse
from concurrent.futures import ThreadPoolExecutor, TimeoutError
from typing import List, Dict, Any, Optional
from fractions import Fraction
from tqdm import tqdm
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field
from prompt_toolkit import prompt
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.styles import Style

SUPPORTED_CODECS = ["avc", "h264", "hev1", "h265", "hevc", "vp8", "vp9"]
SUPPORTED_VIDEO_ENCODERS = ["h264"]
DEFAULT_AUDIO_CODECS = [
    "aac",
    "libopus",
    "libmp3lame",
]  # Consider making this configurable
REQUIRED_TOOLS = [
    "ffmpeg",
    "ffprobe",
    "mediainfo",
    "fzf",
    "vspipe",
]  # vspipe is VapourSynth dependency
VIDEO_EXTENSIONS = [".mp4", ".mkv", ".avi", ".mov", ".flv", ".wmv", ".webm"]
MAX_WORKERS_DEFAULT = os.cpu_count() or 1  # Ensure at least 1 worker

GREEN = "\033[0;36m"  # Made Cyan intentionally
CYAN = "\033[0;36m"
BOLD = "\033[1m"
RED = "\033[0;31m"
NC = "\033[0m"  # No Color

style = Style.from_dict(
    {
        "completion-menu.completion": "fg:#15FFFF bg:default",
        "completion-menu.completion.current": "fg:#15FFFF bg:#333333",
        "prompt": "ansicyan",  # Style the prompt itself
    }
)

DEFAULT_CONFIG = {
    "FFMPEG_BIN": None,
    "FFPROBE_BIN": None,
    "VSPIPE_BIN": None,
    "MAX_WORKERS": MAX_WORKERS_DEFAULT,
    # Add VapourSynth plugin paths here, or rely on VS environment variables
    # "VAPOURSYNTH_PLUGIN_PATHS": ["/usr/lib/vapoursynth", "/usr/local/lib/vapoursynth"],
}
CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config")) / "dmx"
CONFIG_FILE = CONFIG_DIR / "config.json"
LOG_DIR = CONFIG_DIR / "logs"
LOG_FILE = LOG_DIR / "video_processing.log"

LOG_DIR.mkdir(parents=True, exist_ok=True)

logger = logging.getLogger(__name__)  # Use __name__ for logger name
logger.setLevel(logging.INFO)

console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.INFO)  # Or logging.DEBUG for more verbosity
console_formatter = logging.Formatter("%(message)s")  # Simple format for console
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

file_handler = logging.FileHandler(LOG_FILE)
file_handler.setLevel(logging.INFO)
file_formatter = logging.Formatter(
    "%(asctime)s [%(levelname)s] %(name)s - %(message)s"
)  # Include logger name
file_handler.setFormatter(file_formatter)
logger.addHandler(file_handler)


def print_warning(message: str):
    """Print a warning message with proper formatting and log it."""
    # No need to sanitize ASCII, print handles UTF-8 fine
    print(f"{RED}⚠️  {message}{NC}")
    logger.warning(message)


def print_status(message: str, status: str = "OK"):
    """Print a status message with a corresponding symbol and log it."""
    symbols = {
        "OK": f"{GREEN}✓{NC}",
        "ERROR": f"{RED}❌{NC}",
        "WARNING": f"{RED}⚠️{NC}",
        "INFO": f"{GREEN}ℹ️{NC}",
    }
    status_symbol = symbols.get(status.upper(), f"{RED}❔{NC}")
    # Avoid extra newline if message already has one
    print(f"{message.rstrip()} [{status_symbol}]")
    logger.info(f"{message.rstrip()} [{status.upper()}]")


def combine_filters(*filters: str) -> str:
    """Combine multiple FFmpeg video filters into a single filter string."""
    # Filter out empty strings before joining
    return ",".join(f.strip() for f in filters if f and f.strip())


def round_frame_rate(frame_rate: float, decimals: int = 2) -> float:
    """Round the frame rate to a specified number of decimal places."""
    return round(frame_rate, decimals)


def find_binary(name: str, config: Dict[str, Any]) -> Optional[str]:
    """Find a binary using config path or shutil.which."""
    config_path = config.get(f"{name.upper()}_BIN")
    if config_path and Path(config_path).exists():
        logger.debug(f"Found {name} at config path: {config_path}")
        return str(Path(config_path).resolve())

    which_path = shutil.which(name)
    if which_path:
        logger.debug(f"Found {name} using shutil.which: {which_path}")
        return str(Path(which_path).resolve())

    logger.debug(f"{name} not found in config or PATH.")
    return None


def check_encoder_availability(encoder: str, ffmpeg_path: str) -> bool:
    """Check if a specific encoder is available in FFmpeg."""
    if not ffmpeg_path:
        logger.error("FFmpeg path not provided to check encoder availability.")
        return False
    try:
        # Use -hide_banner to reduce noise
        result = subprocess.run(
            [ffmpeg_path, "-hide_banner", "-encoders"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=True,  # Raise CalledProcessError for non-zero exit codes
        )
        # Check both stdout and stderr as some tools print info to stderr
        available_encoders = (result.stdout + result.stderr).lower()
        is_available = encoder.lower() in available_encoders
        logger.debug(f"Encoder '{encoder}' availability check: {is_available}")
        return is_available
    except FileNotFoundError:
        logger.error(f"FFmpeg binary not found at {ffmpeg_path}.")
        return False
    except subprocess.CalledProcessError as e:
        logger.error(f"Error running '{ffmpeg_path} -encoders': {e}")
        logger.error(f"Stdout: {e.stdout}")
        logger.error(f"Stderr: {e.stderr}")
        return False
    except Exception as e:
        logger.error(
            f"Unexpected error checking encoder availability for {encoder}: {e}"
        )
        return False


def check_vapoursynth_plugin_availability(plugin_name: str) -> bool:
    """Check if a VapourSynth plugin is available by attempting to load it."""
    # This is a basic check. A more robust check might involve running a vspipe script
    # that attempts to load the plugin and exits, checking the exit code.
    # However, directly checking file existence in standard plugin paths is simpler
    # and often sufficient if combined with clear error messages.

    # Prioritize VAPOURSYNTH_PLUGIN_PATH environment variable
    plugin_paths = os.environ.get("VAPOURSYNTH_PLUGIN_PATH", "").split(os.pathsep)
    # Add standard Linux paths
    plugin_paths.extend(
        [
            "/usr/lib/vapoursynth",
            "/usr/local/lib/vapoursynth",
            # Add other common paths if necessary, maybe from config
        ]
    )
    # Remove empty paths from split
    plugin_paths = [p for p in plugin_paths if p]

    for path in plugin_paths:
        plugin_path = Path(path) / plugin_name
        if plugin_path.exists():
            logger.debug(f"Found VapourSynth plugin '{plugin_name}' at {plugin_path}")
            return True

    logger.warning(
        f"VapourSynth plugin '{plugin_name}' not found in standard paths or VAPOURSYNTH_PLUGIN_PATH."
    )
    return False


def sanitize_filename(filename: str) -> str:
    """Sanitize the filename by removing or replacing problematic characters."""
    # More robust sanitization: remove characters not allowed in most filesystems
    # and replace spaces. Keep dots, hyphens, underscores.
    sanitized = re.sub(r'[<>:"/\\|?*]', "_", filename)  # Replace common invalid chars
    sanitized = sanitized.replace(" ", "_")
    sanitized = re.sub(
        r"[^\w\-_\.]", "", sanitized
    )  # Remove anything else not word, hyphen, underscore, dot
    # Ensure it's not just dots or empty
    sanitized = sanitized.lstrip(". ")
    if not sanitized:
        sanitized = "sanitized_file"
    return sanitized


def run_command(
    command: List[str], description: str = "", display_output: bool = False
) -> str:
    """Run a system command and optionally display its output in real-time."""
    command_str = subprocess.list2cmdline(
        command
    )  # Use list2cmdline for logging clarity
    logger.info(f"Running command: {command_str}")
    print_status(f"Executing: {description}", "INFO")

    try:
        if display_output:
            # Use Popen for real-time output streaming
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,  # Merge stderr into stdout for simpler streaming
                text=True,
                encoding="utf-8",  # Specify encoding
                errors="replace",  # Handle potential encoding errors
            )
            output_lines = []
            # Stream output line by line
            while True:
                line = process.stdout.readline()
                if not line:
                    break
                print(line, end="")
                output_lines.append(line)

            return_code = process.wait()
            output = "".join(output_lines)  # Capture output for logging/return

            if return_code != 0:
                logger.error(
                    f"{description} - Command failed with exit code {return_code}: {command_str}"
                )
                logger.error(f"Command Output:\n{output}")
                raise subprocess.CalledProcessError(return_code, command, output=output)

            logger.info(f"{description} - Command executed successfully.")
            print_status(f"{description} completed.", "OK")
            return output

        else:
            # Use run for simpler execution when output streaming isn't needed
            result = subprocess.run(
                command,
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
                errors="replace",
            )
            logger.info(f"{description} - Command executed successfully.")
            logger.debug(f"Command Output:\n{result.stdout}")
            print_status(f"{description} completed.", "OK")
            return result.stdout

    except FileNotFoundError:
        error_msg = f"Command not found: {command[0]}. Please ensure it is installed and in your PATH."
        logger.error(error_msg)
        print_warning(error_msg)
        raise DependencyError(error_msg)  # Raise custom error for missing binary
    except subprocess.CalledProcessError as e:
        logger.error(
            f"{description} - Command failed with exit code {e.returncode}: {command_str}"
        )
        logger.error(f"Command Output:\n{e.stdout}")
        # If stderr was captured separately (not merged), log it too
        if hasattr(e, "stderr") and e.stderr:
            logger.error(f"Command Error Output:\n{e.stderr}")
        print_warning(f"Command failed: {description}. Check logs for details.")
        raise  # Re-raise the exception after logging
    except Exception as e:
        logger.error(f"{description} - Unexpected error: {e}")
        print_warning(
            "Unexpected error occurred during execution. Check logs for more details."
        )
        raise  # Re-raise the exception


def estimate_bitrate(width: int, height: int, base_bitrate_mbps: float = 5.0) -> str:
    """Estimate the video bitrate based on resolution, relative to 1080p."""
    # Simple scaling based on pixel count relative to 1080p (1920*1080)
    pixels = width * height
    if pixels <= 0:
        return "1M"  # Default if resolution is unknown

    ref_pixels = 1920 * 1080
    # Scale bitrate based on pixel ratio, with a minimum
    bitrate_mbps = max(1.0, base_bitrate_mbps * (pixels / ref_pixels))
    # Add a buffer, maybe 20%
    bitrate_mbps *= 1.2
    return f"{bitrate_mbps:.1f}M"


class DependencyError(Exception):
    """Custom exception for missing dependencies or tools."""

    pass


class VideoProcessingError(Exception):
    """Custom exception for errors during video processing tasks."""

    pass


def check_dependencies(config: Dict[str, Any]):
    """Check if required dependencies and FFmpeg encoders are installed."""
    missing_tools = []
    tool_paths = {}

    # Check if required tools are installed and find their paths
    for tool in REQUIRED_TOOLS:
        path = find_binary(tool, config)
        if path:
            tool_paths[tool] = path
        else:
            missing_tools.append(tool)

    if missing_tools:
        print_warning(
            f"The following required tools are missing or not found in config/PATH: {', '.join(missing_tools)}"
        )
        print_warning(
            "Please install them manually and ensure they are in your system's PATH or configured in ~/.config/dmx/config.json."
        )
        # Do not sys.exit here, let the caller decide (main function)
        raise DependencyError(f"Missing required tools: {', '.join(missing_tools)}")

    # Update config with found paths if they weren't specified
    for tool, path in tool_paths.items():
        config_key = f"{tool.upper()}_BIN"
        if config.get(config_key) is None:
            config[config_key] = path
            logger.info(f"Using discovered path for {tool}: {path}")

    # Check for available video encoders in FFmpeg
    ffmpeg_path = tool_paths.get("ffmpeg")
    if not ffmpeg_path:
        # This case should be caught by the missing_tools check, but double check
        raise DependencyError("FFmpeg path not determined.")

    try:
        # Update the list of supported encoders based on what's available
        global SUPPORTED_VIDEO_ENCODERS
        SUPPORTED_VIDEO_ENCODERS.clear()

        # Define preferred encoders and check availability
        preferred_encoders = ["libx264", "libx265", "libvpx-vp9", "libvpx"]
        for enc in preferred_encoders:
            if check_encoder_availability(enc, ffmpeg_path):
                SUPPORTED_VIDEO_ENCODERS.append(enc)

        if not SUPPORTED_VIDEO_ENCODERS:
            print_warning(
                "No supported video encoders (libx264, libx265, libvpx, libvpx-vp9) are available in FFmpeg."
            )
            print_warning(
                "Please install FFmpeg with the necessary encoders (e.g., --enable-libx264, --enable-libx265, --enable-libvpx) and try again."
            )
            raise DependencyError("No supported video encoders available.")
        else:
            logger.info(
                f"Supported video encoders: {', '.join(SUPPORTED_VIDEO_ENCODERS)}"
            )

    except DependencyError:
        raise  # Re-raise if encoder check fails critically
    except Exception as e:
        logger.error(f"Error checking FFmpeg encoders: {e}")
        print_warning(
            "An error occurred while checking FFmpeg encoders. Check the logs for more details."
        )
        raise DependencyError("Failed to check FFmpeg encoders.")

    # Check if VapourSynth module is available
    try:
        import vapoursynth as vs  # noqa: F401

        logger.info("VapourSynth module is available.")
    except ImportError:
        print_warning(
            "VapourSynth module ('vapoursynth') is not installed for Python. Please install it (e.g., using pip or your package manager) and try again."
        )
        raise DependencyError("VapourSynth Python module not found.")

    logger.info("All core dependencies are satisfied.")


def load_config() -> Dict[str, Any]:
    """Load the configuration from the config file."""
    config = DEFAULT_CONFIG.copy()  # Start with defaults
    try:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if CONFIG_FILE.exists():
            with CONFIG_FILE.open("r") as f:
                loaded_config = json.load(f)
                # Update defaults with loaded values
                config.update(loaded_config)
            logger.info(f"Loaded configuration from {CONFIG_FILE}")
        else:
            # Save default config if file doesn't exist
            save_config(config)
            logger.info(f"Created default configuration file at {CONFIG_FILE}")
            print_status(f"Created default configuration file at {CONFIG_FILE}", "INFO")

    except FileNotFoundError:
        logger.error(f"Config directory or file not found during load: {CONFIG_FILE}")
        print_warning("Config directory or file not found during load.")
    except json.JSONDecodeError:
        logger.error(f"Error decoding JSON from config file: {CONFIG_FILE}")
        print_warning(
            f"Error reading configuration file {CONFIG_FILE}. Is it valid JSON? Using default configuration."
        )
        config = DEFAULT_CONFIG.copy()  # Revert to defaults on error
    except Exception as e:
        logger.error(f"Error loading configuration: {e}")
        print_warning(
            "Failed to load configuration. Check logs for details. Using default configuration."
        )
        config = DEFAULT_CONFIG.copy()  # Revert to defaults on error

    # Ensure MAX_WORKERS is a positive integer
    try:
        config["MAX_WORKERS"] = int(config.get("MAX_WORKERS", MAX_WORKERS_DEFAULT))
        if config["MAX_WORKERS"] <= 0:
            config["MAX_WORKERS"] = MAX_WORKERS_DEFAULT
            logger.warning(
                f"Invalid MAX_WORKERS in config, resetting to default: {MAX_WORKERS_DEFAULT}"
            )
            print_warning(
                f"Invalid MAX_WORKERS in config, resetting to default: {MAX_WORKERS_DEFAULT}"
            )
    except ValueError:
        config["MAX_WORKERS"] = MAX_WORKERS_DEFAULT
        logger.warning(
            f"Invalid MAX_WORKERS in config, resetting to default: {MAX_WORKERS_DEFAULT}"
        )
        print_warning(
            f"Invalid MAX_WORKERS in config, resetting to default: {MAX_WORKERS_DEFAULT}"
        )

    return config


def save_config(config: Dict[str, Any]):
    """Save the configuration to the config file."""
    try:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)  # Ensure dir exists before saving
        # Only save keys that are different from default or are in default
        config_to_save = {
            k: v
            for k, v in config.items()
            if k in DEFAULT_CONFIG or v != DEFAULT_CONFIG.get(k)
        }
        with CONFIG_FILE.open("w") as f:
            json.dump(config_to_save, f, indent=4)
        logger.info(f"Configuration saved to {CONFIG_FILE}")
    except Exception as e:
        logger.error(f"Error saving configuration: {e}")
        print_warning("Failed to save configuration. Check logs for details.")


@dataclass
class VideoFile:
    filepath: Path  # Use Path object
    basename: str = field(init=False)
    width: int = 0
    height: int = 0
    has_audio: bool = False
    frame_rate: float = 0.0
    codec: str = ""
    audio_codec: str = ""
    duration: float = 0.0
    bitrate: int = 0
    issues: List[str] = field(
        default_factory=list
    )  # Use default_factory for mutable default

    def __post_init__(self):
        if not isinstance(self.filepath, Path):
            self.filepath = Path(self.filepath)
        self.basename = self.filepath.name
        self._get_properties()

    def _get_properties(self):
        """Extract properties using ffprobe."""
        if not self.filepath.exists():
            self.issues.append("File does not exist.")
            logger.error(
                f"Attempted to get properties for non-existent file: {self.filepath}"
            )
            return  # Cannot proceed if file doesn't exist

        ffprobe_path = find_binary(
            "ffprobe", load_config()
        )  # Load config dynamically or pass it
        if not ffprobe_path:
            self.issues.append("ffprobe not found.")
            logger.error("ffprobe not found, cannot get video properties.")
            return

        try:
            # Get video stream properties
            video_command = [
                ffprobe_path,
                "-v",
                "error",
                "-select_streams",
                "v:0",
                "-show_entries",
                "stream=width,height,r_frame_rate,codec_name,duration,bit_rate",
                "-of",
                "json",
                str(self.filepath),  # Pass Path as string to subprocess
            ]
            video_result_stdout = run_command(
                video_command,
                description=f"Getting video properties for {self.basename}",
                display_output=False,  # No need to display output for ffprobe
            )
            video_data = json.loads(video_result_stdout)
            video_stream = video_data.get("streams", [None])[0]

            if video_stream:
                self.width = int(video_stream.get("width", 0))
                self.height = int(video_stream.get("height", 0))
                self.codec = video_stream.get("codec_name", "")
                fps_str = video_stream.get("r_frame_rate", "0/1")
                try:
                    self.frame_rate = float(Fraction(fps_str))
                except (ValueError, ZeroDivisionError):
                    self.frame_rate = 0.0
                    self.issues.append(f"Could not parse frame rate: {fps_str}")

                # Duration and bitrate might be in format section, or stream section
                # Let's try stream first, then format
                self.duration = float(video_stream.get("duration", 0.0))
                self.bitrate = int(video_stream.get("bit_rate", 0))

                logger.info(
                    f"Video properties for {self.filepath}: {self.width}x{self.height}, {self.frame_rate:.2f}fps, codec={self.codec}"
                )
            else:
                self.issues.append("No video stream found.")
                logger.warning(f"No video stream found for {self.filepath}")

            # Get audio stream properties
            audio_command = [
                ffprobe_path,
                "-v",
                "error",
                "-select_streams",
                "a:0",
                "-show_entries",
                "stream=codec_name,duration,bit_rate",  # Also check audio duration/bitrate
                "-of",
                "json",
                str(self.filepath),
            ]
            audio_result_stdout = run_command(
                audio_command,
                description=f"Checking audio properties for {self.basename}",
                display_output=False,
            )
            audio_data = json.loads(audio_result_stdout)
            audio_stream = audio_data.get("streams", [None])[0]

            if audio_stream:
                self.has_audio = True
                self.audio_codec = audio_stream.get("codec_name", "")
                # Update duration/bitrate from audio if video stream didn't have it
                if self.duration == 0.0:
                    self.duration = float(audio_stream.get("duration", 0.0))
                if self.bitrate == 0:
                    self.bitrate = int(audio_stream.get("bit_rate", 0))

                logger.info(f"Audio codec for {self.filepath}: {self.audio_codec}")
            else:
                self.has_audio = False
                self.audio_codec = ""
                logger.info(f"No audio stream in {self.filepath}")

            # Get format properties (container duration/bitrate) if stream info was missing
            if self.duration == 0.0 or self.bitrate == 0:
                format_command = [
                    ffprobe_path,
                    "-v",
                    "error",
                    "-show_entries",
                    "format=duration,bit_rate",
                    "-of",
                    "json",
                    str(self.filepath),
                ]
                format_result_stdout = run_command(
                    format_command,
                    description=f"Checking format properties for {self.basename}",
                    display_output=False,
                )
                format_data = json.loads(format_result_stdout)
                format_info = format_data.get("format", {})
                if self.duration == 0.0:
                    self.duration = float(format_info.get("duration", 0.0))
                if self.bitrate == 0:
                    self.bitrate = int(format_info.get("bit_rate", 0))

        except (FileNotFoundError, DependencyError):
            self.issues.append("Required tool (ffprobe) not found.")
        except json.JSONDecodeError:
            self.issues.append("Failed to parse ffprobe output (invalid JSON).")
            logger.error(f"Failed to parse ffprobe output for {self.filepath}")
        except subprocess.CalledProcessError as e:
            self.issues.append(f"ffprobe command failed: {e.returncode}")
            logger.error(f"ffprobe command failed for {self.filepath}: {e}")
        except Exception as e:
            self.issues.append(f"Unexpected error getting properties: {e}")
            logger.error(
                f"Unexpected error getting properties for {self.filepath}: {e}"
            )

        # Add issues based on extracted properties
        if self.width == 0 or self.height == 0:
            self.issues.append("Resolution not detected.")
        if self.frame_rate == 0.0:
            self.issues.append("Frame rate not detected.")
        if self.codec and self.codec.lower() not in SUPPORTED_CODECS:
            self.issues.append(f"Unsupported codec: {self.codec}")
        if self.duration == 0.0:
            self.issues.append("Duration not detected.")
        # Bitrate check might be less critical, but could be added if needed

    def detect_issues(self, fix_issues: bool = False):
        """Detect potential issues with the video file."""
        logger.info(f"Detecting issues for video {self.filepath}")

        # Re-run property extraction to ensure issues list is fresh
        self.issues = []  # Clear existing issues
        self._get_properties()

        if self.issues:
            print_warning(f"Issues detected in {self.basename}:")
            for issue in self.issues:
                print_warning(f" - {issue}")

            if fix_issues:
                self.attempt_fix()
            else:
                fix = (
                    prompt(
                        f"Would you like to attempt to fix these issues for {self.basename}? (y/n): "
                    )
                    .strip()
                    .lower()
                )
                if fix == "y":
                    self.attempt_fix()
                else:
                    print_status(f"Skipping fix for {self.basename}.", "INFO")
        else:
            print_status(f"No issues detected in {self.basename}")

    def attempt_fix(self, output_dir: str = "."):
        """Attempt to fix detected issues in the video file by re-encoding."""
        logger.info(f"Attempting to fix issues for video {self.filepath}")

        output_path = Path(output_dir) / f"fixed_{self.basename}"
        # Ensure output directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        ffmpeg_path = find_binary("ffmpeg", load_config())
        if not ffmpeg_path:
            print_warning("ffmpeg binary not found. Cannot attempt fix.")
            return

        try:
            encoder = None
            # Find the first available supported encoder
            for enc in SUPPORTED_VIDEO_ENCODERS:
                if check_encoder_availability(enc, ffmpeg_path):
                    encoder = enc
                    break

            if encoder is None:
                print_warning("No suitable video encoder available to fix the video.")
                raise VideoProcessingError("No suitable video encoder available.")

            # Use estimated bitrate based on original resolution
            bitrate = estimate_bitrate(self.width, self.height)

            command = [
                ffmpeg_path,
                "-y",  # Overwrite output without asking
                "-i",
                str(self.filepath),
                "-c:v",
                encoder,
                "-preset",
                "fast",  # Use a reasonable preset
                "-b:v",
                bitrate,
            ]

            if encoder.startswith("libvpx"):
                command += [
                    "-pix_fmt",
                    "yuv420p",
                    "-deadline",
                    "good",
                ]  # VPx specific options

            # Handle audio: copy if present, or remove
            if self.has_audio:
                command += ["-c:a", "copy"]  # Attempt to copy audio
            else:
                command += ["-an"]  # No audio stream

            command += [str(output_path)]

            run_command(
                command,
                description=f"Fixing issues for {self.basename}",
                display_output=True,
            )

            # Update the VideoFile object to point to the new fixed file
            self.filepath = output_path.resolve()
            self.basename = self.filepath.name
            self.issues.clear()  # Clear issues as we attempted a fix
            self._get_properties()  # Re-get properties from the new file
            if not self.issues:  # Check if issues were actually resolved
                print_status(
                    f"Issues fixed for {self.basename}. Saved as {self.filepath}"
                )
                logger.info(f"Issues fixed successfully for {self.filepath}")
            else:
                print_warning(
                    f"Attempted to fix issues for {self.basename}, but new issues were detected or old ones persist."
                )
                logger.warning(
                    f"Fix attempt for {self.filepath} completed, but issues remain: {self.issues}"
                )

        except (
            subprocess.CalledProcessError,
            VideoProcessingError,
            DependencyError,
        ) as e:
            logger.error(f"Failed to fix issues for {self.basename}: {e}")
            print_warning(f"Failed to fix issues for {self.basename}")
            # Clean up potentially incomplete output file
            if output_path.exists():
                try:
                    output_path.unlink()
                    logger.info(f"Removed incomplete output file {output_path}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_path}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Error fixing issues for {self.basename}: {e}")
            print_warning(f"Unexpected error while fixing issues for {self.basename}")


class FFmpegCommandBuilder:
    """Helper class to build FFmpeg commands for various tasks."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.ffmpeg_path = find_binary("ffmpeg", self.config)
        if not self.ffmpeg_path:
            raise DependencyError("ffmpeg binary not found.")

    def _get_encoder(self) -> str:
        """Find the first available supported video encoder."""
        for enc in SUPPORTED_VIDEO_ENCODERS:
            if check_encoder_availability(enc, self.ffmpeg_path):
                return enc
        raise VideoProcessingError("No suitable video encoder available.")

    def build_adjust_resolution_command(
        self, video: VideoFile, resolution: str, output_file: Path
    ) -> List[str]:
        """Build FFmpeg command to adjust video resolution."""
        encoder = self._get_encoder()
        width, height = map(int, resolution.split("x"))
        bitrate = estimate_bitrate(width, height)
        filter_chain = combine_filters(f"scale={resolution}")

        command = [
            self.ffmpeg_path,
            "-y",
            "-i",
            str(video.filepath),
            "-vf",
            filter_chain,
            "-c:v",
            encoder,
            "-preset",
            "fast",
            "-b:v",
            bitrate,
        ]

        if encoder.startswith("libvpx"):
            command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

        if video.has_audio:
            command += ["-c:a", "copy"]
        else:
            command += ["-an"]

        command += [str(output_file)]
        return command

    def build_convert_format_command(
        self, video: VideoFile, new_format: str, output_file: Path
    ) -> List[str]:
        """Build FFmpeg command to convert video format."""
        # Using copy codec is fast but might fail if streams are incompatible.
        # A more robust approach might re-encode if copy fails, or allow user to choose.
        # For simplicity, sticking to copy for now.
        format_codecs = {
            "mp4": ["-c:v", "copy", "-c:a", "copy"],
            "mkv": ["-c:v", "copy", "-c:a", "copy"],
            "avi": [
                "-c:v",
                "libxvid",
                "-c:a",
                "libmp3lame",
            ],  # avi often needs re-encoding
            "mov": ["-c:v", "copy", "-c:a", "copy"],
            "webm": [
                "-c:v",
                "copy",
                "-c:a",
                "copy",
            ],  # webm typically needs vp9/opus/vorbis
        }

        codecs = format_codecs.get(new_format.lower())

        if not codecs:
            raise ValueError(f"Unsupported format: {new_format}")

        # Check if codecs are actually available if not 'copy'
        if "-c:v" in codecs and codecs[codecs.index("-c:v") + 1] != "copy":
            if not check_encoder_availability(
                codecs[codecs.index("-c:v") + 1], self.ffmpeg_path
            ):
                raise DependencyError(
                    f"Required video encoder '{codecs[codecs.index('-c:v') + 1]}' for {new_format} not available."
                )
        if "-c:a" in codecs and codecs[codecs.index("-c:a") + 1] != "copy":
            # Need a similar check for audio encoders
            pass  # Skipping audio encoder check for brevity in review example

        command = (
            [self.ffmpeg_path, "-y", "-i", str(video.filepath)]
            + codecs
            + [str(output_file)]
        )

        return command

    def build_filter_command(
        self, video: VideoFile, filters: str, output_file: Path
    ) -> List[str]:
        """Build FFmpeg command to apply filters to the video."""
        encoder = self._get_encoder()
        bitrate = estimate_bitrate(video.width, video.height)
        filter_chain = combine_filters(
            filters
        )  # combine_filters already handles splitting/stripping

        command = [
            self.ffmpeg_path,
            "-y",
            "-i",
            str(video.filepath),
            "-vf",
            filter_chain,
            "-c:v",
            encoder,
            "-preset",
            "fast",
            "-b:v",
            bitrate,
        ]

        if encoder.startswith("libvpx"):
            command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

        if video.has_audio:
            command += ["-c:a", "copy"]
        else:
            command += ["-an"]

        command += [str(output_file)]
        return command


class VideoProcessor:
    """Processes video files based on user commands."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.ffmpeg_path = find_binary("ffmpeg", self.config)
        self.ffprobe_path = find_binary("ffprobe", self.config)
        self.vspipe_path = find_binary("vspipe", self.config)

        if not self.ffmpeg_path or not self.ffprobe_path or not self.vspipe_path:
            # Dependency check in main should catch this, but good to be safe
            raise DependencyError(
                "Required binaries (ffmpeg, ffprobe, vspipe) not found."
            )

        self.ffmpeg_builder = FFmpegCommandBuilder(config)

        max_workers = self.config.get("MAX_WORKERS", MAX_WORKERS_DEFAULT)
        # Ensure max_workers is valid
        try:
            max_workers = int(max_workers)
            if max_workers <= 0:
                max_workers = MAX_WORKERS_DEFAULT
                logger.warning(
                    f"Invalid MAX_WORKERS config value, using default: {max_workers}"
                )
        except ValueError:
            max_workers = MAX_WORKERS_DEFAULT
            logger.warning(
                f"Invalid MAX_WORKERS config value, using default: {max_workers}"
            )

        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        logger.info(f"Initialized ThreadPoolExecutor with {max_workers} workers.")

        # VapourSynth plugin paths - rely on environment variable or standard paths
        self.vs_plugin_paths = os.environ.get("VAPOURSYNTH_PLUGIN_PATH", "").split(
            os.pathsep
        )
        self.vs_plugin_paths.extend(
            [
                "/usr/lib/vapoursynth",
                "/usr/local/lib/vapoursynth",
                # Add other paths from config if needed
            ]
        )
        self.vs_plugin_paths = [
            p for p in self.vs_plugin_paths if p
        ]  # Remove empty paths

        # Check for specific plugins needed for VapourSynth transformations
        self.required_vs_plugins = {
            "ffms2": "ffms2.so",
            "svpflow1": "svpflow1.so",
            "svpflow2": "svpflow2.so",
            "vivtc": "libvivtc.so",  # For IVTC
            "nnedi3": "libnnedi3.so",  # For Dedot, Super Resolution
            "rgvs": "librgvs.so",  # For Remove Grain
            "f3kdb": "libf3kdb.so",  # For Debanding
            "awarpsharp2": "libawarpsharp2.so",  # For Sharpening
            "adjust": "libadjust.so",  # For Color Correction
            "stabilize": "libstabilize.so",  # For Deshake/Stabilization
            "edge_detect": "libedge_detect.so",  # For Edge Detection
            "dehalo": "libdehalo_alpha.so",  # For Dehalo (example plugin name)
            # Add other plugins as needed
        }
        self.available_vs_plugins = {
            name: self._find_vs_plugin(filename)
            for name, filename in self.required_vs_plugins.items()
        }
        # Filter out plugins that weren't found
        self.available_vs_plugins = {
            k: v for k, v in self.available_vs_plugins.items() if v is not None
        }

        missing_vs_plugins = [
            name
            for name, filename in self.required_vs_plugins.items()
            if name not in self.available_vs_plugins
        ]
        if missing_vs_plugins:
            logger.warning(
                f"Some VapourSynth plugins not found: {', '.join(missing_vs_plugins)}. Related transformations may not work."
            )
            print_warning(
                f"Some VapourSynth plugins not found: {', '.join(missing_vs_plugins)}. Related transformations may not work."
            )

    def _find_vs_plugin(self, plugin_filename: str) -> Optional[Path]:
        """Locate a VapourSynth plugin file."""
        for path_str in self.vs_plugin_paths:
            plugin_path = Path(path_str) / plugin_filename
            if plugin_path.exists():
                return plugin_path.resolve()
        return None

    def validate_resolution_format(self, resolution: str) -> bool:
        """Validate the resolution format (WIDTHxHEIGHT)."""
        pattern = r"^\d+x\d+$"
        return re.match(pattern, resolution) is not None

    def apply_vapoursynth_script(
        self, video: VideoFile, output_file: Path, script_content: str
    ):
        """Apply a VapourSynth script to a video using vspipe and FFmpeg."""
        if not self.vspipe_path or not self.ffmpeg_path:
            raise DependencyError("vspipe or ffmpeg binary not found.")

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        script_file_name = None
        try:
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".vpy", delete=False, encoding="utf-8"
            ) as script_file:
                script_file_name = script_file.name
                script_file.write(script_content)
                script_file.flush()
                logger.debug(
                    f"Created temporary VapourSynth script: {script_file_name}"
                )
                logger.debug(f"Script content:\n{script_content}")

            command_vspipe = [
                self.vspipe_path,
                "-c",
                "y4m",  # Output YUV4MPEG stream
                str(script_file_name),
                "-",  # Output to stdout
            ]

            encoder = (
                self.ffmpeg_builder._get_encoder()
            )  # Use the builder's encoder logic
            bitrate = estimate_bitrate(
                video.width, video.height
            )  # Estimate based on original resolution

            ffmpeg_command = [
                self.ffmpeg_path,
                "-y",  # Overwrite output
                "-f",
                "yuv4mpegpipe",  # Input format is YUV4MPEG stream from pipe
                "-i",
                "-",  # Input from stdin
                "-c:v",
                encoder,
                "-b:v",
                bitrate,
                "-preset",
                "fast",  # Use a reasonable preset
            ]

            if encoder.startswith("libvpx"):
                ffmpeg_command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

            # Handle audio: merge original audio if present
            if video.has_audio:
                ffmpeg_command += [
                    "-i",
                    str(video.filepath),  # Input original video again for audio
                    "-map",
                    "0:v:0",  # Map video from the pipe (input 0)
                    "-map",
                    "1:a:0",  # Map audio from the original video (input 1)
                    "-c:a",
                    "copy",  # Copy audio stream
                ]
            else:
                ffmpeg_command += ["-an"]  # No audio

            ffmpeg_command += [str(output_file)]

            logger.info(
                f"Running VapourSynth script and FFmpeg pipeline for {video.basename}"
            )
            print_status(
                f"Applying VapourSynth transformation to {video.basename}...", "INFO"
            )

            # Use Popen pipeline
            vspipe_proc = None
            ffmpeg_proc = None
            try:
                vspipe_proc = subprocess.Popen(
                    command_vspipe,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,  # Capture stderr separately for vspipe errors
                    text=True,
                    encoding="utf-8",
                    errors="replace",
                )
                ffmpeg_proc = subprocess.Popen(
                    ffmpeg_command,
                    stdin=vspipe_proc.stdout,
                    stdout=subprocess.PIPE,  # Capture ffmpeg output for logging
                    stderr=subprocess.PIPE,  # Capture ffmpeg errors
                    text=True,
                    encoding="utf-8",
                    errors="replace",
                )
                # Allow vspipe_proc.stdout to be read by ffmpeg_proc
                vspipe_proc.stdout.close()

                # Wait for both processes to finish and capture their output
                ffmpeg_stdout, ffmpeg_stderr = ffmpeg_proc.communicate()
                vspipe_stdout, vspipe_stderr = (
                    vspipe_proc.communicate()
                )  # Should be empty if stdout piped

                logger.debug(f"vspipe stdout:\n{vspipe_stdout}")
                logger.debug(f"vspipe stderr:\n{vspipe_stderr}")
                logger.debug(f"ffmpeg stdout:\n{ffmpeg_stdout}")
                logger.debug(f"ffmpeg stderr:\n{ffmpeg_stderr}")

                if vspipe_proc.returncode != 0:
                    error_msg = (
                        f"vspipe failed with exit code {vspipe_proc.returncode}."
                    )
                    if vspipe_stderr:
                        error_msg += f"\nStderr:\n{vspipe_stderr}"
                    logger.error(error_msg)
                    raise subprocess.CalledProcessError(
                        vspipe_proc.returncode,
                        command_vspipe,
                        stdout=vspipe_stdout,
                        stderr=vspipe_stderr,
                    )

                if ffmpeg_proc.returncode != 0:
                    error_msg = (
                        f"ffmpeg failed with exit code {ffmpeg_proc.returncode}."
                    )
                    if ffmpeg_stderr:
                        error_msg += f"\nStderr:\n{ffmpeg_stderr}"
                    logger.error(error_msg)
                    raise subprocess.CalledProcessError(
                        ffmpeg_proc.returncode,
                        ffmpeg_command,
                        stdout=ffmpeg_stdout,
                        stderr=ffmpeg_stderr,
                    )

            finally:
                # Ensure processes are terminated if something goes wrong
                if vspipe_proc and vspipe_proc.poll() is None:
                    vspipe_proc.terminate()
                if ffmpeg_proc and ffmpeg_proc.poll() is None:
                    ffmpeg_proc.terminate()

            print_status(
                f"Transformation applied to {video.basename}. Saved as {output_file}"
            )
            logger.info(
                f"VapourSynth transformation applied successfully to {video.filepath}"
            )
        except (FileNotFoundError, DependencyError):
            print_warning(
                "Required binary (vspipe or ffmpeg) not found. Cannot apply VapourSynth script."
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                    logger.info(f"Removed incomplete output file {output_file}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except subprocess.CalledProcessError:
            print_warning(
                f"VapourSynth pipeline failed for {video.basename}. Check logs for details."
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                    logger.info(f"Removed incomplete output file {output_file}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Error applying VapourSynth script to {video.filepath}: {e}")
            print_warning(f"Failed to apply transformation to {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                    logger.info(f"Removed incomplete output file {output_file}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        finally:
            if script_file_name and Path(script_file_name).exists():
                try:
                    Path(script_file_name).unlink()
                    logger.info(f"Temporary script file {script_file_name} deleted.")
                except Exception as e:
                    logger.warning(
                        f"Could not delete temporary script file {script_file_name}: {e}"
                    )

    def analyze_video(self, video: VideoFile):
        """Analyze a video file using FFmpeg."""
        logger.info(f"Analyzing video {video.filepath}")
        try:
            command = [self.ffmpeg_path, "-i", str(video.filepath)]
            # FFmpeg's -i output goes to stderr, so display_output is good here
            run_command(
                command,
                description=f"Analyzing video {video.basename}",
                display_output=True,
            )
        except (FileNotFoundError, DependencyError):
            print_warning("ffmpeg binary not found. Cannot analyze video.")
        except subprocess.CalledProcessError:
            print_warning(
                f"Failed to analyze video {video.basename}. Check logs for details."
            )
        except Exception as e:
            logger.error(f"Error analyzing video {video.filepath}: {e}")
            print_warning(
                f"Failed to analyze video {video.basename}. Check logs for details."
            )

    def normalize_videos(self, videos: List[VideoFile], output_dir: Path) -> List[Path]:
        """Normalize a list of videos to common properties."""
        logger.info("Starting normalization of videos")

        if not videos:
            print_warning("No videos provided for normalization.")
            return []

        output_dir.mkdir(parents=True, exist_ok=True)

        target_props = self.determine_common_properties(videos)
        normalized_files = []
        futures = []

        for video in videos:
            futures.append(
                self.executor.submit(
                    self._normalize_video, video, target_props, output_dir
                )
            )

        # Use tqdm to show progress for the futures
        for future in tqdm(futures, desc="Normalizing videos", unit="video"):
            try:
                # Use a timeout for each task, adjust as needed
                result = future.result(timeout=7200)  # 2 hour timeout per video
                if result:
                    normalized_files.append(result)
            except TimeoutError:
                logger.error("Normalization task timed out.")
                print_warning("A normalization task timed out. Check logs for details.")
            except Exception as e:
                logger.error(f"Error during normalization: {e}")
                print_warning(f"An error occurred during normalization: {e}")

        return normalized_files

    def _normalize_video(
        self, video: VideoFile, target_props: Dict[str, Any], output_dir: Path
    ) -> Optional[Path]:
        """Normalize a single video to target properties."""
        output_path = (
            output_dir / f"normalized_{video.filepath.stem}{video.filepath.suffix}"
        )

        # Check if output file already exists and skip if desired (optional)
        # if output_path.exists():
        #     logger.info(f"Normalized file already exists for {video.basename}, skipping: {output_path}")
        #     print_status(f"Normalized file already exists for {video.basename}, skipping.", "INFO")
        #     return output_path

        need_reencode = (
            (video.width, video.height) != target_props["resolution"]
            or abs(video.frame_rate - target_props["frame_rate"])
            > 0.001  # Use a small tolerance for float comparison
            or video.codec.lower()
            not in SUPPORTED_CODECS  # Re-encode if codec is unsupported
        )

        try:
            if not need_reencode:
                logger.info(
                    f"{video.basename} matches target properties, copying streams"
                )
                command = [
                    self.ffmpeg_path,
                    "-y",
                    "-i",
                    str(video.filepath),
                ]
                # Use map to ensure correct streams are copied
                command += ["-map", "0:v:0"]  # Map first video stream
                if video.has_audio:
                    command += [
                        "-map",
                        "0:a:0",
                        "-c",
                        "copy",
                    ]  # Map first audio stream and copy all
                else:
                    command += ["-an", "-c:v", "copy"]  # No audio, copy video

                command += [str(output_path)]
            else:
                logger.info(f"Re-encoding {video.basename} to match target properties")
                resolution_str = (
                    f"{target_props['resolution'][0]}x{target_props['resolution'][1]}"
                )
                # Use the builder for the base command
                command = self.ffmpeg_builder.build_adjust_resolution_command(
                    video, resolution_str, output_path
                )

                # Add FPS filter if needed
                if abs(video.frame_rate - target_props["frame_rate"]) > 0.001:
                    target_fps = round_frame_rate(
                        target_props["frame_rate"], 3
                    )  # Use slightly higher precision for FPS
                    # Find the existing -vf argument and append to it
                    try:
                        vf_index = command.index("-vf")
                        existing_vf = command[vf_index + 1]
                        combined_vf = combine_filters(existing_vf, f"fps={target_fps}")
                        command[vf_index + 1] = combined_vf
                    except ValueError:
                        # Should not happen if build_adjust_resolution_command is used, but as a fallback
                        command.extend(["-vf", f"fps={target_fps}"])

            run_command(
                command,
                description=f"Normalizing video {video.basename}",
                display_output=True,
            )
            logger.info(f"Normalization complete for {video.basename}")
            # print_status is called by run_command
            return output_path
        except (
            subprocess.CalledProcessError,
            VideoProcessingError,
            DependencyError,
        ) as e:
            logger.error(f"Error normalizing video {video.basename}: {e}")
            print_warning(
                f"Error normalizing video {video.basename}. Check logs for details."
            )
            # Clean up incomplete output file
            if output_path.exists():
                try:
                    output_path.unlink()
                    logger.info(f"Removed incomplete output file {output_path}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_path}: {unlink_e}"
                    )
            return None
        except Exception as e:
            logger.error(f"Unexpected error normalizing video {video.basename}: {e}")
            print_warning(
                f"Unexpected error normalizing video {video.basename}. Check logs for details."
            )
            # Clean up incomplete output file
            if output_path.exists():
                try:
                    output_path.unlink()
                    logger.info(f"Removed incomplete output file {output_path}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_path}: {unlink_e}"
                    )
            return None

    def determine_common_properties(self, videos: List[VideoFile]) -> Dict[str, Any]:
        """Determine the most common resolution and frame rate across a list of videos."""
        logger.info("Determining common properties for normalization")

        if not videos:
            return {"resolution": (0, 0), "frame_rate": 0.0}

        resolutions = [
            (video.width, video.height)
            for video in videos
            if video.width > 0 and video.height > 0
        ]
        # Use rounded frame rates for counting to group similar FPS
        frame_rates = [
            round_frame_rate(video.frame_rate, 2)
            for video in videos
            if video.frame_rate > 0
        ]

        # Handle cases where no valid resolutions or frame rates are found
        target_resolution = (0, 0)
        if resolutions:
            target_resolution = max(set(resolutions), key=resolutions.count)

        target_frame_rate = 0.0
        if frame_rates:
            target_frame_rate = max(set(frame_rates), key=frame_rates.count)

        logger.info(
            f"Target resolution: {target_resolution}, frame rate: {target_frame_rate}"
        )

        return {"resolution": target_resolution, "frame_rate": target_frame_rate}

    def change_speed(
        self,
        video: VideoFile,
        output_file: Path,
        speed_factor: float,
        smooth_motion: bool = False,
    ):
        """Change the speed of a video with optional smooth motion interpolation."""
        logger.info(f"Changing speed of {video.filepath} by factor {speed_factor}")

        if speed_factor <= 0:
            print_warning("Speed factor must be greater than 0.")
            return

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        try:
            if smooth_motion:
                # Check for required SVPflow plugins
                if (
                    "svpflow1" not in self.available_vs_plugins
                    or "svpflow2" not in self.available_vs_plugins
                    or "ffms2" not in self.available_vs_plugins
                ):
                    print_warning(
                        "Required VapourSynth plugins (svpflow1, svpflow2, ffms2) not found for smooth motion."
                    )
                    print_warning("Falling back to FFmpeg's setpts/atempo method.")
                    smooth_motion = (
                        False  # Disable smooth motion if plugins are missing
                    )
                else:
                    # Calculate target FPS for smooth motion
                    # To play at speed_factor, we need 1/speed_factor times the frames
                    # If original is 30fps, speed 0.5 (slow-mo) means we need 60fps to play at 30fps speed
                    # If original is 30fps, speed 2.0 (fast-mo) means we need 15fps to play at 30fps speed
                    # The SVPflow script interpolates to a higher FPS for smoother playback at the original FPS,
                    # and then FFmpeg's setpts/atempo is applied after VapourSynth.
                    # Let's stick to the FFmpeg method for speed change and use VapourSynth only for FRC if needed?
                    # The current implementation applies SVPflow then FFmpeg setpts/atempo.
                    # This means SVPflow interpolates to target_fps, and then FFmpeg changes the speed of that interpolated stream.
                    # This seems overly complex and potentially incorrect.
                    # A simpler approach:
                    # 1. Use VapourSynth only for Frame Rate Conversion (e.g., 30fps -> 60fps) if smooth_motion is true.
                    # 2. Use FFmpeg's setpts/atempo on the result of step 1 (or the original video if smooth_motion is false).

                    # Let's revise: smooth_motion implies using VapourSynth FRC to a higher FPS (e.g., 60), then apply FFmpeg speed change.
                    # If not smooth_motion, just use FFmpeg setpts/atempo.

                    # Option 1: VapourSynth for FRC, then FFmpeg for speed (more complex pipeline)
                    # Option 2: VapourSynth for FRC and speed change (if possible with plugins), or just use FFmpeg.
                    # Option 3: Keep current structure, but fix the SVPflow script logic and clarify its purpose.

                    # Let's refine Option 3: Use SVPflow to interpolate to a higher frame rate (e.g., 60 or 120), then use FFmpeg's setpts/atempo.
                    # The SVPflow script provided seems to target target_fps * 1000 / 1000, which simplifies to target_fps.
                    # If target_fps is calculated as video.frame_rate  (1 / speed_factor), this is the output* frame rate, not the intermediate FRC rate.
                    # The SVPflow example script in the original code targets fps={target_fps} where target_fps was calculated as video.frame_rate  (1 / speed_factor). This is incorrect for smooth motion interpolation before* speed change.
                    # For smooth motion, you typically interpolate to a multiple of the original FPS (e.g., 2x, 4x) or a fixed high rate (60, 120), then change speed.

                    # Let's simplify: If smooth_motion, use VapourSynth to interpolate to 60fps (or 120fps if original is high), then apply FFmpeg speed change.
                    # If not smooth_motion, just use FFmpeg setpts/atempo.

                    # Determine the intermediate FRC target FPS
                    intermediate_fps = 60.0  # Default target for FRC
                    if video.frame_rate > 30 and video.frame_rate <= 60:
                        intermediate_fps = (
                            120.0  # Go higher if source is already high FPS
                        )

                    script_content = textwrap.dedent(
                        f"""
                    import vapoursynth as vs
                    core = vs.core
                    # Ensure plugins are loaded using their found paths
                    core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow1"]}")
                    core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow2"]}")
                    core.std.LoadPlugin(r"{self.available_vs_plugins["ffms2"]}")
                    clip = core.ffms2.Source(r"{str(video.filepath)}")
                    # Ensure clip is in a compatible format if needed, e.g., 8-bit YUV420P
                    # clip = core.resize.Spline36(clip, format=vs.YUV420P8) # Example conversion

                    super_params = dict(pel=2)
                    analyse_params = dict(main=dict(search=dict(coarse=dict(distance=-6))))
                    # Target the intermediate FPS for interpolation
                    smoothfps_params = dict(fpsnum=int({intermediate_fps} * 1000), fpsden=1000)
                    super_clip = core.svp2.Super(clip, levels=super_params)
                    vectors = core.svp2.Analyse(super_clip, clip, analyse_params=analyse_params)
                    # Use SmoothFps to interpolate to the intermediate_fps
                    smooth_clip = core.svp2.SmoothFps(clip, super_clip, vectors, smoothfps_params, src=clip, fps={intermediate_fps})
                    smooth_clip.set_output()
                    """
                    )
                    # Apply VapourSynth FRC, output goes to a temp file or pipe
                    # Let's modify apply_vapoursynth_script to output to a pipe that FFmpeg reads
                    # This requires a more complex Popen setup than the current one.
                    # The current apply_vapoursynth_script already does this pipe setup.
                    # So the flow is: vspipe(script) -> pipe -> ffmpeg(speed change) -> output_file

                    # The FFmpeg command will read the interpolated stream from the pipe
                    # and apply the setpts/atempo filters.
                    pts_multiplier = 1 / speed_factor
                    setpts_filter = f"setpts={pts_multiplier}*PTS"
                    atempo_filters = []
                    remaining_speed = (
                        speed_factor if speed_factor > 1 else 1 / speed_factor
                    )
                    while remaining_speed > 2.0:
                        atempo_filters.append("atempo=2.0")
                        remaining_speed /= 2.0
                    while remaining_speed < 0.5:
                        atempo_filters.append("atempo=0.5")
                        remaining_speed *= 2.0
                    atempo_filters.append(f"atempo={remaining_speed}")
                    atempo_filter = ",".join(atempo_filters)

                    # Build the FFmpeg command that reads from the pipe (input 0)
                    # and applies the speed filters.
                    ffmpeg_command = [
                        self.ffmpeg_path,
                        "-y",
                        "-f",
                        "yuv4mpegpipe",  # Input format from vspipe
                        "-i",
                        "-",  # Input from stdin (the pipe)
                        "-i",
                        str(video.filepath),  # Input original video for audio (input 1)
                        "-filter_complex",
                        f"[0:v]{setpts_filter}[v];[1:a]{atempo_filter}[a]",  # Apply filters to piped video and original audio
                        "-map",
                        "[v]",  # Map filtered video
                        "-map",
                        "[a]",  # Map filtered audio
                        "-c:v",
                        self.ffmpeg_builder._get_encoder(),  # Re-encode video after filtering
                        "-b:v",
                        estimate_bitrate(video.width, video.height),
                        "-preset",
                        "fast",
                        "-c:a",
                        "aac",  # Re-encode audio after atempo
                        "-b:a",
                        "256k",
                        str(output_file),
                    ]

                    # Need a dedicated function to run vspipe -> ffmpeg pipeline with specific ffmpeg args
                    self._run_vspipe_ffmpeg_pipeline(
                        video, script_content, ffmpeg_command, output_file
                    )

            if not smooth_motion:  # Use FFmpeg only
                pts_multiplier = 1 / speed_factor
                setpts_filter = f"setpts={pts_multiplier}*PTS"
                atempo_filters = []
                remaining_speed = speed_factor if speed_factor > 1 else 1 / speed_factor
                while remaining_speed > 2.0:
                    atempo_filters.append("atempo=2.0")
                    remaining_speed /= 2.0
                while remaining_speed < 0.5:
                    atempo_filters.append("atempo=0.5")
                    remaining_speed *= 2.0
                atempo_filters.append(f"atempo={remaining_speed}")
                atempo_filter = ",".join(atempo_filters)

                # Use filter_complex for both video and audio filters
                filter_complex = f"[0:v]{setpts_filter}[v]"
                if video.has_audio:
                    filter_complex += f";[0:a]{atempo_filter}[a]"

                command = [
                    self.ffmpeg_path,
                    "-y",
                    "-i",
                    str(video.filepath),
                    "-filter_complex",
                    filter_complex,
                    "-map",
                    "[v]",  # Map filtered video stream
                ]
                if video.has_audio:
                    command += ["-map", "[a]"]  # Map filtered audio stream
                else:
                    command += ["-an"]

                # Re-encode video and audio after filtering
                command += [
                    "-c:v",
                    self.ffmpeg_builder._get_encoder(),
                    "-b:v",
                    estimate_bitrate(video.width, video.height),
                    "-preset",
                    "fast",
                ]
                if video.has_audio:
                    command += [
                        "-c:a",
                        "aac",
                        "-b:a",
                        "256k",
                    ]  # atempo requires audio re-encoding

                command += [str(output_file)]
                run_command(
                    command,
                    description=f"Changing speed of {video.basename}",
                    display_output=True,
                )
                print_status(
                    f"Speed changed for {video.basename}. Saved as {output_file}"
                )

        except (
            subprocess.CalledProcessError,
            VideoProcessingError,
            DependencyError,
        ) as e:
            logger.error(f"Error changing speed of {video.filepath}: {e}")
            print_warning(f"Failed to change speed for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                    logger.info(f"Removed incomplete output file {output_file}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Unexpected error changing speed of {video.filepath}: {e}")
            print_warning(f"Unexpected error changing speed for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                    logger.info(f"Removed incomplete output file {output_file}")
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def _run_vspipe_ffmpeg_pipeline(
        self,
        video: VideoFile,
        script_content: str,
        ffmpeg_command: List[str],
        output_file: Path,
    ):
        """Helper to run the vspipe -> ffmpeg pipeline."""
        script_file_name = None
        try:
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".vpy", delete=False, encoding="utf-8"
            ) as script_file:
                script_file_name = script_file.name
                script_file.write(script_content)
                script_file.flush()
                logger.debug(
                    f"Created temporary VapourSynth script: {script_file_name}"
                )
                logger.debug(f"Script content:\n{script_content}")

            command_vspipe = [
                self.vspipe_path,
                "-c",
                "y4m",
                str(script_file_name),
                "-",
            ]

            logger.info(f"Running VapourSynth pipeline for {video.basename}")
            print_status(
                f"Applying VapourSynth transformation to {video.basename}...", "INFO"
            )

            vspipe_proc = None
            ffmpeg_proc = None
            try:
                vspipe_proc = subprocess.Popen(
                    command_vspipe,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    encoding="utf-8",
                    errors="replace",
                )
                ffmpeg_proc = subprocess.Popen(
                    ffmpeg_command,
                    stdin=vspipe_proc.stdout,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    encoding="utf-8",
                    errors="replace",
                )
                vspipe_proc.stdout.close()  # Allow vspipe_proc.stdout to receive a SIGPIPE if ffmpeg exits early

                # Stream FFmpeg output for user feedback
                # This part is tricky with capturing full output on error.
                # A simpler approach for logging might be to capture all output
                # and print it only on error, or log it at DEBUG level.
                # For now, let's just wait and check return codes, logging captured output.
                ffmpeg_stdout, ffmpeg_stderr = ffmpeg_proc.communicate()
                vspipe_stdout, vspipe_stderr = vspipe_proc.communicate()

                logger.debug(f"vspipe stdout:\n{vspipe_stdout}")
                logger.debug(f"vspipe stderr:\n{vspipe_stderr}")
                logger.debug(f"ffmpeg stdout:\n{ffmpeg_stdout}")
                logger.debug(f"ffmpeg stderr:\n{ffmpeg_stderr}")

                if vspipe_proc.returncode != 0:
                    error_msg = (
                        f"vspipe failed with exit code {vspipe_proc.returncode}."
                    )
                    if vspipe_stderr:
                        error_msg += f"\nStderr:\n{vspipe_stderr}"
                    raise subprocess.CalledProcessError(
                        vspipe_proc.returncode,
                        command_vspipe,
                        stdout=vspipe_stdout,
                        stderr=vspipe_stderr,
                    )

                if ffmpeg_proc.returncode != 0:
                    error_msg = (
                        f"ffmpeg failed with exit code {ffmpeg_proc.returncode}."
                    )
                    if ffmpeg_stderr:
                        error_msg += f"\nStderr:\n{ffmpeg_stderr}"
                    raise subprocess.CalledProcessError(
                        ffmpeg_proc.returncode,
                        ffmpeg_command,
                        stdout=ffmpeg_stdout,
                        stderr=ffmpeg_stderr,
                    )

            finally:
                if vspipe_proc and vspipe_proc.poll() is None:
                    vspipe_proc.terminate()
                if ffmpeg_proc and ffmpeg_proc.poll() is None:
                    ffmpeg_proc.terminate()

            print_status(
                f"VapourSynth pipeline completed. Saved as {output_file}", "OK"
            )

        except (FileNotFoundError, DependencyError):
            print_warning(
                "Required binary (vspipe or ffmpeg) not found. Cannot run pipeline."
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
            raise VideoProcessingError(
                "Required binary not found for VapourSynth pipeline."
            )
        except subprocess.CalledProcessError as e:
            logger.error(f"VapourSynth pipeline failed for {video.basename}: {e}")
            print_warning(
                f"VapourSynth pipeline failed for {video.basename}. Check logs for details."
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
            raise VideoProcessingError(f"VapourSynth pipeline failed: {e}")
        except Exception as e:
            logger.error(
                f"Unexpected error in VapourSynth pipeline for {video.filepath}: {e}"
            )
            print_warning(
                f"Unexpected error in VapourSynth pipeline for {video.basename}"
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
            raise VideoProcessingError(f"Unexpected error in VapourSynth pipeline: {e}")
        finally:
            if script_file_name and Path(script_file_name).exists():
                try:
                    Path(script_file_name).unlink()
                    logger.info(f"Temporary script file {script_file_name} deleted.")
                except Exception as e:
                    logger.warning(
                        f"Could not delete temporary script file {script_file_name}: {e}"
                    )

    def adjust_resolution(self, video: VideoFile, output_file: Path, resolution: str):
        """Adjust the resolution of a video."""
        logger.info(f"Adjusting resolution of {video.filepath} to {resolution}")
        try:
            if not self.validate_resolution_format(resolution):
                print_warning(
                    "Invalid resolution format. Please use WIDTHxHEIGHT (e.g., 1920x1080)."
                )
                return

            # Ensure output directory exists
            output_file.parent.mkdir(parents=True, exist_ok=True)

            command = self.ffmpeg_builder.build_adjust_resolution_command(
                video, resolution, output_file
            )
            run_command(
                command,
                description=f"Adjusting resolution for {video.basename}",
                display_output=True,
            )

            print_status(
                f"Resolution adjusted for {video.basename}. Saved as {output_file}"
            )
            logger.info(f"Resolution adjusted successfully for {video.filepath}")
        except (
            subprocess.CalledProcessError,
            VideoProcessingError,
            DependencyError,
        ) as e:
            logger.error(f"Error adjusting resolution of {video.filepath}: {e}")
            print_warning(f"Failed to adjust resolution for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(
                f"Unexpected error adjusting resolution of {video.filepath}: {e}"
            )
            print_warning(f"Unexpected error adjusting resolution for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def convert_video_format(
        self, video: VideoFile, output_file: Path, new_format: str
    ):
        """Convert the video format to a different container."""
        logger.info(f"Converting format of {video.filepath} to {new_format}")
        try:
            # Ensure output directory exists
            output_file.parent.mkdir(parents=True, exist_ok=True)

            command = self.ffmpeg_builder.build_convert_format_command(
                video, new_format, output_file
            )

            run_command(
                command,
                description=f"Converting format for {video.basename}",
                display_output=True,
            )
            print_status(
                f"Format conversion completed for {video.basename}. Saved as {output_file}"
            )
            logger.info(f"Format conversion successful for {video.filepath}")
        except (ValueError, DependencyError) as ve:
            logger.error(
                f"Invalid format or missing codec specified for {video.filepath}: {ve}"
            )
            print_warning(str(ve))
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except subprocess.CalledProcessError as e:
            logger.error(
                f"FFmpeg failed during format conversion of {video.filepath}: {e}"
            )
            print_warning(
                f"Failed to convert format for {video.basename}. Check logs for details."
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Unexpected error converting format of {video.filepath}: {e}")
            print_warning(f"Unexpected error converting format for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def apply_filters(self, video: VideoFile, output_file: Path, filters: str):
        """Apply a set of filters to the video."""
        logger.info(f"Applying filters to {video.filepath}: {filters}")
        try:
            # Ensure output directory exists
            output_file.parent.mkdir(parents=True, exist_ok=True)

            command = self.ffmpeg_builder.build_filter_command(
                video, filters, output_file
            )

            run_command(
                command,
                description=f"Applying filters to {video.basename}",
                display_output=True,
            )
            print_status(f"Filters applied to {video.basename}. Saved as {output_file}")
            logger.info(f"Filters applied successfully to {video.filepath}")
        except (
            subprocess.CalledProcessError,
            VideoProcessingError,
            DependencyError,
        ) as e:
            logger.error(f"Error applying filters to {video.filepath}: {e}")
            print_warning(f"Failed to apply filters to {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Unexpected error applying filters to {video.filepath}: {e}")
            print_warning(f"Unexpected error applying filters to {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def extract_frames(self, video: VideoFile, output_dir: Path):
        """Extract frames from the video at 1 frame per second and save them as images."""
        logger.info(f"Extracting frames from {video.filepath}")
        try:
            output_dir.mkdir(parents=True, exist_ok=True)
            logger.info(f"Output directory set to {output_dir}")

            # Use -vsync vfr for variable frame rate output (recommended with fps filter)
            command = [
                self.ffmpeg_path,
                "-y",
                "-i",
                str(video.filepath),
                "-vf",
                "fps=1",
                "-vsync",
                "vfr",
                str(output_dir / "frame_%04d.png"),
            ]

            run_command(
                command,
                description=f"Extracting frames from {video.basename}",
                display_output=True,
            )
            print_status(
                f"Frames extracted from {video.basename}. Saved in {output_dir}"
            )
            logger.info(f"Frame extraction completed for {video.filepath}")
        except (subprocess.CalledProcessError, DependencyError) as e:
            logger.error(f"Error extracting frames from {video.filepath}: {e}")
            print_warning(f"Failed to extract frames from {video.basename}")
        except Exception as e:
            logger.error(
                f"Unexpected error extracting frames from {video.filepath}: {e}"
            )
            print_warning(f"Unexpected error extracting frames from {video.basename}")

    def concatenate_videos(self, videos: List[VideoFile], output_file: Path):
        """Concatenate multiple video files using FFmpeg."""
        logger.info("Starting video concatenation process")

        if not videos:
            print_warning("No videos provided for concatenation.")
            return

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        # Normalize videos first to ensure compatibility
        normalized_files = self.normalize_videos(videos, output_file.parent)
        if not normalized_files or len(normalized_files) != len(videos):
            print_warning(
                "Not all videos were successfully normalized. Cannot proceed with concatenation."
            )
            return

        temp_file_name = None
        try:
            # Create a temporary file list for the concat demuxer
            with tempfile.NamedTemporaryFile(
                mode="w", delete=False, encoding="utf-8"
            ) as temp_file:
                temp_file_name = temp_file.name
                for file_path in normalized_files:
                    # Use Path.resolve() to get absolute path, required by concat demuxer safe mode 0
                    temp_file.write(f"file '{file_path.resolve()}'\n")
                temp_file.flush()
            logger.debug(f"Created temporary concat list: {temp_file_name}")

            # Attempt concatenation without re-encoding first
            try:
                first_video = videos[
                    0
                ]  # Use properties from the first original video (assuming normalization preserved them)
                command = [
                    self.ffmpeg_path,
                    "-y",
                    "-f",
                    "concat",
                    "-safe",
                    "0",  # Allow relative or absolute paths not in the current directory
                    "-i",
                    temp_file_name,
                ]
                # Use map to ensure correct streams are copied
                command += [
                    "-map",
                    "0:v:0",
                ]  # Map first video stream from the concat input
                if first_video.has_audio:
                    command += [
                        "-map",
                        "0:a:0",
                        "-c",
                        "copy",
                    ]  # Map first audio stream and copy all
                else:
                    command += ["-an", "-c:v", "copy"]  # No audio, copy video

                command += [str(output_file)]

                logger.info(
                    f"Running ffmpeg concat command (copy): {' '.join(command)}"
                )
                run_command(
                    command,
                    description="Concatenating videos (copy)",
                    display_output=True,
                )
                logger.info(
                    f"Concatenation successful (copy). Output saved to {output_file}"
                )
                print_status(
                    f"Concatenation successful (copy). Output saved to {output_file}"
                )

            except subprocess.CalledProcessError as e:
                logger.warning(
                    f"Concatenation (copy) failed: {e}. Attempting re-encoding."
                )
                print_warning(
                    "Concatenation with stream copy failed. Attempting re-encoding."
                )

                # Attempt concatenation with re-encoding
                try:
                    encoder = self.ffmpeg_builder._get_encoder()
                    width, height = (
                        videos[0].width,
                        videos[0].height,
                    )  # Use properties from the first original video
                    bitrate = estimate_bitrate(width, height)

                    command = [
                        self.ffmpeg_path,
                        "-y",
                        "-f",
                        "concat",
                        "-safe",
                        "0",
                        "-i",
                        temp_file_name,
                    ]
                    command += ["-c:v", encoder, "-b:v", bitrate, "-preset", "fast"]

                    if encoder.startswith("libvpx"):
                        command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

                    if videos[0].has_audio:  # Check audio on first video
                        command += [
                            "-c:a",
                            "aac",
                            "-b:a",
                            "256k",
                        ]  # Re-encode audio too
                    else:
                        command += ["-an"]
                    command += [str(output_file)]

                    logger.info(
                        f"Running ffmpeg concat command (re-encode): {' '.join(command)}"
                    )
                    run_command(
                        command,
                        description="Concatenating videos (re-encode)",
                        display_output=True,
                    )
                    logger.info(
                        f"Concatenation (re-encode) successful. Output saved to {output_file}"
                    )
                    print_status(
                        f"Concatenation (re-encode) successful. Output saved to {output_file}"
                    )

                except (
                    subprocess.CalledProcessError,
                    VideoProcessingError,
                    DependencyError,
                ) as e:
                    logger.error(f"Error during re-encoded concatenation: {e}")
                    print_warning("Error during concatenation even after re-encoding.")
                    # Clean up potentially incomplete output file
                    if output_file.exists():
                        try:
                            output_file.unlink()
                            logger.info(f"Removed incomplete output file {output_file}")
                        except Exception as unlink_e:
                            logger.warning(
                                f"Could not remove incomplete output file {output_file}: {unlink_e}"
                            )
                except Exception as e:
                    logger.error(
                        f"Unexpected error during re-encoded concatenation: {e}"
                    )
                    print_warning(
                        "Unexpected error during concatenation even after re-encoding."
                    )
                    # Clean up potentially incomplete output file
                    if output_file.exists():
                        try:
                            output_file.unlink()
                            logger.info(f"Removed incomplete output file {output_file}")
                        except Exception as unlink_e:
                            logger.warning(
                                f"Could not remove incomplete output file {output_file}: {unlink_e}"
                            )

        except (FileNotFoundError, DependencyError) as e:
            print_warning(
                f"Required binary (ffmpeg) not found. Cannot concatenate videos: {e}"
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Error during concatenation setup: {e}")
            print_warning("Failed to set up concatenation process.")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        finally:
            # Clean up the temporary file list
            if temp_file_name and Path(temp_file_name).exists():
                try:
                    Path(temp_file_name).unlink()
                    logger.info(f"Temporary file {temp_file_name} deleted.")
                except Exception as e:
                    logger.warning(
                        f"Could not delete temporary file {temp_file_name}: {e}"
                    )
            # Clean up normalized files if they were created in a temp dir (not currently implemented)
            # If normalized files are in the output dir, maybe leave them? Or add an option.

    def extract_audio(self, video: VideoFile, output_file: Path, format_choice: str):
        """Extract the audio track from the video file and save it in the chosen format."""
        logger.info(f"Extracting audio from {video.filepath} in format {format_choice}")

        if not video.has_audio:
            print_warning(f"No audio stream found in {video.basename}.")
            return

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        format_codecs = {
            "mp3": "libmp3lame",
            "opus": "libopus",
            "aac": "aac",
            # Add more formats/codecs if needed
        }
        audio_codec = format_codecs.get(format_choice.lower())

        if not audio_codec:
            print_warning(f"Unsupported audio format choice: {format_choice}")
            return

        ffmpeg_path = find_binary("ffmpeg", load_config())
        if not ffmpeg_path:
            print_warning("ffmpeg binary not found. Cannot extract audio.")
            return

        try:
            # Check if the selected audio codec is available in FFmpeg
            if not check_encoder_availability(audio_codec, ffmpeg_path):
                print_warning(
                    f"Audio encoder '{audio_codec}' not available in your FFmpeg build."
                )
                print_warning(
                    "Please install FFmpeg with support for this codec or choose a different format."
                )
                return  # Exit the function

            command = [
                ffmpeg_path,
                "-y",
                "-i",
                str(video.filepath),
                "-vn",  # No video
                "-c:a",
                audio_codec,
                "-b:a",
                "256k",  # Hardcoded bitrate, could be configurable
                "-map",
                "0:a:0",  # Map the first audio stream
                str(output_file),
            ]

            run_command(
                command,
                description=f"Extracting audio from {video.basename}",
                display_output=True,
            )
            print_status(
                f"Audio extracted from {video.basename}. Saved as {output_file}"
            )
            logger.info(f"Audio extraction successful for {video.filepath}")

        except (subprocess.CalledProcessError, DependencyError) as e:
            logger.error(f"Error extracting audio from {video.filepath}: {e}")
            print_warning(f"Failed to extract audio from {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(
                f"Unexpected error extracting audio from {video.filepath}: {e}"
            )
            print_warning(f"Unexpected error extracting audio from {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def merge_audio_with_video(
        self, video: VideoFile, audio_file: Path, output_file: Path
    ):
        """Merge an external audio file with a video."""
        logger.info(f"Merging audio from {audio_file} with {video.filepath}")

        if not audio_file.is_file():
            print_warning(f"Audio file does not exist: {audio_file}")
            return

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        ffmpeg_path = find_binary("ffmpeg", load_config())
        if not ffmpeg_path:
            print_warning("ffmpeg binary not found. Cannot merge audio.")
            return

        try:
            command = [
                ffmpeg_path,
                "-y",
                "-i",
                str(video.filepath),  # Input 0: Video file
                "-i",
                str(audio_file),  # Input 1: Audio file
                "-c:v",
                "copy",  # Copy video stream
                "-c:a",
                "copy",  # Copy audio stream
                "-map",
                "0:v:0",  # Map first video stream from input 0
                "-map",
                "1:a:0",  # Map first audio stream from input 1
                "-shortest",  # Finish encoding when the shortest input stream ends
                str(output_file),
            ]

            run_command(
                command,
                description=f"Merging audio with {video.basename}",
                display_output=True,
            )
            print_status(f"Audio merged with {video.basename}. Saved as {output_file}")
            logger.info(f"Audio merge successful for {video.filepath}")

        except (subprocess.CalledProcessError, DependencyError) as e:
            logger.error(f"Error merging audio with {video.filepath}: {e}")
            print_warning(f"Failed to merge audio with {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(f"Unexpected error merging audio with {video.filepath}: {e}")
            print_warning(f"Unexpected error merging audio with {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def handle_metadata(
        self, video: VideoFile, output_file: Path, keep_metadata: bool = True
    ):
        """Handle metadata retention or removal in the video file."""
        logger.info(
            f"Handling metadata for {video.filepath}. Keep metadata: {keep_metadata}"
        )

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        ffmpeg_path = find_binary("ffmpeg", load_config())
        if not ffmpeg_path:
            print_warning("ffmpeg binary not found. Cannot handle metadata.")
            return

        try:
            command = [
                ffmpeg_path,
                "-y",
                "-i",
                str(video.filepath),
            ]

            if keep_metadata:
                command += ["-map_metadata", "0"]  # Map metadata from input 0
            else:
                command += ["-map_metadata", "-1"]  # Remove all metadata

            # Copy streams
            command += ["-c", "copy", str(output_file)]

            run_command(
                command,
                description=f"Handling metadata for {video.basename}",
                display_output=True,
            )
            print_status(
                f"Metadata handling complete for {video.basename}. Saved as {output_file}"
            )
            logger.info(f"Metadata handling successful for {video.filepath}")

        except (subprocess.CalledProcessError, DependencyError) as e:
            logger.error(f"Error handling metadata for {video.filepath}: {e}")
            print_warning(f"Failed to handle metadata for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(
                f"Unexpected error handling metadata for {video.filepath}: {e}"
            )
            print_warning(f"Unexpected error handling metadata for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def generate_video_report(self, video: VideoFile, output_file: Path):
        """Generate a detailed report for the video file using ffprobe."""
        logger.info(f"Generating video report for {video.filepath}")

        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        ffprobe_path = find_binary("ffprobe", load_config())
        if not ffprobe_path:
            print_warning("ffprobe binary not found. Cannot generate report.")
            return

        try:
            command = [
                ffprobe_path,
                "-v",
                "error",  # Suppress verbose output, only show errors
                "-print_format",
                "json",
                "-show_format",
                "-show_streams",
                str(video.filepath),
            ]

            # Run command without displaying output, capture JSON
            report_json_str = run_command(
                command,
                description=f"Generating video report for {video.basename}",
                display_output=False,
            )

            # Pretty print the JSON report
            try:
                report_data = json.loads(report_json_str)
                pretty_report = json.dumps(report_data, indent=4)
            except json.JSONDecodeError:
                logger.error("Failed to parse ffprobe JSON output for report.")
                pretty_report = report_json_str  # Save raw output if JSON parsing fails

            with output_file.open("w", encoding="utf-8") as f:
                f.write(pretty_report)

            print_status(
                f"Video report generated for {video.basename}. Saved as {output_file}"
            )
            logger.info(f"Video report generated successfully for {video.filepath}")

        except (subprocess.CalledProcessError, DependencyError) as e:
            logger.error(f"Error generating report for {video.filepath}: {e}")
            print_warning(f"Failed to generate report for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )
        except Exception as e:
            logger.error(
                f"Unexpected error generating report for {video.filepath}: {e}"
            )
            print_warning(f"Unexpected error generating report for {video.basename}")
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )

    def handle_vapoursynth(self, video: VideoFile):
        """Handle applying a VapourSynth transformation to a video."""
        logger.info(f"Applying VapourSynth transformation to {video.filepath}")
        transformation = self.vapoursynth_menu(video)
        if transformation:
            self.apply_vapoursynth_transformation(video, transformation)

    def vapoursynth_menu(self, video: VideoFile) -> Optional[str]:
        """Display the VapourSynth transformations menu and handle user selection."""
        options = [
            "Frame Rate Conversion (Motion Interpolation)",
            "Inverse Telecine (IVTC)",
            "Deflicker",
            "Dedot",
            "Dehalo",
            "Grain Generation",
            "Remove Grain",
            "Debanding",
            "Sharpening & Edge Enhancement",
            "Color Correction",
            "Super Resolution",
            "Deshake",
            "Edge Detection",
            "Zooming",
            "Stabilization",  # Seems identical to Deshake?
            "Exit",
        ]
        # Filter options based on available plugins
        available_options = []
        for opt in options:
            required = []
            if opt == "Frame Rate Conversion (Motion Interpolation)":
                required = ["svpflow1", "svpflow2", "ffms2"]
            elif opt == "Inverse Telecine (IVTC)":
                required = ["vivtc", "ffms2"]
            elif opt in ["Deflicker", "Grain Generation", "Zooming"]:
                required = [
                    "ffms2"
                ]  # These might only need ffms2 + built-in std filters
            elif opt == "Dedot":
                required = ["nnedi3", "ffms2"]
            elif opt == "Dehalo":
                required = ["dehalo", "ffms2"]
            elif opt == "Remove Grain":
                required = ["rgvs", "ffms2"]
            elif opt == "Debanding":
                required = ["f3kdb", "ffms2"]
            elif opt == "Sharpening & Edge Enhancement":
                required = ["awarpsharp2", "ffms2"]
            elif opt == "Color Correction":
                required = ["adjust", "ffms2"]
            elif opt == "Super Resolution":
                required = ["nnedi3", "ffms2"]  # Note: nnedi3 is a doubler, not full SR
            elif opt in ["Deshake", "Stabilization"]:
                required = ["stabilize", "ffms2"]  # Assuming stabilize plugin
            elif opt == "Edge Detection":
                required = ["edge_detect", "ffms2"]
            elif opt == "Exit":
                required = []  # Always available

            if all(p in self.available_vs_plugins for p in required):
                available_options.append(opt)
            elif opt == "Exit":
                available_options.append(opt)  # Always include Exit
            else:
                logger.debug(
                    f"Skipping VapourSynth option '{opt}' due to missing plugins: {[r for r in required if r not in self.available_vs_plugins]}"
                )

        if not available_options or (
            len(available_options) == 1 and available_options[0] == "Exit"
        ):
            print_warning(
                "No VapourSynth transformations available (missing plugins or ffms2)."
            )
            return None

        print(f"{GREEN}#{NC} ===== VapourSynth Transformations =====")
        for idx, opt in enumerate(available_options, 1):
            print(f"{idx}. {opt}")

        completer = WordCompleter(available_options, ignore_case=True)

        while True:
            choice_input = prompt(
                HTML(
                    "<ansigreen>Select a transformation (or type 'Exit'): </ansigreen>"
                ),
                completer=completer,
                style=style,
            ).strip()

            if choice_input.lower() == "exit":
                print_status("Exiting VapourSynth menu.", "INFO")
                return None

            try:
                choice_idx = int(choice_input) - 1
                if 0 <= choice_idx < len(available_options):
                    transformation = available_options[choice_idx]
                    print_status(f"Selected: {transformation}", "INFO")
                    return transformation
                else:
                    print_warning("Invalid option number selected.")
            except ValueError:
                print_warning(
                    "Invalid input. Please enter a number corresponding to the options or 'Exit'."
                )

    def apply_vapoursynth_transformation(self, video: VideoFile, transformation: str):
        """Apply the selected VapourSynth transformation."""
        output_filename = prompt(
            "Enter output file name (or press Enter for default): "
        ).strip()
        if not output_filename:
            safe_transformation = sanitize_filename(
                transformation.lower()
                .replace(" ", "_")
                .replace("(", "")
                .replace(")", "")
            )
            output_filename = f"{video.filepath.stem}_{safe_transformation}{video.filepath.suffix}"  # Keep original extension

        output_file = Path(output_filename)
        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        ffms2_plugin_path = self.available_vs_plugins.get("ffms2")
        if not ffms2_plugin_path:
            print_warning(
                "FFMS2 plugin not found. Cannot proceed with VapourSynth transformations."
            )
            return  # Should be caught by menu filtering, but double check

        script_content = ""
        # Define transformation parameters and script content
        if transformation == "Frame Rate Conversion (Motion Interpolation)":
            if (
                "svpflow1" not in self.available_vs_plugins
                or "svpflow2" not in self.available_vs_plugins
            ):
                print_warning("SVPflow plugins not available for this transformation.")
                return
            target_fps_input = prompt("Enter target FPS (e.g., 60, 120): ").strip()
            try:
                target_fps = float(target_fps_input)
                if target_fps <= video.frame_rate:
                    print_warning(
                        f"Target FPS ({target_fps}) must be higher than original FPS ({video.frame_rate:.2f}) for interpolation."
                    )
                    return
            except ValueError:
                print_warning("Invalid FPS value.")
                return

            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow1"]}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow2"]}")
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Ensure clip is in a compatible format if needed, e.g., 8-bit YUV420P
            # clip = core.resize.Spline36(clip, format=vs.YUV420P8) # Example conversion

            super_params = dict(pel=2)
            analyse_params = dict(main=dict(search=dict(coarse=dict(distance=-6))))
            smoothfps_params = dict(fpsnum=int({target_fps} * 1000), fpsden=1000)
            super_clip = core.svp2.Super(clip, levels=super_params)
            vectors = core.svp2.Analyse(super_clip, clip, analyse_params=analyse_params)
            # Use SmoothFps to interpolate to the target_fps
            smooth_clip = core.svp2.SmoothFps(clip, super_clip, vectors, smoothfps_params, src=clip, fps={target_fps})
            smooth_clip.set_output()
            """
            )
        elif transformation == "Inverse Telecine (IVTC)":
            if "vivtc" not in self.available_vs_plugins:
                print_warning("vivtc plugin not available for IVTC.")
                return
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["vivtc"]}")
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Ensure clip is in a compatible format if needed
            # clip = core.resize.Spline36(clip, format=vs.YUV400P8) # Example conversion for VFM

            # Basic IVTC using VFM and VDecimate
            ivtc = core.vivtc.VFM(clip, order=1, cthresh=2, mi=60, modi=2, chroma=True, tff=None) # order=1 for bottom field first, adjust tff if needed
            ivtc = core.vivtc.VDecimate(ivtc, mode=0, threshold=1.5) # mode=0 for NTSC, adjust threshold
            ivtc.set_output()
            """
            )
        elif transformation == "Deflicker":
            # std.Deflicker is a built-in VapourSynth filter, doesn't need a separate plugin file
            script_content = textwrap.dedent(
                f"""
             import vapoursynth as vs
             core = vs.core
             core.std.LoadPlugin(r"{ffms2_plugin_path}")
             clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
             # mode=1: luminance only, window=3: 3 frames window
             deflicker = core.std.Deflicker(clip, mode=1, window=3)
             deflicker.set_output()
             """
            )
        elif transformation == "Dedot":
            if "nnedi3" not in self.available_vs_plugins:
                print_warning("nnedi3 plugin not available for Dedot.")
                return
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["nnedi3"]}")
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # nnedi3.Dedot is a specific function within nnedi3 plugin
            dedot = core.nnedi3.Dedot(clip)
            dedot.set_output()
            """
            )
        elif transformation == "Dehalo":
            if "dehalo" not in self.available_vs_plugins:
                print_warning("Dehalo plugin (libdehalo_alpha.so) not available.")
                return
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["dehalo"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Example parameters for Alpha dehalo, adjust as needed
            dehalo = core.dehalo.Alpha(clip, rx=1.8, ry=1.8, depth=16)
            dehalo.set_output()
            """
            )
        elif transformation == "Grain Generation":
            # grain.Add is a built-in VapourSynth filter
            strength = (
                prompt("Enter grain strength (e.g., 8, 12, 16): ").strip() or "10"
            )
            try:
                strength_val = float(strength)
            except ValueError:
                print_warning("Invalid strength value. Using default 10.")
                strength_val = 10.0
            script_content = textwrap.dedent(
                f"""
             import vapoursynth as vs
             core = vs.core
             core.std.LoadPlugin(r"{ffms2_plugin_path}")
             clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
             # Add grain to all planes (y, u, v)
             grain = core.grain.Add(clip, strength=[{strength_val}, {strength_val}, {strength_val}])
             grain.set_output()
             """
            )
        elif transformation == "Remove Grain":
            if "rgvs" not in self.available_vs_plugins:
                print_warning("rgvs plugin not available for Remove Grain.")
                return
            # mode=17 is a common mode for RemoveGrain, but user might want others
            mode = (
                prompt("Enter RemoveGrain mode (e.g., 1, 4, 17, 20): ").strip() or "17"
            )
            try:
                mode_val = int(mode)
            except ValueError:
                print_warning("Invalid mode value. Using default 17.")
                mode_val = 17
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["rgvs"]}")
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            remove_grain = core.rgvs.RemoveGrain(clip, mode={mode_val})
            remove_grain.set_output()
            """
            )
        elif transformation == "Debanding":
            if "f3kdb" not in self.available_vs_plugins:
                print_warning("f3kdb plugin not available for Debanding.")
                return
            # Default parameters from original script, could prompt for these
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["f3kdb"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Example parameters, often need tuning
            deband = core.f3kdb.Deband(clip, y=64, cb=64, cr=64, grainy=64, grainc=64)
            deband.set_output()
            """
            )
        elif transformation == "Sharpening & Edge Enhancement":
            if "awarpsharp2" not in self.available_vs_plugins:
                print_warning("AWarpSharp2 plugin not available for Sharpening.")
                return
            # depth=2 is a common default, could prompt
            depth = prompt("Enter AWarpSharp2 depth (e.g., 2, 8, 16): ").strip() or "2"
            try:
                depth_val = int(depth)
            except ValueError:
                print_warning("Invalid depth value. Using default 2.")
                depth_val = 2
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["awarpsharp2"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            sharpen = core.warp.AWarpSharp2(clip, depth={depth_val})
            sharpen.set_output()
            """
            )
        elif transformation == "Color Correction":
            if "adjust" not in self.available_vs_plugins:
                print_warning("adjust plugin not available for Color Correction.")
                return
            brightness = (
                prompt("Enter brightness adjustment (default 0.0): ").strip() or "0.0"
            )
            contrast = (
                prompt("Enter contrast adjustment (default 1.0): ").strip() or "1.0"
            )
            saturation = (
                prompt("Enter saturation adjustment (default 1.0): ").strip() or "1.0"
            )
            try:
                brightness_val = float(brightness)
                contrast_val = float(contrast)
                saturation_val = float(saturation)
            except ValueError:
                print_warning("Invalid input values. Using default settings.")
                brightness_val, contrast_val, saturation_val = 0.0, 1.0, 1.0
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["adjust"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            color_correct = core.std.Tweak(clip, bright={brightness_val}, cont={contrast_val}, sat={saturation_val})
            color_correct.set_output()
            """
            )
        elif transformation == "Super Resolution":
            if "nnedi3" not in self.available_vs_plugins:
                print_warning("nnedi3 plugin not available for Super Resolution.")
                return
            # Note: nnedi3 is primarily a deinterlacer/doubler. True SR needs other plugins.
            # This script performs a simple 2x upscale.
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["nnedi3"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Use nnedi3 for doubling (field=1 or field=0 for progressive)
            # field=3 is for deinterlacing interlaced content (both fields)
            # For progressive upscale, use field=1 or 0, then resize if needed
            # Let's assume progressive input and use field=1 for doubling height
            doubled_height = core.nnedi3.nnedi3(clip, field=1)
            # Now double width using a resizer
            super_res = core.resize.Spline36(doubled_height, width=clip.width  2, height=clip.height  2)
            super_res.set_output()
            """
            )
        elif transformation in [
            "Deshake",
            "Stabilization",
        ]:  # Assuming they use the same plugin/function
            if "stabilize" not in self.available_vs_plugins:
                print_warning(
                    "Stabilize plugin not available for Deshake/Stabilization."
                )
                return
            # Stabilize parameters often need tuning, using defaults here
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["stabilize"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Basic stabilization, parameters like factor, cutoff, etc., might be needed
            stabilized = core.stabilize.Stabilize(clip)
            stabilized.set_output()
            """
            )
        elif transformation == "Edge Detection":
            if "edge_detect" not in self.available_vs_plugins:
                print_warning("Edge Detection plugin not available.")
                return
            # EdgeDetect parameters often need tuning
            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            core.std.LoadPlugin(r"{self.available_vs_plugins["edge_detect"]}") # Use found path
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Example parameters, adjust method, threshold etc.
            edges = core.edge_detect.EdgeDetect(clip)
            edges.set_output()
            """
            )
        elif transformation == "Zooming":
            # Zooming can be done with Crop and Resize
            print(
                "Note: This performs a crop and then resizes back to original dimensions."
            )
            x = prompt("Enter x coordinate for crop (default 0): ").strip() or "0"
            y = prompt("Enter y coordinate for crop (default 0): ").strip() or "0"
            width = prompt(f"Enter width for crop (current: {video.width}): ").strip()
            height = prompt(
                f"Enter height for crop (current: {video.height}): "
            ).strip()
            try:
                x_val = int(x)
                y_val = int(y)
                width_val = int(width) if width else video.width
                height_val = int(height) if height else video.height
                if (
                    width_val <= 0
                    or height_val <= 0
                    or x_val < 0
                    or y_val < 0
                    or x_val + width_val > video.width
                    or y_val + height_val > video.height
                ):
                    print_warning("Invalid cropping parameters.")
                    return
            except ValueError:
                print_warning("Invalid cropping parameters (must be integers).")
                return

            script_content = textwrap.dedent(
                f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r"{ffms2_plugin_path}")
            clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")
            # Crop the region to "zoom" into
            cropped = core.std.CropAbs(clip, width={width_val}, height={height_val}, left={x_val}, top={y_val})
            # Resize the cropped region back to the original video dimensions
            zoomed = core.resize.Spline36(cropped, width=clip.width, height=clip.height)
            zoomed.set_output()
            """
            )
        elif transformation == "Exit":
            return  # Handled in menu loop

        if script_content:
            # Use the pipeline helper
            try:
                # Build the FFmpeg command to read from the pipe and encode
                encoder = self.ffmpeg_builder._get_encoder()
                bitrate = estimate_bitrate(video.width, video.height)

                ffmpeg_command = [
                    self.ffmpeg_path,
                    "-y",
                    "-f",
                    "yuv4mpegpipe",
                    "-i",
                    "-",
                    "-c:v",
                    encoder,
                    "-b:v",
                    bitrate,
                    "-preset",
                    "fast",
                ]
                if encoder.startswith("libvpx"):
                    ffmpeg_command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

                if video.has_audio:
                    ffmpeg_command += [
                        "-i",
                        str(video.filepath),  # Original video for audio
                        "-map",
                        "0:v:0",  # Video from pipe (input 0)
                        "-map",
                        "1:a:0",  # Audio from original video (input 1)
                        "-c:a",
                        "copy",
                    ]
                else:
                    ffmpeg_command += ["-an"]

                ffmpeg_command += [str(output_file)]

                self._run_vspipe_ffmpeg_pipeline(
                    video, script_content, ffmpeg_command, output_file
                )

            except (VideoProcessingError, DependencyError):
                # Error already logged and printed by _run_vspipe_ffmpeg_pipeline
                pass  # Just propagate the failure
            except Exception as e:
                logger.error(
                    f"Unexpected error setting up VapourSynth pipeline for {video.filepath}: {e}"
                )
                print_warning(
                    f"Unexpected error setting up VapourSynth pipeline for {video.basename}"
                )
                # Clean up incomplete output file
                if output_file.exists():
                    try:
                        output_file.unlink()
                    except Exception as unlink_e:
                        logger.warning(
                            f"Could not remove incomplete output file {output_file}: {unlink_e}"
                        )

        else:
            print_warning(f"No script generated for transformation: {transformation}")

    def batch_enhance_video(self, video: VideoFile):
        """Apply a series of enhancements to the video using VapourSynth."""
        logger.info(f"Starting batch enhancement for {video.filepath}")

        output_filename = prompt(
            "Enter output file name for enhanced video (or press Enter for default): "
        ).strip()
        if not output_filename:
            output_filename = f"{sanitize_filename(video.filepath.stem)}_enhanced{video.filepath.suffix}"

        output_file = Path(output_filename)
        # Ensure output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)

        # Check for all required plugins for the batch script
        required_plugins = [
            "ffms2",
            "rgvs",
            "awarpsharp2",
            "nnedi3",
            "dehalo",
            "f3kdb",
            "adjust",
            "svpflow1",
            "svpflow2",
        ]
        missing_plugins = [
            p for p in required_plugins if p not in self.available_vs_plugins
        ]

        if missing_plugins:
            print_warning(
                f"Missing required VapourSynth plugins for batch enhancement: {', '.join(missing_plugins)}"
            )
            print_warning("Cannot perform batch enhancement.")
            return



        # Construct a VapourSynth script that applies multiple transformations
        # Ensure variables used in SVPflow part are defined
        script_content = textwrap.dedent(
            f"""
        import vapoursynth as vs
        core = vs.core
        # Load all required plugins using their found paths
        core.std.LoadPlugin(r"{self.available_vs_plugins["ffms2"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["rgvs"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["awarpsharp2"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["nnedi3"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["dehalo"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["f3kdb"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["adjust"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow1"]}")
        core.std.LoadPlugin(r"{self.available_vs_plugins["svpflow2"]}")

        clip = core.ffms2.Source(r"{str(video.filepath.resolve())}")

        # Ensure clip is in a compatible format if needed, e.g., 8-bit YUV420P
        # clip = core.resize.Spline36(clip, format=vs.YUV420P8) # Example conversion

        # --- Enhancement Chain ---
        # 1. Remove grain (example mode 17)
        clip = core.rgvs.RemoveGrain(clip, mode=17)
        # 2. Sharpening and edge enhancement (example depth 2)
        clip = core.warp.AWarpSharp2(clip, depth=2)
        # 3. Super resolution (simple 2x upscale using nnedi3 and resize)
        # Assuming progressive input, use field=1 for doubling height
        doubled_height = core.nnedi3.nnedi3(clip, field=1)
        # Resize to double width and height
        clip = core.resize.Spline36(doubled_height, width=clip.width  2, height=clip.height  2)
        # 4. Dehalo (example parameters)
        clip = core.dehalo.Alpha(clip, rx=1.8, ry=1.8, depth=16)
        # 5. Debanding (example parameters)
        clip = core.f3kdb.Deband(clip, y=64, cb=64, cr=64, grainy=64, grainc=64)
        # 6. Color correction (example parameters)
        clip = core.std.Tweak(clip, bright=0.0, cont=1.0, sat=1.0)
        # 7. Frame rate conversion with motion interpolation (example to 60fps)
        # Define SVPflow parameters within the script
        super_params = dict(pel=2)
        analyse_params = dict(main=dict(search=dict(coarse=dict(distance=-6))))
        # Target 60 FPS for interpolation
        smoothfps_params = dict(fpsnum=60000, fpsden=1000) # 60 FPS
        super_clip = core.svp2.Super(clip, levels=super_params)
        vectors = core.svp2.Analyse(super_clip, clip, analyse_params=analyse_params)
        clip = core.svp2.SmoothFps(clip, super_clip, vectors, smoothfps_params, src=clip, fps=60.0)

        # --- End Enhancement Chain ---

        clip.set_output()
        """
        )

        try:
            # Build the FFmpeg command to read from the pipe and encode
            # Use the new resolution after Super Resolution (assuming 2x)
            enhanced_width = video.width * 2
            enhanced_height = video.height * 2
            encoder = self.ffmpeg_builder._get_encoder()
            bitrate = estimate_bitrate(
                enhanced_width, enhanced_height
            )  # Estimate bitrate for the new resolution

            ffmpeg_command = [
                self.ffmpeg_path,
                "-y",
                "-f",
                "yuv4mpegpipe",
                "-i",
                "-",
                "-c:v",
                encoder,
                "-b:v",
                bitrate,
                "-preset",
                "fast",
            ]
            if encoder.startswith("libvpx"):
                ffmpeg_command += ["-pix_fmt", "yuv420p", "-deadline", "good"]

            if video.has_audio:
                ffmpeg_command += [
                    "-i",
                    str(video.filepath),  # Original video for audio
                    "-map",
                    "0:v:0",  # Video from pipe (input 0)
                    "-map",
                    "1:a:0",  # Audio from original video (input 1)
                    "-c:a",
                    "copy",
                ]
            else:
                ffmpeg_command += ["-an"]

            ffmpeg_command += [str(output_file)]

            self._run_vspipe_ffmpeg_pipeline(
                video, script_content, ffmpeg_command, output_file
            )

        except (VideoProcessingError, DependencyError):
            # Error already logged and printed by _run_vspipe_ffmpeg_pipeline
            pass  # Just propagate the failure
        except Exception as e:
            logger.error(
                f"Unexpected error setting up batch enhancement pipeline for {video.filepath}: {e}"
            )
            print_warning(
                f"Unexpected error setting up batch enhancement pipeline for {video.basename}"
            )
            # Clean up incomplete output file
            if output_file.exists():
                try:
                    output_file.unlink()
                except Exception as unlink_e:
                    logger.warning(
                        f"Could not remove incomplete output file {output_file}: {unlink_e}"
                    )


class UserInterface:
    """Handles user interactions."""

    def __init__(self, config: Dict[str, Any], config_mode: bool = False):
        self.config = config
        # Initialize processor after config is loaded and dependencies checked
        try:
            self.processor = VideoProcessor(self.config)
            logger.info("UserInterface initialized with VideoProcessor")
        except DependencyError as e:
            logger.error(
                f"Failed to initialize VideoProcessor due to missing dependencies: {e}"
            )
            print_warning(
                f"Failed to initialize video processor. Please resolve dependencies: {e}"
            )
            sys.exit(1)  # Exit if core processor cannot be initialized

        if config_mode or not CONFIG_FILE.exists():
            self.configure_binary_paths()
        # Re-initialize processor after potential config changes
        try:
            self.processor = VideoProcessor(self.config)
            logger.info("VideoProcessor re-initialized after config check.")
        except DependencyError as e:
            logger.error(
                f"Failed to re-initialize VideoProcessor after config check: {e}"
            )
            print_warning(
                f"Failed to initialize video processor after config check. Please resolve dependencies: {e}"
            )
            sys.exit(1)

    def configure_binary_paths(self):
        """Provide the user with an option to specify binary paths and store them in the config file."""
        print(f"{GREEN}#{NC} ===== Binary Paths Configuration =====")
        print(
            "This tool requires external binaries (ffmpeg, ffprobe, vspipe, mediainfo, fzf)."
        )
        print("It will attempt to find them in your system's PATH.")
        print("You can optionally specify custom paths below.")
        print("Press Enter to use the default/discovered path for each tool.")

        updated = False
        current_config = self.config.copy()  # Work on a copy until saved

        for key in ["FFMPEG_BIN", "FFPROBE_BIN", "VSPIPE_BIN"]:
            current_path = current_config.get(key)
            discovered_path = find_binary(
                key.replace("_BIN", "").lower(), DEFAULT_CONFIG
            )  # Find using default logic
            display_path = (
                current_path
                if current_path is not None
                else (discovered_path if discovered_path else "Not found in PATH")
            )

            new_path_input = prompt(f"Enter path for {key} [{display_path}]: ").strip()

            if new_path_input:
                new_path = os.path.expanduser(new_path_input)
                if Path(new_path).exists():
                    current_config[key] = new_path
                    logger.info(f"Updated {key} to {current_config[key]}")
                    updated = True
                else:
                    print_warning(
                        f"Path '{new_path}' does not exist. Keeping current path."
                    )
            else:
                # If user pressed Enter, explicitly set to None so find_binary uses shutil.which
                current_config[key] = None

        max_workers_input = prompt(
            f"Enter maximum number of worker threads [{current_config.get('MAX_WORKERS', MAX_WORKERS_DEFAULT)}]: "
        ).strip()
        if max_workers_input:
            try:
                max_workers = int(max_workers_input)
                if max_workers > 0:
                    current_config["MAX_WORKERS"] = max_workers
                    logger.info(f"Updated MAX_WORKERS to {max_workers}")
                    updated = True
                else:
                    print_warning(
                        "MAX_WORKERS must be a positive integer. Keeping current value."
                    )
            except ValueError:
                print_warning(
                    "Invalid input for MAX_WORKERS. It must be an integer. Keeping current value."
                )

        if updated:
            self.config.update(current_config)  # Update the actual config
            save_config(self.config)
            print_status("Configuration updated successfully.", "OK")
        else:
            print_status("No changes made to configuration.", "INFO")

    def main_menu(self):
        """Display the main menu and handle user selection."""
        menu_options = [
            "Analyze",
            "Autofix",
            "Normalize",
            "Change Speed",
            "Adjust Resolution",
            "Convert Format",
            "Apply Filters",
            "Batch Enhance",
            "Help",
            "Screencaps",
            "Concatenate",
            "Extract Audio",
            "Merge Audio",
            "Metadata",
            "Generate Report",
            "VapourSynth",
            "Config",  # Add config option to menu
            "Quit",
        ]
        completer = WordCompleter(menu_options, ignore_case=True)

        while True:
            print(f"\n{CYAN}#{NC} ========= {CYAN}// DMX //{NC} =========\n")
            choice = (
                prompt(
                    HTML("<prompt>By your command: </prompt>"),
                    completer=completer,
                    style=style,
                )
                .strip()
                .lower()
            )

            try:
                if choice == "analyze":
                    self.handle_analyze()
                elif choice == "autofix":
                    self.handle_autofix()
                elif choice == "normalize":
                    self.handle_normalize()
                elif choice == "change speed":
                    self.handle_change_speed()
                elif choice == "adjust resolution":
                    self.handle_adjust_resolution()
                elif choice == "convert format":
                    self.handle_convert_format()
                elif choice == "apply filters":
                    self.handle_filters()
                elif choice == "batch enhance":
                    self.handle_batch_enhance()
                elif choice == "help":
                    self.print_help()
                elif choice == "screencaps":
                    self.handle_screencaps()
                elif choice == "concatenate":
                    self.handle_concatenate()
                elif choice == "extract audio":
                    self.handle_extract_audio()
                elif choice == "merge audio":
                    self.handle_merge_audio()
                elif choice == "metadata":
                    self.handle_metadata()
                elif choice == "generate report":
                    self.handle_generate_report()
                elif choice == "vapoursynth":
                    self.handle_vapoursynth()
                elif choice == "config":  # Handle config option
                    self.configure_binary_paths()
                    # Re-initialize processor after config change
                    try:
                        self.processor = VideoProcessor(self.config)
                        logger.info(
                            "VideoProcessor re-initialized after config change."
                        )
                    except DependencyError as e:
                        logger.error(
                            f"Failed to re-initialize VideoProcessor after config change: {e}"
                        )
                        print_warning(
                            f"Failed to initialize video processor after config change. Please resolve dependencies: {e}"
                        )
                        # Decide if you want to exit or continue with limited functionality
                        # For now, let's exit as core tools are missing
                        sys.exit(1)

                elif choice in ["quit", "exit"]:  # Accept 'exit' as well
                    print("Exiting DMX!")
                    logging.info("User exited the program.")
                    break
                else:
                    print_warning(f"Unrecognized option: {choice}")

            except (DependencyError, VideoProcessingError) as e:
                # Specific errors are already logged and printed by the functions that raise them
                logger.debug(f"Caught specific error in main menu handler: {e}")
                pass  # Continue the loop
            except Exception as e:
                logger.error(
                    f"Unexpected error in main menu handler for choice '{choice}': {e}",
                    exc_info=True,
                )  # Log traceback
                print_warning(f"An unexpected error occurred during the operation: {e}")
                print_warning("Check the log file for details.")

    def handle_analyze(self):
        """Handle the video analysis operation."""
        video = self.select_single_video()
        if video:
            self.processor.analyze_video(video)

    def handle_autofix(self):
        """Handle the detect and autofix operation for a video."""
        video = self.select_single_video()
        if video:
            video.detect_issues(fix_issues=True)

    def handle_normalize(self):
        """Handle the video normalization operation."""
        videos = self.select_multiple_videos()
        if videos:
            output_dir_input = prompt(
                "Enter custom directory for normalized videos or press Enter for current directory: "
            ).strip()
            output_dir = Path(output_dir_input) if output_dir_input else Path(".")
            self.processor.normalize_videos(videos, output_dir)

    def handle_change_speed(self):
        """Handle changing the speed of a video."""
        video = self.select_single_video()
        if video:
            speed_factor_input = prompt(
                "Enter Speed factor (e.g., 0.5 for slow motion, 2 for fast motion): "
            ).strip()
            try:
                speed_factor = float(speed_factor_input)
                if speed_factor <= 0:
                    print_warning("Speed factor must be greater than 0.")
                    return
            except ValueError:
                print_warning("Invalid speed factor (must be a number).")
                return

            # Check if SVPflow plugins are available before offering smooth motion
            can_do_smooth = (
                "svpflow1" in self.processor.available_vs_plugins
                and "svpflow2" in self.processor.available_vs_plugins
                and "ffms2" in self.processor.available_vs_plugins
            )

            smooth_motion = False
            if can_do_smooth:
                smooth_motion_input = (
                    prompt("Enable advanced motion interpolation? (y/n): ")
                    .strip()
                    .lower()
                )
                while smooth_motion_input not in [
                    "y",
                    "n",
                    "",
                ]:  # Allow empty for default 'n'
                    print_warning("Please enter 'y' or 'n'.")
                    smooth_motion_input = (
                        prompt("Enable advanced motion interpolation? (y/n): ")
                        .strip()
                        .lower()
                    )
                smooth_motion = smooth_motion_input == "y"
                if smooth_motion and speed_factor == 1.0:
                    print_warning(
                        "Smooth motion interpolation is typically used when changing speed. For 1x speed, it might not be necessary."
                    )

            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = f"{sanitize_filename(video.filepath.stem)}_speed_change{video.filepath.suffix}"

            output_file = Path(output_filename)

            self.processor.change_speed(video, output_file, speed_factor, smooth_motion)

    def handle_adjust_resolution(self):
        """Handle adjusting the resolution of a video."""
        video = self.select_single_video()
        if video:
            resolution = prompt("Enter new resolution (e.g., 1920x1080): ").strip()
            if not self.processor.validate_resolution_format(resolution):
                print_warning(
                    "Invalid resolution format. Please use WIDTHxHEIGHT (e.g., 1920x1080)."
                )
                return

            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = f"{sanitize_filename(video.filepath.stem)}_{resolution}{video.filepath.suffix}"

            output_file = Path(output_filename)

            self.processor.adjust_resolution(video, output_file, resolution)

    def handle_convert_format(self):
        """Handle converting the video format."""
        video = self.select_single_video()
        if video:
            supported_formats = [
                "mp4",
                "mkv",
                "avi",
                "mov",
                "webm",
            ]  # Match FFmpegCommandBuilder
            format_completer = WordCompleter(supported_formats, ignore_case=True)
            new_format = (
                prompt(
                    HTML(f"Enter new format ({'/'.join(supported_formats)}): "),
                    completer=format_completer,
                    style=style,
                )
                .strip()
                .lower()
            )

            if not new_format:
                print_warning("No format entered.")
                return
            if new_format not in supported_formats:
                print_warning(
                    f"Unsupported format: {new_format}. Supported formats are: {', '.join(supported_formats)}"
                )
                return

            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = f"{video.filepath.stem}.{new_format}"
            else:
                # Ensure correct extension if user provided a name without one
                if not output_filename.lower().endswith(f".{new_format}"):
                    output_filename = f"{output_filename}.{new_format}"

            output_file = Path(output_filename)

            self.processor.convert_video_format(video, output_file, new_format)

    def handle_filters(self):
        """Handle applying filters to the video."""
        video = self.select_single_video()
        if video:
            # Provide some common filter examples
            print(
                "Common filters: grayscale, negate, hflip, vflip, rotate=90, crop=w:h:x:y, scale=w:h"
            )
            filters = prompt(
                "Enter the video filters to apply, separated by commas (e.g., grayscale,negate): "
            ).strip()
            if not filters:
                print_warning("No filters entered.")
                return

            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = f"{sanitize_filename(video.filepath.stem)}_filtered{video.filepath.suffix}"

            output_file = Path(output_filename)

            self.processor.apply_filters(video, output_file, filters)

    def handle_screencaps(self):
        """Handle extracting frames from a video and saving them as images."""
        video = self.select_single_video()
        if video:
            output_dir_input = prompt(
                "Enter custom directory for screencaps or press Enter for './screencaps/': "
            ).strip()
            output_dir = (
                Path(output_dir_input) if output_dir_input else Path("./screencaps/")
            )
            self.processor.extract_frames(video, output_dir)

    def handle_concatenate(self):
        """Handle concatenating multiple videos into a single video."""
        print_status(
            "Select videos to concatenate (use TAB to select multiple in fzf)", "INFO"
        )
        videos = self.select_multiple_videos()
        if videos:
            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                # Use the extension of the first video as default
                output_filename = f"concatenated_{self.generate_timestamp()}{videos[0].filepath.suffix}"

            output_file = Path(output_filename)

            self.processor.concatenate_videos(videos, output_file)

    def handle_extract_audio(self):
        """Handle extracting the audio track from a video."""
        video = self.select_single_video()
        if video:
            supported_formats = ["opus", "mp3", "aac"]  # Match VideoProcessor
            format_completer = WordCompleter(supported_formats, ignore_case=True)
            format_choice = (
                prompt(
                    HTML(f"Select audio format ({'/'.join(supported_formats)}): "),
                    completer=format_completer,
                    style=style,
                )
                .strip()
                .lower()
            )

            if format_choice not in supported_formats:
                print_warning("Unsupported audio format selected.")
                return

            output_filename_base = prompt(
                "Enter the base name for the output audio file (or press Enter for default): "
            ).strip()
            if not output_filename_base:
                output_filename = f"{video.filepath.stem}_audio.{format_choice}"
            else:
                output_filename = (
                    f"{sanitize_filename(output_filename_base)}.{format_choice}"
                )

            output_file = Path(output_filename)

            self.processor.extract_audio(video, output_file, format_choice)

    def handle_merge_audio(self):
        """Handle merging an external audio file with a video."""
        video = self.select_single_video()
        if video:
            audio_file_input = prompt(
                "Enter the path to the audio file to merge: "
            ).strip()
            if not audio_file_input:
                print_warning("No audio file path entered.")
                return

            audio_file = Path(audio_file_input).expanduser()  # Expand user path
            if not audio_file.is_file():
                print_warning(f"The specified audio file does not exist: {audio_file}")
                return

            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = (
                    f"merged_{self.generate_timestamp()}{video.filepath.suffix}"
                )

            output_file = Path(output_filename)

            self.processor.merge_audio_with_video(video, audio_file, output_file)

    def handle_metadata(self):
        """Handle adding/removing metadata in a video file."""
        video = self.select_single_video()
        if video:
            output_filename = prompt(
                "Enter output file name (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = f"{sanitize_filename(video.filepath.stem)}_metadata{video.filepath.suffix}"

            output_file = Path(output_filename)

            keep_metadata_input = prompt("Keep the metadata? (y/n): ").strip().lower()
            while keep_metadata_input not in [
                "y",
                "n",
                "",
            ]:  # Allow empty for default 'y'
                print_warning("Please enter 'y' or 'n'.")
                keep_metadata_input = (
                    prompt("Keep the metadata? (y/n): ").strip().lower()
                )
            keep_metadata = keep_metadata_input != "n"  # Default is True

            self.processor.handle_metadata(video, output_file, keep_metadata)

    def handle_generate_report(self):
        """Handle generating a detailed report for a video."""
        video = self.select_single_video()
        if video:
            output_filename = prompt(
                "Enter output file name (e.g., video_report.json) (or press Enter for default): "
            ).strip()
            if not output_filename:
                output_filename = (
                    f"{sanitize_filename(video.filepath.stem)}_report.json"
                )
            elif not output_filename.lower().endswith(".json"):
                output_filename += ".json"  # Ensure json extension

            output_file = Path(output_filename)

            self.processor.generate_video_report(video, output_file)

    def handle_vapoursynth(self):
        """Handle applying a VapourSynth transformation to a video."""
        video = self.select_single_video()
        if video:
            self.processor.handle_vapoursynth(video)  # This calls the menu internally

    def handle_batch_enhance(self):
        """Handle running the batch enhancement pipeline."""
        video = self.select_single_video()
        if video:
            self.processor.batch_enhance_video(video)

    def generate_timestamp(self) -> str:
        """Generate a simple timestamp string for use in filenames."""
        return datetime.now().strftime("%Y%m%d_%H%M%S")

    def select_single_video(self) -> Optional[VideoFile]:
        """Select a single video file using fzf."""
        files = self.use_fzf_to_select_files(multiple=False)
        if files:
            filepath = Path(files[0])
            try:
                return VideoFile(filepath=filepath)
            except (ValueError, DependencyError) as e:
                print_warning(
                    f"Failed to load video properties for {filepath.name}: {e}"
                )
                logger.error(f"Failed to create VideoFile object for {filepath}: {e}")
                return None
        print_status("No file selected.", "INFO")
        return None

    def select_multiple_videos(self) -> List[VideoFile]:
        """Select multiple video files using fzf."""
        files = self.use_fzf_to_select_files(multiple=True)
        videos = []
        if files:
            for f in files:
                filepath = Path(f)
                try:
                    videos.append(VideoFile(filepath=filepath))
                except (ValueError, DependencyError) as e:
                    print_warning(
                        f"Failed to load video properties for {filepath.name}, skipping: {e}"
                    )
                    logger.error(
                        f"Failed to create VideoFile object for {filepath}: {e}"
                    )
            if not videos:
                print_warning("No valid video files selected.")
        else:
            print_status("No files selected.", "INFO")
        return videos

    @staticmethod
    def use_fzf_to_select_files(multiple: bool = False) -> List[str]:
        """
        Use fzf to select files from the current directory.
        Args:
            multiple (bool, optional): Whether to allow multiple selections. Defaults to False.
        Returns:
            List[str]: List of selected file paths.
        """
        fzf_path = find_binary("fzf", load_config())  # Find fzf using config/PATH
        if not fzf_path:
            print_warning("fzf binary not found. Cannot use file selection.")
            return []

        fzf_command = [fzf_path]
        if multiple:
            fzf_command.append("--multi")

        # Add fzf options for better usability (optional)
        fzf_command.extend(
            ["--ansi", "--preview", "mediainfo {}", "--preview-window", "right:wrap"]
        )

        try:
            # Get list of files in current directory matching video extensions
            current_dir = Path(".")
            # Use glob for potentially better performance on large directories
            files_in_dir = [
                str(f.resolve())  # Get absolute path
                for ext in VIDEO_EXTENSIONS
                for f in current_dir.glob(f"*{ext}")
                if f.is_file()
            ]

            if not files_in_dir:
                print_warning(
                    f"No video files ({', '.join(VIDEO_EXTENSIONS)}) found in the current directory."
                )
                return []

            # Run fzf with the list of files as input
            # Use Popen to handle potential large input and allow capturing stderr
            process = subprocess.Popen(
                fzf_command,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8",
                errors="replace",
            )
            # Pass the list of files to fzf's stdin
            stdout, stderr = process.communicate(input="\n".join(files_in_dir))

            if (
                process.returncode != 0 and process.returncode != 130
            ):  # 130 is typically Ctrl+C in fzf
                logger.error(f"fzf command failed with exit code {process.returncode}")
                logger.error(f"fzf stderr:\n{stderr}")
                print_warning("Error running fzf file selection.")
                return []

            # fzf outputs selected files to stdout
            selected_files = [line for line in stdout.strip().split("\n") if line]
            return selected_files

        except FileNotFoundError:
            print_warning("fzf binary not found. Cannot use file selection.")
            return []
        except Exception as e:
            logger.error(f"Error using fzf to select files: {e}", exc_info=True)
            print_warning("An unexpected error occurred while selecting files.")
            return []

    def print_help(self):
        """Display help information."""
        help_message = f"""
{CYAN}Available Commands:{NC}
  analyze          : Analyze the Video with FFmpeg
  autofix          : Detect and Auto-fix Video Issues
  normalize        : Normalize Videos for Concatenation
  change speed     : Change Video Speed (Fast/Slow) w/ Interpolation
  adjust resolution: Adjust Video Resolution
  convert format   : Convert Video into another format
  apply filters    : Apply Video Filters (FFmpeg)
  batch enhance    : Apply a series of enhancements (VapourSynth)
  help             : Show this help message
  screencaps       : Extract Frames as Screencaps
  concatenate      : Concatenate Videos Into Single Video
  extract audio    : Extract Audio from Video
  merge audio      : Merge New Audio with Video
  metadata         : Edit or Remove Metadata
  generate report  : Generate Video Report (ffprobe)
  vapoursynth      : Apply Advanced Transformations (VapourSynth)
  config           : Configure Binary Paths and Settings
  quit             : Exit the program

{CYAN}Instructions:{NC}
Type the command name and press Enter.

Use Tab for command completion.

Follow the prompts for file selection and parameters.

File selection uses fzf (fuzzy finder). Use Tab to select multiple files.

"""
        print(help_message)


def main():
    """Main function to handle CLI arguments and initialize the UserInterface."""
    parser = argparse.ArgumentParser(description="DMX Video Processing Tool")
    parser.add_argument(
        "--config",
        action="store_true",
        help="Launch Binary Paths Configuration menu on startup",
    )
    # Add option to specify input files directly (basic non-interactive mode) - Future enhancement
    # parser.add_argument(
    #     "input_files", nargs="*", help="Input video files to process"
    # )
    args = parser.parse_args()

    # Load configuration first
    config = load_config()

    # Check dependencies before starting the UI
    try:
        check_dependencies(config)
    except DependencyError as e:
        logger.critical(f"Dependency check failed: {e}")
        print_warning(f"Critical dependencies are missing: {e}")
        print_warning(
            f"Please install the required tools and ensure they are in your PATH or configured in {CONFIG_FILE}."
        )
        # Optionally display log file here as in original code
        sys.exit(1)  # Exit if dependencies are not met

    # Initialize the UI, passing the loaded and checked config
    try:
        # Pass config_mode based on CLI arg or if config file was just created
        ui = UserInterface(
            config=config, config_mode=args.config or not CONFIG_FILE.exists()
        )
        ui.main_menu()

    except Exception as e:
        # Catch any unexpected errors during UI initialization or main loop
        logger.critical(f"Fatal error during application execution: {e}", exc_info=True)
        print_warning(
            "A fatal error occurred. Displaying the log file for troubleshooting."
        )

        # Attempt to display the log file
        try:
            log_path = LOG_FILE.resolve()
            print(f"\nLog file location: {log_path}")
            if shutil.which("bat"):
                subprocess.run(
                    ["bat", str(log_path)], check=False
                )  # Don't check=True here, bat might not be found
            elif shutil.which("less"):
                subprocess.run(["less", str(log_path)], check=False)
            elif shutil.which("cat"):
                subprocess.run(["cat", str(log_path)], check=False)
            else:
                print_warning(
                    "Could not find 'bat', 'less', or 'cat' to display the log file."
                )

        except Exception as display_e:
            logger.error(f"Failed to display log file: {display_e}")
            print_warning("Failed to display the log file. Please check it manually.")

        sys.exit(1)  # Exit with a non-zero status code


if __name__ == "__main__":
    main()
