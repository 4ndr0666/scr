#!/bin/bash

# Video Merge Script
# This script automates the merging of multiple video files with varying properties.
# It normalizes videos to a default or specified resolution, frame rate, aspect ratio, and encoding,
# intelligently handles smaller videos by placing them side by side, and removes subtitles and sound by default.

# Default values
DEFAULT_RESOLUTION="1920x1080"
DEFAULT_FRAMERATE="60"
DEFAULT_ASPECT_RATIO="16:9"
DEFAULT_CRF="16"
DEFAULT_ENCODER="libx264"
DEFAULT_FORMAT="mp4"
REMOVE_SUBS_SOUND="yes"

# Function to update resolution variables
update_resolution() {
    IFS='x' read -r WIDTH HEIGHT <<< "$DEFAULT_RESOLUTION"
    if [ -z "$WIDTH" ] || [ -z "$HEIGHT" ] || ! [[ $WIDTH =~ ^[0-9]+$ ]] || ! [[ $HEIGHT =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid resolution format. Use WIDTHxHEIGHT, e.g., 1920x1080"
        exit 1
    fi
}

# Initialize resolution variables
update_resolution

# Usage function
usage() {
    echo "Usage: $0 [options]"
    echo "Options:"
    echo "  -r RESOLUTION     Set output resolution (e.g., 1920x1080)"
    echo "  -f FRAMERATE      Set output framerate (e.g., 60)"
    echo "  -a ASPECT_RATIO   Set output aspect ratio (e.g., 16:9)"
    echo "  -c CRF            Set CRF value (e.g., 16)"
    echo "  -e ENCODER        Set video encoder (e.g., libx264)"
    echo "  -o FORMAT         Set output format (e.g., mp4)"
    echo "  -k                Keep subtitles and sound"
    echo "  -h                Show this help message"
    exit 1
}

# Parse arguments
while getopts "r:f:a:c:e:o:kh" opt; do
    case $opt in
        r)
            DEFAULT_RESOLUTION="$OPTARG"
            update_resolution
            ;;
        f)
            DEFAULT_FRAMERATE="$OPTARG"
            ;;
        a)
            DEFAULT_ASPECT_RATIO="$OPTARG"
            ;;
        c)
            DEFAULT_CRF="$OPTARG"
            ;;
        e)
            DEFAULT_ENCODER="$OPTARG"
            ;;
        o)
            DEFAULT_FORMAT="$OPTARG"
            ;;
        k)
            REMOVE_SUBS_SOUND="no"
            ;;
        h)
            usage
            ;;
        *)
            usage
            ;;
    esac
done

shift $((OPTIND -1))

# Check for dependencies
for cmd in ffmpeg ffprobe fzf bc; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Error: $cmd is not installed."
        exit 1
    fi
done

# Trap to ensure cleanup on exit
trap cleanup EXIT

# Function to select files using fzf
select_files() {
    mapfile -t files < <(fzf --multi --prompt="Select video files to merge> " --preview='ffprobe -v error -show_entries stream=width,height,avg_frame_rate,codec_name -of default=noprint_wrappers=1 "{}"')
    if [ ${#files[@]} -eq 0 ]; then
        echo "No files selected. Exiting."
        exit 1
    fi
    echo "Selected files:"
    for file in "${files[@]}"; do
        echo "$file"
    done
}

# Function to normalize video
normalize_video() {
    local file="$1"
    local output_file="$2"

    echo "Normalizing video: $file"

    # Build ffmpeg command
    ffmpeg_cmd=()
    ffmpeg_cmd+=("ffmpeg" "-y" "-i" "$file")
    ffmpeg_cmd+=("-vf" "scale=w=${WIDTH}:h=${HEIGHT}:force_original_aspect_ratio=decrease,pad=w=${WIDTH}:h=${HEIGHT}:x=(ow-iw)/2:y=(oh-ih)/2:color=black")
    ffmpeg_cmd+=("-r" "$DEFAULT_FRAMERATE")
    ffmpeg_cmd+=("-c:v" "$DEFAULT_ENCODER" "-crf" "$DEFAULT_CRF")
    if [ "$REMOVE_SUBS_SOUND" = "yes" ]; then
        ffmpeg_cmd+=("-an")
    fi
    ffmpeg_cmd+=("-movflags" "+faststart")
    ffmpeg_cmd+=("$output_file")

    # Execute ffmpeg command
    if ! "${ffmpeg_cmd[@]}"; then
        echo "Error normalizing $file"
        return 1
    fi
}

# Function to handle small videos
handle_small_videos() {
    local small_files=("$@")
    local i=0
    local num_small_videos=${#small_files[@]}

    while [ $i -lt $num_small_videos ]; do
        # Process in pairs
        file1="${small_files[$i]}"
        base_name1=$(basename "$file1")
        output_file1="$temp_dir/normalized_small_$base_name1"
        if ! normalize_video "$file1" "$output_file1"; then
            echo "Error processing $file1"
            return 1
        fi

        if [ $((i+1)) -lt $num_small_videos ]; then
            # There is a second video
            file2="${small_files[$((i+1))]}"
            base_name2=$(basename "$file2")
            output_file2="$temp_dir/normalized_small_$base_name2"
            if ! normalize_video "$file2" "$output_file2"; then
                echo "Error processing $file2"
                return 1
            fi

            # Stack the two videos side by side
            combined_output="$temp_dir/combined_small_${i}.mp4"
            echo "Combining videos side by side: $output_file1 and $output_file2"
            if ! ffmpeg -y -i "$output_file1" -i "$output_file2" -filter_complex "[0:v][1:v]hstack=inputs=2" -c:v "$DEFAULT_ENCODER" -crf "$DEFAULT_CRF" "$combined_output"; then
                echo "Error combining $output_file1 and $output_file2"
                return 1
            fi
        else
            # Only one video left, pad it
            combined_output="$temp_dir/combined_small_${i}.mp4"
            echo "Padding video to fit: $output_file1"
            if ! ffmpeg -y -i "$output_file1" -vf "pad=w=${WIDTH}:h=${HEIGHT}:x=(ow-iw)/2:y=(oh-ih)/2:color=black" -c:v "$DEFAULT_ENCODER" -crf "$DEFAULT_CRF" "$combined_output"; then
                echo "Error padding $output_file1"
                return 1
            fi
        fi

        # Add combined video to input list
        echo "file '$combined_output'" >> "$input_list"

        i=$((i+2))
    done
}

# Function to merge videos
merge_videos() {
    local input_list="$1"
    local output_file="$2"

    echo "Merging videos into $output_file"
    if ! ffmpeg -y -f concat -safe 0 -i "$input_list" -c copy "$output_file"; then
        echo "Error merging videos."
        return 1
    fi
}

# Function to clean up temporary files
cleanup() {
    if [ -d "$temp_dir" ]; then
        rm -rf "$temp_dir"
    fi
}

# Main script execution
main() {
    select_files

    # Create a temporary directory for normalized videos
    temp_dir=$(mktemp -d)
    echo "Temporary directory: $temp_dir"

    # Arrays to hold video files
    declare -a regular_videos
    declare -a small_videos

    # Create input list for merging
    input_list="$temp_dir/input_list.txt"
    touch "$input_list"

    # Get target aspect ratio
    IFS=':' read -r target_w target_h <<< "$DEFAULT_ASPECT_RATIO"
    if [ -z "$target_w" ] || [ -z "$target_h" ] || ! [[ $target_w =~ ^[0-9]+$ ]] || ! [[ $target_h =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid target aspect ratio."
        exit 1
    fi
    target_aspect_ratio=$(echo "scale=4; $target_w/$target_h" | bc)

    # Process each file
    for file in "${files[@]}"; do
        # Check if file exists
        if [ ! -f "$file" ]; then
            echo "Error: File not found - $file"
            exit 1
        fi

        # Analyze video properties
        width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$file")
        height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$file")
        if [ -z "$width" ] || [ -z "$height" ]; then
            echo "Error: Could not get video dimensions for $file"
            exit 1
        fi
        aspect_ratio=$(echo "scale=4; $width/$height" | bc)

        # Compare aspect ratios
        if (( $(echo "$aspect_ratio < $target_aspect_ratio" | bc -l) )); then
            # Video is smaller than target aspect ratio
            small_videos+=("$file")
        else
            regular_videos+=("$file")
        fi
    done

    # Normalize regular videos
    for file in "${regular_videos[@]}"; do
        base_name=$(basename "$file")
        output_file="$temp_dir/normalized_$base_name"
        if ! normalize_video "$file" "$output_file"; then
            echo "Error processing $file"
            exit 1
        fi
        echo "file '$output_file'" >> "$input_list"
    done

    # Handle small videos
    if [ "${#small_videos[@]}" -gt 0 ]; then
        # Place small videos side by side
        if ! handle_small_videos "${small_videos[@]}"; then
            echo "Error handling small videos"
            exit 1
        fi
    fi

    # Merge videos
    output_file="merged_output.$DEFAULT_FORMAT"
    if ! merge_videos "$input_list" "$output_file"; then
        echo "Error merging videos"
        exit 1
    fi

    echo "Merged video saved as $output_file"
}

main "$@"
