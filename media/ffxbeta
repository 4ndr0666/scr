#!/usr/bin/env bash
#shellcheck disable=SC2207,SC2034,SC2046,SC2004,SC1009,SC1073,SC1078,SC1079,SC1036,SC1050,SC2317
# Author: 4ndr0666
# Final Superset Version: Integrates the best features from all ffx project revisions.
set -euo pipefail
# ========================== // FFX Final // ==========================

# --- XDG & Directory Setup ---
: "${XDG_CONFIG_HOME:="$HOME/.config"}"
: "${XDG_DATA_HOME:="$HOME/.local/share"}"
: "${XDG_CACHE_HOME:="$HOME/.cache"}"
: "${XDG_RUNTIME_DIR:="${TMPDIR:-/tmp}"}"

FFX_CONFIG_DIR="$XDG_CONFIG_HOME/ffx"
FFX_LOG_DIR="$XDG_DATA_HOME/ffx"
FFX_CACHE_DIR="$XDG_CACHE_HOME/ffx"
FFX_RUN_DIR="$(mktemp -d -p "${XDG_RUNTIME_DIR}" "ffx.XXXXXXXX")" # Session-specific temp files

mkdir -p "$FFX_CONFIG_DIR" "$FFX_LOG_DIR" "$FFX_CACHE_DIR"
LOG_FILE="$FFX_LOG_DIR/ffx.log"

# --- Colors and Logging ---
if command -v tput >/dev/null 2>&1 && [[ -t 1 ]]; then
	CYAN="$(tput setaf 6)"
	GREEN="$(tput setaf 2)"
	BOLD="$(tput bold)"
	RED="$(tput setaf 1)"
	RESET="$(tput sgr0)"
else
	CYAN="" GREEN="" BOLD="" RED="" RESET=""
fi

say() { printf '%b[✔️] %s%b\n' "${GREEN}${BOLD}" "$1" "${RESET}"; }
warn() { printf '%b[⚠️] %s%b\n' "${RED}" "$1" "${RESET}" >&2; }
die() {
    printf '%b[❌] Error: %s%b\n' "${RED}" "$1" "${RESET}" >&2
    exit 1
}
verbose_log() { if [ "$VERBOSE_MODE" = true ]; then printf '[INFO] %s\n' "$1"; fi; }

# --- Constants & Defaults ---
default_config() {
	ADVANCED_MODE=false
	VERBOSE_MODE=false
	DRY_RUN=false
	REMOVE_AUDIO=false
	COMPOSITE_MODE=false
	MAX_1080=false
	INTERPOLATE=false
	OUTPUT_DIR="$(pwd)"
	SPECIFIC_FPS=""
	PTS_FACTOR=""
    FFX_TIMEOUT="${FFX_TIMEOUT:-300}" # Default 5-minute timeout for ffmpeg

	# Advanced options (can be overridden by config file)
	ADV_CONTAINER="mp4"
	ADV_RES="1920x1080"
	ADV_FPS="60"
	ADV_CODEC="libx264"
	ADV_PIX_FMT="yuv420p"
	ADV_CRF="18"
}
default_config

# --- TRAP and Cleanup ---
cleanup_all() {
	[ -d "$FFX_RUN_DIR" ] && rm -rf "$FFX_RUN_DIR"
}
trap 'cleanup_all' EXIT INT TERM

## FFmpeg Runner
run_ffmpeg() {
	if [ "$DRY_RUN" = true ]; then
		printf "[DRY-RUN] ffmpeg %q \n" "$@"
		return 0
	fi

    local -a base_cmd=("timeout" "$FFX_TIMEOUT" "ffmpeg" "-hide_banner")
    if [ "$VERBOSE_MODE" = true ]; then
        base_cmd+=("-v" "info")
        printf "Executing FFmpeg (timeout ${FFX_TIMEOUT}s)... Log: ${LOG_FILE}\n"
        "${base_cmd[@]}" "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=${PIPESTATUS[0]}
    else
        base_cmd+=("-v" "error")
        # Overwrite log for new command, append during command
        >"$LOG_FILE"
        "${base_cmd[@]}" "$@" >>"$LOG_FILE" 2>&1
        local exit_code=$?
    fi

    if [ "$exit_code" -eq 124 ]; then
        die "FFmpeg command timed out after ${FFX_TIMEOUT} seconds. Use --timeout to extend."
    elif [ "$exit_code" -ne 0 ]; then
        warn "FFmpeg failed (exit code $exit_code). See log for details: $LOG_FILE"
        tail -n 10 "$LOG_FILE" >&2
        return 1
    fi
    return 0
}

# --- Validation & Helpers ---
command_exists() { command -v "$1" >/dev/null 2>&1; }
check_deps() {
	for dep in ffmpeg ffprobe bc awk timeout; do
		command_exists "$dep" || die "Required dependency '$dep' is not installed."
	done
}
absolute_path() {
	readlink -f "$1" 2>/dev/null || realpath "$1" 2>/dev/null || (cd "$(dirname "$1")" && echo "$(pwd)/$(basename "$1")")
}
get_default_filename() {
	local base="${1:-out}" suffix="${2:-tmp}" ext="${3:-mp4}"
	local candidate="${OUTPUT_DIR}/${base}_${suffix}.${ext}"
	local counter=1
	while [ -e "$candidate" ]; do
		candidate="${OUTPUT_DIR}/${base}_${suffix}_${counter}.${ext}"
		counter=$((counter + 1))
	done
	echo "$candidate"
}
mktemp_ffx() { mktemp -p "$FFX_RUN_DIR" --suffix="${1:-.tmp}"; }

# --- Audio Options ---
get_audio_opts_array() {
	if [ "$REMOVE_AUDIO" = true ]; then
		printf '%s\n' "-an"
	else
		printf '%s\n' "-c:a" "copy"
	fi
}

# --- DTS & Timestamp Correction ---
check_dts_for_file() {
	ffprobe -v error -select_streams v -show_entries frame=pkt_dts_time -of csv=p=0 "$1" 2>/dev/null |
		awk 'NR > 1 && $1 < prev { exit 1 } { prev = $1 }'
}
fix_dts() {
	local file="$1" tmpf
	tmpf="$(mktemp_ffx .mp4)"
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)

	if ! run_ffmpeg -y -fflags +genpts -i "$file" -c:v copy "${audio_opts[@]}" -movflags +faststart "$tmpf"; then
		verbose_log "DTS fix fallback: Re-encoding '$file' losslessly."
		if ! run_ffmpeg -y -fflags +genpts -i "$file" -c:v "$ADV_CODEC" -qp 0 -preset ultrafast "${audio_opts[@]}" "$tmpf"; then
			warn "Could not fix DTS for '$file'"
			return 1
		fi
	fi
	echo "$tmpf"
}
ensure_dts_correct() {
	local file="$1"
	[ ! -f "$file" ] && die "ensure_dts_correct: '$file' not found."
	if ! check_dts_for_file "$file"; then
		verbose_log "DTS issues found in '$file', attempting fix..."
		local fixed
		fixed="$(fix_dts "$file")" || return 1
		[ ! -s "$fixed" ] && die "DTS fix failed for '$file' (output was empty)."
		echo "$fixed"
	else
		echo "$file"
	fi
}

# =============================================================================
# === COMMANDS ================================================================
# =============================================================================

## probe
cmd_probe() {
	local input="${1:-}"
	if [ -z "$input" ]; then
		command_exists fzf || die "fzf not found."
		echo "➡️ No file provided. Launching fzf..."
		input="$(fzf)"
		[ -z "$input" ] && die "No file selected."
	fi
	[ ! -f "$input" ] && die "File not found: $input"

	local sz hsz resolution fps duration
	sz="$(stat -c '%s' "$input" 2>/dev/null || echo 0)"
	hsz=$(awk -v b="$sz" 'BEGIN{split("B KiB MiB GiB",u);i=1;while(b>=1024&&i<4){b/=1024;i++}printf"%.2f %s",b,u[i]}')
	resolution="$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "$input" 2>/dev/null || echo 'unknown')"
	fps="$(ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 "$input" 2>/dev/null || echo '0/0')"
	duration="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input" 2>/dev/null || echo 0)"

	printf '%b# === FFX Probe ===%b\n' "${CYAN}${BOLD}" "${RESET}"
	printf '%bFile:%b %s\n' "${CYAN}" "${RESET}" "$input"
	printf '%bSize:%b %s\n' "${CYAN}" "${RESET}" "$hsz"
	printf '%b--------------------------------%b\n' "${CYAN}" "${RESET}"
	printf '%bResolution:%b   %s\n' "${CYAN}" "${RESET}" "$resolution"
	printf '%bFPS:%b          %s\n' "${CYAN}" "${RESET}" "$fps"
	printf '%bDuration:%b     %ss\n' "${CYAN}" "${RESET}" "$duration"
}

## process
cmd_process() {
	local input="${1:-}" output="${2:-}"
	[ -z "$input" ] && die "'process' requires an input file."
	[ ! -s "$input" ] && die "Input file is zero-length or not found: $input"

	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "processed" "$ADV_CONTAINER")"
	[ -n "$SPECIFIC_FPS" ] && ADV_FPS="$SPECIFIC_FPS"

	local fixed_input; fixed_input="$(ensure_dts_correct "$input")" || die "DTS fix failed for '$input'"

	if [ "$MAX_1080" = true ]; then
		local orig_height; orig_height="$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$fixed_input" 2>/dev/null || echo 0)"
		if [[ "$orig_height" =~ ^[0-9]+$ ]] && [ "$orig_height" -gt 1080 ]; then
			verbose_log "Forcing downscale to 1080p due to --max-1080 flag."
			ADV_RES="1920x1080"
		fi
	fi

	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	local scale_filter="scale=${ADV_RES}:force_original_aspect_ratio=decrease"

	run_ffmpeg -y -i "$fixed_input" -vf "$scale_filter" -r "$ADV_FPS" \
		-c:v "$ADV_CODEC" -crf "$ADV_CRF" -preset medium "${audio_opts[@]}" \
		-movflags +faststart "$output" || die "Re-encode failed."

	say "Processed: $output"
}

## Internal helper for merge -C to composite a PAIR of videos side-by-side
composite_pair_lossless() {
    local file1="$1" file2="$2"
    local output_composite; output_composite="$(mktemp_ffx -composite-pair.mp4)"

    local w1 h1 w2 h2
    read -r w1 h1 < <(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of default=nw=1:nk=1 "$file1" | xargs)
    read -r w2 h2 < <(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of default=nw=1:nk=1 "$file2" | xargs)
    local max_h=$(( h1 > h2 ? h1 : h2 ))
    verbose_log "Compositing pair. Canvas height will be $max_h."

    local filter_complex="[0:v]scale=-2:${max_h}[v0];[1:v]scale=-2:${max_h}[v1];[v0][v1]hstack=inputs=2[vout]"
    local -a ffmpeg_args=("-y" "-i" "$file1" "-i" "$file2")
    local audio_streams=0 audio_filter=""

    if [ "$REMOVE_AUDIO" = false ]; then
        if ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 "$file1" 2>/dev/null | grep -q '.*'; then
            audio_filter+="[0:a]"; audio_streams=$((audio_streams + 1))
        fi
        if ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 "$file2" 2>/dev/null | grep -q '.*'; then
            audio_filter+="[1:a]"; audio_streams=$((audio_streams + 1))
        fi
    fi

    if [ "$audio_streams" -gt 0 ]; then
        filter_complex+=";${audio_filter}amerge=inputs=${audio_streams}[aout]"
        ffmpeg_args+=("-map" "[vout]" "-map" "[aout]")
    else
        ffmpeg_args+=("-map" "[vout]")
    fi

    ffmpeg_args+=("-filter_complex" "$filter_complex" "-c:v" "libx264" "-qp" "0" "-preset" "ultrafast" "$output_composite")
    run_ffmpeg "${ffmpeg_args[@]}" || die "Intermediate pair compositing failed."
    echo "$output_composite"
}

## merge
cmd_merge() {
	local files=() output=""
	while [ $# -gt 0 ]; do
		case "$1" in
		-o | --output) output="$2"; shift 2 ;;
		*) files+=("$1"); shift ;;
		esac
	done

	if [ "${#files[@]}" -lt 1 ]; then
		command_exists fzf || die "fzf is required for interactive selection."
		mapfile -t files < <(fzf --multi)
		[ "${#files[@]}" -lt 1 ] && die "No files selected for merge."
	fi
	[ -z "$output" ] && output="$(get_default_filename "output" "merged" "$ADV_CONTAINER")"
	
	local dts_fixed_files=()
    # PARALLEL PRE-PROCESSING
    local -a pids=()
    local results_dir; results_dir="$(mktemp -d -p "$FFX_RUN_DIR")"
    verbose_log "Pre-processing ${#files[@]} files in parallel..."
    for i in "${!files[@]}"; do
        local f="${files[i]}"
        [ ! -f "$f" ] && die "File not found: $f"
        # Run each fix in the background, writing the result path to a unique file
        (
            # Pass required functions and variables to the subshell
            declare -f ensure_dts_correct check_dts_for_file fix_dts run_ffmpeg mktemp_ffx get_audio_opts_array die warn verbose_log
            declare -x FFX_RUN_DIR FFX_TIMEOUT DRY_RUN VERBOSE_MODE ADV_CODEC RED RESET LOG_FILE REMOVE_AUDIO
            ensure_dts_correct "$f" > "$results_dir/$i"
        ) &
        pids+=($!)
    done

    # Wait for all background jobs to finish
    local failed_jobs=0
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            warn "A pre-processing job (PID $pid) failed."
            failed_jobs=$((failed_jobs + 1))
        fi
    done
    [ "$failed_jobs" -gt 0 ] && die "$failed_jobs pre-processing job(s) failed. Check logs for details."
    verbose_log "All pre-processing jobs complete."

    # Collect results
    for i in "${!files[@]}"; do
        local result_file="$results_dir/$i"
        if [ -s "$result_file" ]; then
            dts_fixed_files+=("$(<"$result_file")")
        else
            die "Failed to get processed path for '${files[i]}'."
        fi
    done


	local segments_to_concat=()
	if [ "$COMPOSITE_MODE" = true ]; then
		verbose_log "Composite mode enabled. Grouping files by aspect ratio."
		local -a widescreen_files=() other_files=()
		for f in "${dts_fixed_files[@]}"; do
			local w h; read -r w h < <(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of default=nw=1:nk=1 "$f" | xargs)
			if [ "$h" -eq 0 ]; then other_files+=("$f"); continue; fi
			if awk -v w="$w" -v h="$h" 'BEGIN{ exit (w/h >= 1.77) ? 0 : 1 }'; then
				widescreen_files+=("$f")
			else
				other_files+=("$f")
			fi
		done
		segments_to_concat+=("${widescreen_files[@]}")
		local i=0
		while [ "$i" -lt "${#other_files[@]}" ]; do
			if [ $((i + 1)) -lt "${#other_files[@]}" ]; then
				segments_to_concat+=("$(composite_pair_lossless "${other_files[i]}" "${other_files[i+1]}")")
				i=$((i + 2))
			else
				segments_to_concat+=("${other_files[i]}"); i=$((i + 1))
			fi
		done
	else
        local uniform=true first_res
        first_res=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "${dts_fixed_files[0]}")
        for ((i=1; i<${#dts_fixed_files[@]}; i++)); do
            local current_res; current_res=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0:s=x "${dts_fixed_files[i]}")
            [ "$first_res" != "$current_res" ] && uniform=false && break
        done

        if [ "$uniform" = false ]; then
            verbose_log "Resolutions differ. Re-encoding all videos losslessly to match first video ($first_res)."
            local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
            for f in "${dts_fixed_files[@]}"; do
                local tmpf; tmpf="$(mktemp_ffx .mp4)"
                run_ffmpeg -y -i "$f" -vf "scale=$first_res" -c:v libx264 -qp 0 -preset ultrafast "${audio_opts[@]}" "$tmpf" || die "Preprocessing failed for '$f'"
                segments_to_concat+=("$tmpf")
            done
        else
		    segments_to_concat=("${dts_fixed_files[@]}")
        fi
	fi

	local concat_list; concat_list="$(mktemp_ffx .txt)"
	for f in "${segments_to_concat[@]}"; do echo "file '$(absolute_path "$f")'" >>"$concat_list"; done

	run_ffmpeg -y -f concat -safe 0 -i "$concat_list" -c copy "$output" || die "Final merge/concatenation failed."
	say "Merged: $output"
}

## looperang
cmd_looperang() {
	local input="${1:-}" output="${2:-}"
	[ -z "$input" ] && die "looperang requires an input file."
	[ ! -f "$input" ] && die "File not found: $input"
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "looperang" "$ADV_CONTAINER")"

	local fixed_input; fixed_input="$(ensure_dts_correct "$input")" || die "DTS fix failed."
	local tmp_rev; tmp_rev="$(mktemp_ffx .mp4)"
	
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	run_ffmpeg -y -i "$fixed_input" -vf reverse -af areverse "${audio_opts[@]}" -c:v libx264 -qp 0 -preset ultrafast "$tmp_rev" || die "Failed to create reversed segment."

	local concat_list; concat_list="$(mktemp_ffx .txt)"
	echo "file '$(absolute_path "$fixed_input")'" >>"$concat_list"
	echo "file '$(absolute_path "$tmp_rev")'" >>"$concat_list"

	run_ffmpeg -y -f concat -safe 0 -i "$concat_list" -c copy "$output" || die "Looperang concatenation failed."
	say "Looperang: $output"
}

## slowmo
cmd_slowmo() {
	local input="${1:-}" output="${2:-}" factor="${3:-2}"
	[ -n "$PTS_FACTOR" ] && factor="$PTS_FACTOR"
	[ -z "$input" ] && die "slowmo requires an input file."
	[ ! -f "$input" ] && die "File not found: $input"
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "slowmo" "$ADV_CONTAINER")"

	local fps_val="$ADV_FPS"; [ -n "$SPECIFIC_FPS" ] && fps_val="$SPECIFIC_FPS"
	local vfilter="setpts=${factor}*PTS" afilter=""

	if [ "$INTERPOLATE" = true ]; then
		[ -z "$SPECIFIC_FPS" ] && fps_val="120" && verbose_log "Defaulting interpolation to 120 FPS."
		vfilter="minterpolate=fps=${fps_val}:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:vsbmc=1,${vfilter}"
	fi
	
	local -a ffmpeg_args=("-y" "-i" "$input")
	if [ "$REMOVE_AUDIO" = false ]; then
		local speed; speed=$(bc -l <<<"1 / $factor")
		while (( $(echo "$speed < 0.5" | bc -l) )); do afilter+="atempo=0.5,"; speed=$(bc -l <<<"$speed / 0.5"); done
		while (( $(echo "$speed > 2.0" | bc -l) )); do afilter+="atempo=2.0,"; speed=$(bc -l <<<"$speed / 2.0"); done
		afilter+="atempo=$speed"
		ffmpeg_args+=("-filter_complex" "[0:v]${vfilter}[v];[0:a]${afilter}[a]" "-map" "[v]" "-map" "[a]")
	else
		ffmpeg_args+=("-vf" "$vfilter" "-an")
	fi

	ffmpeg_args+=("-r" "$fps_val" "-c:v" "$ADV_CODEC" "-crf" "$ADV_CRF" "-preset" "medium" "$output")
	run_ffmpeg "${ffmpeg_args[@]}" || die "Slowmo operation failed."
	say "Slow motion: $output"
}

## fix
cmd_fix() {
	local input="${1:-}" output="${2:-}"
	[ -z "$input" ] && die "fix requires an input file."
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "fixed" "$ADV_CONTAINER")"
	local fixed_input; fixed_input=$(ensure_dts_correct "$input") || die "Fix command failed for '$input'"
	if [ "$fixed_input" != "$input" ]; then mv "$fixed_input" "$output"; say "Fixed: $output";
	else cp "$input" "$output"; say "No DTS issues found, file copied: $output"; fi
}

## clean
cmd_clean() {
	local input="${1:-}" output="${2:-}"
	[ -z "$input" ] && die "clean requires an input file."
	[ ! -f "$input" ] && die "File not found: $input"
	[ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "cleaned" "$ADV_CONTAINER")"
	local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
	run_ffmpeg -y -i "$input" -map_metadata -1 -c copy "${audio_opts[@]}" "$output" || die "Metadata cleaning failed."
	say "Metadata cleaned: $output"
}

## cache-clean
cmd_cache_clean() {
	echo "This will remove all ffx-related cache files in: $FFX_CACHE_DIR"
	local ans; read -r -p "Are you sure? (y/N): " ans
	if [[ "${ans:-n}" =~ ^[Yy]$ ]]; then
		rm -rf -- "$FFX_CACHE_DIR"; mkdir -p -- "$FFX_CACHE_DIR"; say "Cache cleaned."
	else echo "Aborted."; fi
}

## clip
cmd_clip() {
    local input="${1:-}" output="${2:-}"
    if [ -z "$input" ]; then
        command_exists fzf || die "fzf not found."
        input="$(fzf)"
        [ -z "$input" ] && die "No file selected."
    fi
    [ ! -f "$input" ] && die "File not found: $input"
    [ -z "$output" ] && output="$(get_default_filename "$(basename "${input%.*}")" "clip" "$ADV_CONTAINER")"

    local dur; dur="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input")"
    echo "Total duration: $dur seconds."
    local st et; read -r -p "Enter start time (HH:MM:SS or seconds): " st
    read -r -p "Enter end time (HH:MM:SS or seconds): " et
    [ -z "$st" ] || [ -z "$et" ] && die "Start and end times are required."

    local -a audio_opts; mapfile -t audio_opts < <(get_audio_opts_array)
    run_ffmpeg -y -ss "$st" -to "$et" -i "$input" -c copy "${audio_opts[@]}" "$output" || die "Clip operation failed (try re-encoding if stream copy fails)."
    say "Clip created: $output"
}

# =============================================================================
# === PARSING & DISPATCH ======================================================
# =============================================================================

display_usage() {
	cat <<EOF
Usage: ffx [global options] <command> [arguments]

${BOLD}Global Options:${RESET}
  -v, --verbose         Enable verbose FFmpeg logging to terminal and log file.
  -an, --remove-audio   Remove audio tracks from output.
  -P, --max-1080        Enforce max height of 1080p for 'process'.
  -o, --output-dir <d>  Specify output directory (default: current dir).
  -f, --fps <val>       Force output FPS for relevant commands.
  -p, --pts <val>       Set slow-mo PTS factor (e.g., 2 for half speed).
  -i, --interpolate     Enable motion interpolation for 'slowmo'.
  -C, --composite       Enable composite mode for 'merge' command.
  --timeout <sec>       Set FFmpeg command timeout in seconds (default: 300).
  --dry-run             Print ffmpeg commands instead of executing them.
  -h, --help            Display this help information.

${BOLD}Commands:${RESET}
  probe <input>             Display file info.
  process <input> [output]  Re-encode a file with scaling/fps options.
  merge [files...] [-o <out>] [-C]
                            Merge videos. With -C, wide-screen videos play solo
                            while portrait/square videos are paired side-by-side.
  looperang <input> [output]  Create a boomerang (forward-reverse) effect.
  slowmo <in> [out] [factor]  Apply slow-motion to a video.
  fix <input> [output]      Fix DTS/timestamp issues by remuxing or re-encoding.
  clean <input> [output]    Remove all non-essential metadata.
  clip <input> [output]     Interactively trim a video by start/end times.
  cache-clean               Removes all temporary files created by this script.
EOF
	exit 0
}
parse_global_options() {
	REMAINING_ARGS=()
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-A | --advanced) ADVANCED_MODE=true; shift ;;
		-v | --verbose) VERBOSE_MODE=true; shift ;;
		-an | --remove-audio) REMOVE_AUDIO=true; shift ;;
		-C | --composite) COMPOSITE_MODE=true; shift ;;
		-P | --max-1080) MAX_1080=true; shift ;;
		-i | --interpolate) INTERPOLATE=true; shift ;;
		--dry-run) DRY_RUN=true; shift ;;
		-o | --output-dir) [[ -z "${2:-}" ]] && die "Option '$1' requires an argument."; OUTPUT_DIR="$2"; shift 2 ;;
		-f | --fps) [[ -z "${2:-}" ]] && die "Option '$1' requires an argument."; SPECIFIC_FPS="$2"; shift 2 ;;
		-p | --pts) [[ -z "${2:-}" ]] && die "Option '$1' requires an argument."; PTS_FACTOR="$2"; shift 2 ;;
		--timeout) [[ -z "${2:-}" ]] && die "Option '$1' requires an argument."; FFX_TIMEOUT="$2"; shift 2 ;;
		-h | --help | help) display_usage ;;
		--) shift; REMAINING_ARGS+=("$@"); break ;;
		-*) REMAINING_ARGS+=("$@"); break ;;
		*) REMAINING_ARGS+=("$@"); break ;;
		esac
	done
}
main_dispatch() {
	local cmd="${1:-help}"
	shift || true
	case "$cmd" in
	probe) cmd_probe "$@" ;;
	process) cmd_process "$@" ;;
	merge) cmd_merge "$@" ;;
	looperang) cmd_looperang "$@" ;;
	slowmo) cmd_slowmo "$@" ;;
	fix) cmd_fix "$@" ;;
	clean) cmd_clean "$@" ;;
	cache-clean) cmd_cache_clean "$@" ;;
    clip) cmd_clip "$@" ;;
	help) display_usage ;;
	*) die "Unrecognized command: $cmd" ;;
	esac
}
main() {
	check_deps
	parse_global_options "$@"
	if [ "${#REMAINING_ARGS[@]}" -lt 1 ]; then
		display_usage
	fi
	main_dispatch "${REMAINING_ARGS[@]}"
}

main "$@"
