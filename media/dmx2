#!/usr/bin/env python3
import os
import sys
import subprocess
import json
import logging
from concurrent.futures import ThreadPoolExecutor, TimeoutError
from typing import List, Dict, Any
from fractions import Fraction
import shutil
import tempfile
import textwrap
from tqdm import tqdm
from datetime import datetime

# --- // Ensure custom_ffmpeg_build on path:
os.environ['PATH'] = f"{os.path.expanduser('~/bin')}:{os.environ.get('PATH', '')}"

# --- // Constants
SUPPORTED_CODECS = ['avc', 'h264', 'hev1', 'h265', 'hevc']
DEFAULT_VIDEO_CODEC = 'libx264'
DEFAULT_AUDIO_CODECS = ['aac', 'libopus', 'libmp3lame']
REQUIRED_TOOLS = ['ffmpeg', 'mediainfo', 'fzf', 'vspipe']
GREEN = "\033[38;2;57;255;20m"
BOLD = "\033[1m"
RED = "\033[0;31m"
NC = "\033[0m"  # No Color
MAX_WORKERS = os.cpu_count()

logging.basicConfig(
    filename='video_processing.log',
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)

def print_warning(message: str):
    """Print a warning message."""
    print(f"{RED}⚠️  {message}{NC}")
    logging.warning(message)

def print_status(message: str, status: str = "OK"):
    """Print a status message with a symbol."""
    status_symbol = f"{GREEN}✓{NC}" if status == "OK" else f"{RED}❌{NC}"
    print(f"{message} [{status_symbol}]\n")
    logging.info(f"{message} [{status}]")

def check_dependencies():
    """Check if required dependencies are installed."""
    missing_commands = [cmd for cmd in REQUIRED_TOOLS if not shutil.which(cmd)]
    if missing_commands:
        print_warning(f"The following required commands are missing: {', '.join(missing_commands)}")
        print_warning("Please install them using your package manager and try again.")
        sys.exit(1)

    # Check if ffmpeg has libx264 encoder
    try:
        result = subprocess.run(['ffmpeg', '-encoders'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if 'libx264' not in result.stdout:
            print_warning("FFmpeg does not have 'libx264' encoder support.")
            print_warning("Please install FFmpeg with 'libx264' support and try again.")
            sys.exit(1)
    except Exception as e:
        logging.error(f"Error checking FFmpeg encoders: {e}")
        print_warning("An error occurred while checking FFmpeg encoders. Check the logs for more details.")
        sys.exit(1)
    logging.info("All dependencies are satisfied.")

def find_svp_plugins():
    """Find the paths to SVP plugin files."""
    possible_paths = [
        "/usr/lib/vapoursynth",
        "/usr/local/lib/vapoursynth",
        "/home/build/vapoursynth-plugin-svpflow2-bin/src/svpflow-4.3.0.168/lib-linux/",
        os.path.expanduser("~/.local/lib/vapoursynth"),
        "/opt/svp/lib64/vapoursynth",
        "/opt/svp/lib/vapoursynth",
        os.path.expanduser("~/vapoursynth")
    ]
    svp_plugins = {}
    for path in possible_paths:
        lib1 = os.path.join(path, "libsvpflow1_vs64.so")
        lib2 = os.path.join(path, "libsvpflow2_vs64.so")
        if os.path.isfile(lib1) and os.path.isfile(lib2):
            svp_plugins['lib1'] = lib1
            svp_plugins['lib2'] = lib2
            logging.info(f"Found SVP plugins at {path}")
            return svp_plugins
    # If not found, print a warning and exit
    print_warning("SVP plugins 'libsvpflow1_vs64.so' and 'libsvpflow2_vs64.so' not found in standard locations.")
    print_warning("Please install SVP plugins or specify their paths in the 'find_svp_plugins' function.")
    sys.exit(1)

def find_ffms2_plugin():
    """Find the path to the ffms2 VapourSynth plugin."""
    possible_paths = [
        "/usr/lib/vapoursynth",
        "/usr/local/lib/vapoursynth",
        os.path.expanduser("~/.local/lib/vapoursynth"),
        "/home/build/ffms2/lib/",
        "/opt/vapoursynth/lib/",
        os.path.expanduser("~/vapoursynth")
    ]
    for path in possible_paths:
        lib_ffms2 = os.path.join(path, "libffms2.so")
        if os.path.isfile(lib_ffms2):
            logging.info(f"Found ffms2 plugin at {path}")
            return lib_ffms2
    print_warning("ffms2 plugin 'libffms2.so' not found in standard locations.")
    print_warning("Please install ffms2 or specify its path in the 'find_ffms2_plugin' function.")
    sys.exit(1)

def run_command(command: List[str], description: str = "", display_output: bool = False) -> str:
    """Run a system command and optionally display its output in real-time."""
    try:
        logging.info(f"Running command: {' '.join(command)}")
        if display_output:
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            output = ''
            for line in process.stdout:
                print(line, end='')  # Display output in real-time
                output += line
            process.wait()
            return_code = process.returncode
            if return_code != 0:
                raise subprocess.CalledProcessError(return_code, command)
            logging.info(f"{description} - Command executed successfully: {' '.join(command)}")
            return output
        else:
            result = subprocess.run(command, check=True, capture_output=True, text=True)
            logging.info(f"{description} - Command executed successfully: {' '.join(command)}")
            return result.stdout
    except subprocess.CalledProcessError as e:
        logging.error(f"{description} - Command '{' '.join(command)}' failed with exit code {e.returncode}")
        print_warning(f"An error occurred while executing a command. Check the logs for more details.")
        raise
    except Exception as e:
        logging.error(f"{description} - An unexpected error occurred: {e}")
        print_warning(f"An unexpected error occurred. Check the logs for more details.")
        raise

class VideoFile:
    """Represents a video file and its properties."""

    def __init__(self, filepath: str):
        self.filepath = os.path.abspath(filepath)
        self.basename = os.path.basename(self.filepath)
        self.width = 0
        self.height = 0
        self.frame_rate = 0.0
        self.codec = ''
        self.audio_codec = ''
        self.duration = 0.0
        self.bitrate = 0
        self.has_audio = False
        self.issues = []
        self._get_properties()

    def _get_properties(self):
        """Extract properties using ffprobe."""
        try:
            # Get video properties
            command = [
                'ffprobe', '-v', 'error',
                '-select_streams', 'v:0',
                '-show_entries', 'stream=width,height,r_frame_rate,codec_name,duration,bit_rate',
                '-of', 'json', self.filepath
            ]
            result_stdout = run_command(command, description=f"Getting video properties for {self.basename}")
            data = json.loads(result_stdout)
            stream = data['streams'][0]
            self.width = int(stream.get('width', 0))
            self.height = int(stream.get('height', 0))
            self.codec = stream.get('codec_name', '')
            fps_str = stream.get('r_frame_rate', '0/1')
            self.frame_rate = float(Fraction(fps_str))
            self.duration = float(stream.get('duration', 0.0))
            self.bitrate = int(stream.get('bit_rate', 0))
            logging.info(f"Video properties for {self.filepath}: {self.width}x{self.height}, {self.frame_rate}fps, codec={self.codec}")

            # Check for audio stream
            command = [
                'ffprobe', '-v', 'error',
                '-select_streams', 'a:0',
                '-show_entries', 'stream=codec_name',
                '-of', 'json', self.filepath
            ]
            result_stdout = run_command(command, description=f"Checking audio properties for {self.basename}")
            data = json.loads(result_stdout)
            if data.get('streams'):
                self.has_audio = True
                self.audio_codec = data['streams'][0].get('codec_name', '')
                logging.info(f"Audio codec for {self.filepath}: {self.audio_codec}")
            else:
                self.has_audio = False
                logging.info(f"No audio stream in {self.filepath}")
        except Exception as e:
            logging.error(f"Error getting properties for {self.filepath}: {e}")
            raise

    def detect_issues(self, fix_issues=False):
        """Detect potential issues with the video file and attempt mitigation."""
        logging.info(f"Detecting issues for video {self.filepath}")
        if self.width == 0 or self.height == 0:
            self.issues.append('Resolution not detected.')
        if self.frame_rate == 0.0:
            self.issues.append('Frame rate not detected.')
        if self.codec.lower() not in SUPPORTED_CODECS:
            self.issues.append(f'Unsupported codec: {self.codec}')
        if not os.path.exists(self.filepath):
            self.issues.append('File does not exist.')
        if self.duration == 0.0:
            self.issues.append('Duration not detected.')

        if self.issues:
            print_warning(f"Issues detected in {self.basename}:")
            for issue in self.issues:
                print_warning(f" - {issue}")
            if fix_issues:
                self.attempt_fix()
            else:
                fix = input("Would you like to attempt to fix these issues? (y/n): ").lower()
                if fix == 'y':
                    self.attempt_fix()
        else:
            print_status(f"No issues detected in {self.basename}")

    def attempt_fix(self, output_dir='.'):
        """Attempt to fix detected issues."""
        logging.info(f"Attempting to fix issues for video {self.filepath}")
        output_file = os.path.join(output_dir, f"fixed_{self.basename}")
        try:
            command = ['ffmpeg', '-y', '-i', self.filepath]
            if self.codec.lower() in ['vp8', 'vp9']:
                command += ['-c:v', 'libvpx', '-b:v', '1M', '-c:a', 'libvorbis']
            else:
                command += ['-c:v', DEFAULT_VIDEO_CODEC, '-preset', 'fast', '-b:v', '1M']
                if self.has_audio:
                    command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
                else:
                    command += ['-an']
            command += [output_file]
            run_command(command, description=f"Fixing issues for {self.basename}")
            print_status(f"Issues fixed for {self.basename}. Saved as {output_file}")
            self.filepath = os.path.abspath(output_file)
            self.basename = os.path.basename(self.filepath)
            self._get_properties()
            self.issues = []  # Clear issues after fixing
        except Exception as e:
            logging.error(f"Error fixing issues for {self.basename}: {e}")
            print_warning(f"Failed to fix issues for {self.basename}")

class FFmpegCommandBuilder:
    """Helper class to build and execute FFmpeg commands."""
    
    @staticmethod
    def build_adjust_resolution_command(video: VideoFile, resolution: str, output_file: str) -> List[str]:
        command = [
            'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
            '-vf', f"scale={resolution}",
            '-c:v', DEFAULT_VIDEO_CODEC,
            '-preset', 'fast',
            '-b:v', '1M'
        ]
        if video.has_audio:
            command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
        else:
            command += ['-an']
        command += [os.path.abspath(output_file)]
        return command

    @staticmethod
    def build_convert_format_command(video: VideoFile, new_format: str, output_file: str) -> List[str]:
        format_codecs = {
            'mp4': ['-c:v', 'copy', '-c:a', 'copy'],
            'mkv': ['-c:v', 'copy', '-c:a', 'copy'],
            'avi': ['-c:v', 'libxvid', '-c:a', 'libmp3lame'],
            'mov': ['-c:v', 'copy', '-c:a', 'copy']
        }
        codecs = format_codecs.get(new_format.lower())
        if not codecs:
            raise ValueError(f"Unsupported format: {new_format}")
        command = ['ffmpeg', '-y', '-i', os.path.abspath(video.filepath)] + codecs + [os.path.abspath(output_file)]
        return command

    @staticmethod
    def build_filter_command(video: VideoFile, filters: str, output_file: str) -> List[str]:
        filter_chain = ",".join([f.strip() for f in filters.split(',') if f.strip()])
        command = [
            'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
            '-vf', filter_chain, '-c:v', DEFAULT_VIDEO_CODEC,
            '-preset', 'fast', '-b:v', '1M'
        ]
        if video.has_audio:
            command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
        else:
            command += ['-an']
        command += [os.path.abspath(output_file)]
        return command

class VideoProcessor:
    """Processes video files based on user commands."""
    
    def __init__(self, max_workers=None):
        self.executor = ThreadPoolExecutor(max_workers=max_workers or MAX_WORKERS)
        self.svp_plugins = find_svp_plugins()

    def analyze_video(self, video: VideoFile):
        """Analyze a video file using MediaInfo."""
        logging.info(f"Analyzing video {video.filepath}")
        try:
            command = ['mediainfo', video.filepath]
            output = run_command(command, description=f"Analyzing video {video.basename}")
            print(output)
        except Exception as e:
            logging.error(f"Error analyzing video {video.filepath}: {e}")
            print_warning(f"Error analyzing video {video.basename}")

    def normalize_videos(self, videos: List[VideoFile], output_dir: str):
        """Normalize videos to common properties."""
        logging.info("Starting normalization of videos")
        target_props = self.determine_common_properties(videos)
        normalized_files = []
        futures = []
        for video in videos:
            futures.append(self.executor.submit(self._normalize_video, video, target_props, output_dir))

        for future in tqdm(futures, desc="Normalizing videos"):
            try:
                result = future.result(timeout=1200)  # Increased timeout for larger files
                if result:
                    normalized_files.append(result)
            except TimeoutError:
                logging.error("Normalization task timed out.")
                print_warning("A normalization task timed out.")
            except Exception as e:
                logging.error(f"Error during normalization: {e}")
                print_warning("An error occurred during normalization.")
        return normalized_files

    def _normalize_video(self, video: VideoFile, target_props: Dict[str, Any], output_dir: str):
        """Normalize a single video."""
        output_file = os.path.join(output_dir, f"normalized_{video.basename}")
        need_reencode = (
            (video.width, video.height) != target_props['resolution'] or
            abs(video.frame_rate - target_props['frame_rate']) > 0.1 or
            video.codec.lower() not in SUPPORTED_CODECS
        )
        try:
            command = ['ffmpeg', '-y', '-i', os.path.abspath(video.filepath)]
            if not need_reencode:
                logging.info(f"{video.basename} matches target properties, copying streams")
                if video.has_audio:
                    command += ['-c:v', 'copy', '-c:a', 'copy']
                else:
                    command += ['-c:v', 'copy', '-an']
                command += [os.path.abspath(output_file)]
            else:
                logging.info(f"Re-encoding {video.basename} to match target properties")
                width, height = target_props['resolution']
                command += ['-vf', f"scale={width}:{height},fps={target_props['frame_rate']}"]
                command += ['-c:v', DEFAULT_VIDEO_CODEC, '-preset', 'fast', '-b:v', '1M']
                if video.has_audio:
                    command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
                else:
                    command += ['-an']
                command += [os.path.abspath(output_file)]
            run_command(command, description=f"Normalizing video {video.basename}")
            logging.info(f"Normalization complete for {video.basename}")
            print_status(f"Normalization complete for {video.basename}")
            return output_file
        except Exception as e:
            logging.error(f"Error normalizing video {video.basename}: {e}")
            print_warning(f"Error normalizing video {video.basename}")
            return None

    def determine_common_properties(self, videos: List[VideoFile]) -> Dict[str, Any]:
        """Determine common properties among videos."""
        logging.info("Determining common properties for normalization")
        # Collect resolutions and frame rates
        resolutions = [(video.width, video.height) for video in videos]
        frame_rates = [video.frame_rate for video in videos]

        # Determine the most common resolution and frame rate
        target_resolution = max(set(resolutions), key=resolutions.count)
        target_frame_rate = max(set(frame_rates), key=frame_rates.count)

        logging.info(f"Target resolution: {target_resolution}, frame rate: {target_frame_rate}")
        return {'resolution': target_resolution, 'frame_rate': target_frame_rate}

    def change_speed(self, video: VideoFile, output_file: str, speed_factor: float, smooth_motion: bool = False):
        """Change the speed of a video with optional smooth motion interpolation."""
        logging.info(f"Changing speed of {video.filepath} by factor {speed_factor}")
        try:
            if speed_factor <= 0:
                print_warning("Speed factor must be greater than 0.")
                return
            ffms2_plugin = find_ffms2_plugin()
            
            if smooth_motion:
                temp_vpy = tempfile.NamedTemporaryFile(delete=False, suffix=".vpy")
                temp_vpy_name = temp_vpy.name
    
                svp_script_content = textwrap.dedent(f"""
                import vapoursynth as vs
                core = vs.core
                
                # Load necessary plugins
                core.std.LoadPlugin(r'{self.svp_plugins["lib1"]}')
                core.std.LoadPlugin(r'{self.svp_plugins["lib2"]}')
                core.std.LoadPlugin(r'{ffms2_plugin}')
                
                # Load the video source
                clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
                
                # Ensure the format is set to YUV420P8 (VapourSynth's standard format for many filters)
                clip = clip.resize.Bicubic(format=vs.YUV420P8)
                
                # Create the Super clip with the opt parameter (e.g., pel=2, sharpness=1)
                super_params = dict(opt=1)  # You can tweak opt depending on the performance
                super_clip = core.svp1.Super(clip, **super_params)
                
                # Analyse motion vectors with default params
                analyse_params = dict(block=32, overlap=16)
                vectors = core.svp1.Analyse(super_clip["clip"], super_clip["data"], clip, **analyse_params)
                
                # Perform motion interpolation
                smoothfps_params = dict(frate_num=int(clip.fps_num * {speed_factor}), frate_den=clip.fps_den, algo=23, block=True)
                smooth_clip = core.svp2.SmoothFps(clip, super_clip["clip"], super_clip["data"], vectors["clip"], vectors["data"], **smoothfps_params)
                
                # Adjust the FPS of the output
                smooth_clip = core.std.AssumeFPS(smooth_clip, fpsnum=int(clip.fps_num * {speed_factor}), fpsden=clip.fps_den)
                
                # Set the output
                smooth_clip.set_output()
                """)
    
                temp_vpy.write(svp_script_content.encode())
                temp_vpy.close()
    
                vspipe_command = f"vspipe {temp_vpy_name} - | ffmpeg -y -i pipe: -c:v libx264 -preset fast -b:v 1M"
                if video.has_audio:
                    vspipe_command += f" -i {os.path.abspath(video.filepath)} -c:a {DEFAULT_AUDIO_CODECS[0]} -b:a 256k -map 0:v -map 1:a"
                else:
                    vspipe_command += " -an"
                vspipe_command += f" {os.path.abspath(output_file)}"
                
                logging.info(f"Running vspipe command: {vspipe_command}")
                subprocess.run(vspipe_command, shell=True, check=True)
                logging.info(f"Speed change and interpolation applied to {video.basename}. Saved as {output_file}")
                print_status(f"Speed change applied to {video.basename}. Saved as {output_file}")
    
            else:
                atempo_filters = []
                if speed_factor < 0.5 or speed_factor > 2.0:
                    print_warning("Speed factor too extreme for atempo filter. Use advanced interpolation.")
                    return
                remaining_speed = speed_factor
                while remaining_speed > 2.0:
                    atempo_filters.append("atempo=2.0")
                    remaining_speed /= 2.0
                while remaining_speed < 0.5:
                    atempo_filters.append("atempo=0.5")
                    remaining_speed *= 2.0
                atempo_filters.append(f"atempo={remaining_speed}")
                atempo_filter = ",".join(atempo_filters)
    
                command = [
                    'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
                    '-filter_complex', f"[0:v]setpts={1/speed_factor}*PTS[v];[0:a]{atempo_filter}[a]"
                ]
                command += ['-map', '[v]', '-map', '[a]' if video.has_audio else '-an', '-c:v', DEFAULT_VIDEO_CODEC, '-preset', 'fast', '-b:v', '1M']
                if video.has_audio:
                    command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
                command += [os.path.abspath(output_file)]
                run_command(command, description=f"Changing speed of {video.basename}")
                print_status(f"Speed changed for {video.basename}. Saved as {output_file}")
    
        except Exception as e:
            logging.error(f"Error changing speed of {video.filepath}: {e}")
            print_warning(f"Failed to change speed for {video.basename}")
    
    def adjust_resolution(self, video: VideoFile, output_file: str, resolution: str):
        """Adjust the resolution of a video."""
        logging.info(f"Adjusting resolution of {video.filepath} to {resolution}")
        try:
            if not self.validate_resolution_format(resolution):
                print_warning("Invalid resolution format. Please use WIDTHxHEIGHT (e.g., 1920x1080).")
                return

            command = FFmpegCommandBuilder.build_adjust_resolution_command(video, resolution, output_file)
            run_command(command, description=f"Adjusting resolution for {video.basename}")

            print_status(f"Resolution adjusted for {video.basename}. Saved as {output_file}")

        except Exception as e:
            logging.error(f"Error adjusting resolution of {video.filepath}: {e}")
            print_warning(f"Failed to adjust resolution for {video.basename}")

    @staticmethod
    def validate_resolution_format(resolution: str) -> bool:
        """Validate the resolution format (e.g., 1920x1080)."""
        if 'x' not in resolution.lower():
            return False
        parts = resolution.lower().split('x')
        if len(parts) != 2:
            return False
        width, height = parts
        return width.isdigit() and height.isdigit()

    def convert_video_format(self, video: VideoFile, output_file: str, new_format: str):
        """Convert the video format to a different container."""
        logging.info(f"Converting format of {video.filepath} to {new_format}")
        try:
            command = FFmpegCommandBuilder.build_convert_format_command(video, new_format, output_file)
            run_command(command, description=f"Converting format for {video.basename}")
            print_status(f"Format conversion completed for {video.basename}. Saved as {output_file}")
        except ValueError as ve:
            print_warning(str(ve))
        except Exception as e:
            logging.error(f"Error converting format of {video.filepath}: {e}")
            print_warning(f"Failed to convert format for {video.basename}")

    def apply_filters(self, video: VideoFile, output_file: str, filters: str):
        """Apply specified video filters to the video."""
        logging.info(f"Applying filters to {video.filepath}: {filters}")
        try:
            command = FFmpegCommandBuilder.build_filter_command(video, filters, output_file)
            run_command(command, description=f"Applying filters to {video.basename}")
            print_status(f"Filters applied to {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error applying filters to {video.filepath}: {e}")
            print_warning(f"Failed to apply filters to {video.basename}")

    def extract_frames(self, video: VideoFile, output_dir: str):
        """Extract frames from the video and save them as images."""
        logging.info(f"Extracting frames from {video.filepath}")
        try:
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                logging.info(f"Created directory {output_dir} for frame extraction.")
            command = [
                'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
                '-vf', 'fps=1', os.path.join(output_dir, 'frame_%04d.png')
            ]
            run_command(command, description=f"Extracting frames from {video.basename}")
            print_status(f"Frames extracted from {video.basename}. Saved in {output_dir}")
        except Exception as e:
            logging.error(f"Error extracting frames from {video.filepath}: {e}")
            print_warning(f"Failed to extract frames from {video.basename}")

    def concatenate_videos(self, videos: List[VideoFile], output_file: str):
        """Concatenate multiple video files using ffmpeg."""
        logging.info("Starting concatenation process")
        normalized_files = self.normalize_videos(videos, os.path.dirname(output_file))
        if not normalized_files:
            print_warning("No videos were successfully normalized. Cannot proceed with concatenation.")
            return
        with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_file:
            temp_file_name = temp_file.name
            for file in normalized_files:
                temp_file.write(f"file '{os.path.abspath(file)}'\n")
            temp_file.flush()
        try:
            command = ['ffmpeg', '-y', '-f', 'concat', '-safe', '0', '-i', temp_file_name]
            if videos[0].has_audio:
                command += ['-c', 'copy']
            else:
                command += ['-c:v', 'copy', '-an']
            command += [os.path.abspath(output_file)]
            logging.info(f"Running ffmpeg concat command: {' '.join(command)}")
            run_command(command, description="Concatenating videos without re-encoding")
            logging.info(f"Concatenation successful. Output saved to {output_file}.")
            print_status(f"Concatenation successful. Output saved to {output_file}.")
        except subprocess.CalledProcessError as e:
            logging.warning(f"Concatenation failed: {e}. Attempting re-encoding.")
            try:
                command = ['ffmpeg', '-y', '-f', 'concat', '-safe', '0', '-i', temp_file_name]
                command += ['-c:v', DEFAULT_VIDEO_CODEC, '-preset', 'fast', '-b:v', '1M']
                if videos[0].has_audio:
                    command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']
                else:
                    command += ['-an']
                command += [os.path.abspath(output_file)]
                logging.info(f"Running ffmpeg re-encoding command: {' '.join(command)}")
                run_command(command, description="Concatenating videos with re-encoding")
                logging.info(f"Concatenation (re-encoding) successful. Output saved to {output_file}.")
                print_status(f"Concatenation (re-encoding) successful. Output saved to {output_file}.")
            except Exception as e:
                logging.error(f"Error during re-encoded concatenation: {e}")
                print_warning("Error during concatenation even after re-encoding.")
                if os.path.exists(output_file):
                    os.remove(output_file)
        finally:
            try:
                os.unlink(temp_file_name)
                logging.info(f"Temporary file {temp_file_name} deleted.")
            except FileNotFoundError:
                logging.warning(f"Temporary file {temp_file_name} was already removed.")

    def extract_audio(self, video: VideoFile, output_file: str, format_choice: str):
        """Extract the audio track from the video file."""
        logging.info(f"Extracting audio from {video.filepath} in format {format_choice}")
        try:
            if not video.has_audio:
                print_warning(f"No audio stream found in {video.basename}.")
                return
            format_codecs = {
                'mp3': 'libmp3lame',
                'opus': 'libopus',
                'aac': 'aac'
            }
            audio_codec = format_codecs.get(format_choice.lower())
            if not audio_codec:
                print_warning(f"Unsupported audio format: {format_choice}")
                return
            command = [
                'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
                '-vn', '-c:a', audio_codec, '-b:a', '256k',
                os.path.abspath(output_file)
            ]
            run_command(command, description=f"Extracting audio from {video.basename}")
            print_status(f"Audio extracted from {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error extracting audio from {video.filepath}: {e}")
            print_warning(f"Failed to extract audio from {video.basename}")

    def merge_audio_with_video(self, video: VideoFile, audio_file: str, output_file: str):
        """Merge an external audio file with a video."""
        logging.info(f"Merging {audio_file} with {video.filepath}")
        try:
            if not os.path.exists(audio_file):
                print_warning(f"Audio file does not exist: {audio_file}")
                return
            command = [
                'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
                '-i', os.path.abspath(audio_file),
                '-c:v', 'copy', '-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k',
                '-map', '0:v:0', '-map', '1:a:0',
                os.path.abspath(output_file)
            ]
            run_command(command, description=f"Merging audio with {video.basename}")
            print_status(f"Audio merged with {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error merging audio with {video.filepath}: {e}")
            print_warning(f"Failed to merge audio with {video.basename}")

    def handle_metadata(self, video: VideoFile, output_file: str, keep_metadata: bool = True):
        """Handle metadata retention or removal in the video file."""
        logging.info(f"Handling metadata for {video.filepath}. Keep metadata: {keep_metadata}")
        try:
            command = ['ffmpeg', '-y', '-i', os.path.abspath(video.filepath)]
            if keep_metadata:
                command += ['-map_metadata', '0']
            else:
                command += ['-map_metadata', '-1']
            command += ['-c:v', 'copy', '-c:a', 'copy', os.path.abspath(output_file)]
            run_command(command, description=f"Handling metadata for {video.basename}")
            print_status(f"Metadata handling complete for {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error handling metadata for {video.filepath}: {e}")
            print_warning(f"Failed to handle metadata for {video.basename}")

    def generate_video_report(self, video: VideoFile, output_file: str):
        """Generate a detailed report for the video file."""
        logging.info(f"Generating video report for {video.filepath}")
        try:
            command = [
                'ffprobe', '-v', 'error', '-show_format',
                '-show_streams', '-of', 'json', os.path.abspath(video.filepath)
            ]
            report = run_command(command, description=f"Generating video report for {video.basename}")
            with open(os.path.abspath(output_file), 'w') as f:
                f.write(report)
            print_status(f"Video report generated for {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error generating report for {video.filepath}: {e}")
            print_warning(f"Failed to generate report for {video.basename}")

    def apply_vapoursynth_script(self, video: VideoFile, output_file: str, script_content: str):
        """Apply a VapourSynth script to the video."""
        logging.info(f"Applying VapourSynth script to {video.filepath}")
        try:
            temp_vpy = tempfile.NamedTemporaryFile(delete=False, suffix=".vpy")
            temp_vpy_name = temp_vpy.name
            temp_vpy.write(script_content.encode())
            temp_vpy.close()
            vspipe_command = f"vspipe {temp_vpy_name} - | ffmpeg -y -i pipe: -c:v libx264 -preset fast -b:v 1M"
            if video.has_audio:
                vspipe_command += f" -i {os.path.abspath(video.filepath)} -c:a {DEFAULT_AUDIO_CODECS[0]} -b:a 256k -map 0:v -map 1:a"
            else:
                vspipe_command += " -an"
            vspipe_command += f" {os.path.abspath(output_file)}"
            subprocess.run(vspipe_command, shell=True, check=True)
            logging.info(f"VapourSynth script applied to {video.basename}. Saved as {output_file}")
            print_status(f"VapourSynth script applied to {video.basename}. Saved as {output_file}")
        except Exception as e:
            logging.error(f"Error applying VapourSynth script to {video.filepath}: {e}")
            print_warning(f"Failed to apply VapourSynth script to {video.basename}")
        finally:
            if os.path.exists(temp_vpy_name):
                os.remove(temp_vpy_name)
                logging.info(f"Temporary VapourSynth script {temp_vpy_name} deleted.")

class UserInterface:
    """Handles user interactions."""

    def __init__(self):
        self.processor = VideoProcessor()

    def main_menu(self):
        """Display the main menu and handle user selection."""
        while True:
            print(f"{GREEN}#{NC} ========= {GREEN}// DMX //{NC}")
            print(f"{GREEN}1.{NC}) Analyze         {GREEN}9.{NC}) Screencaps")
            print(f"{GREEN}2.{NC}) Autofix         {GREEN}10.{NC}) Concatenate")
            print(f"{GREEN}3.{NC}) Normalize       {GREEN}11.{NC}) Extract Audio")
            print(f"{GREEN}4.{NC}) Change Speed    {GREEN}12.{NC}) Merge Audio")
            print(f"{GREEN}5.{NC}) Resolution      {GREEN}13.{NC}) Metadata")
            print(f"{GREEN}6.{NC}) Convert         {GREEN}14.{NC}) Report")
            print(f"{GREEN}7.{NC}) Filters         {GREEN}15.{NC}) VapourSynth")
            print(f"{GREEN}8.{NC}) Help            {GREEN}Q{NC}) Quit")
            print("")
            choice = input(f"{GREEN}By your command: {NC}").strip().lower()

            try:
                # Option 1: Analyze Video with MediaInfo
                if choice == '1':
                    video = self.select_single_video()
                    if video:
                        self.processor.analyze_video(video)

                # Option 2: Detect and Autofix Issues
                elif choice == '2':
                    video = self.select_single_video()
                    if video:
                        video.detect_issues(fix_issues=True)

                # Option 3: Normalize Videos
                elif choice == '3':
                    videos = self.select_multiple_videos()
                    if videos:
                        output_dir = input("Enter custom directory for normalized videos or press Enter for current directory: ").strip()
                        if not output_dir:
                            output_dir = "."
                        self.processor.normalize_videos(videos, output_dir)

                # Option 4: Change Video Speed (Fast/Slow)
                elif choice == '4':
                    video = self.select_single_video()
                    if video:
                        speed_factor_input = input("Enter Speed factor (e.g., 0.5 for slow motion, 2 for fast motion): ")
                        try:
                            speed_factor = float(speed_factor_input)
                            if speed_factor <= 0:
                                print_warning("Speed factor must be greater than 0.")
                                continue
                        except ValueError:
                            print_warning("Invalid speed factor.")
                            continue
                        smooth_motion_input = input("Enable advanced motion interpolation? (y/n): ").lower()
                        smooth_motion = smooth_motion_input == 'y'
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_speed_change.mp4"
                        self.processor.change_speed(video, output_file, speed_factor, smooth_motion)

                # Option 5: Adjust Video Resolution
                elif choice == '5':
                    video = self.select_single_video()
                    if video:
                        resolution = input("Enter new resolution (e.g., 1920x1080): ").strip()
                        if not self.processor.validate_resolution_format(resolution):
                            print_warning("Invalid resolution format. Please use WIDTHxHEIGHT (e.g., 1920x1080).")
                            continue
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_resolution.mp4"
                        self.processor.adjust_resolution(video, output_file, resolution)

                # Option 6: Convert Video Format
                elif choice == '6':
                    video = self.select_single_video()
                    if video:
                        new_format = input("Enter new format (e.g., mp4, mkv, avi, mov): ").strip()
                        if not new_format:
                            print_warning("No format entered.")
                            continue
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}.{new_format}"
                        self.processor.convert_video_format(video, output_file, new_format)

                # Option 7: Apply Video Filters
                elif choice == '7':
                    video = self.select_single_video()
                    if video:
                        filters = input("Enter the video filters to apply, separated by commas (e.g., grayscale,negate): ").strip()
                        if not filters:
                            print_warning("No filters entered.")
                            continue
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_filtered.mp4"
                        self.processor.apply_filters(video, output_file, filters)

                # Option 8: Help
                elif choice == '8':
                    self.print_help()

                # Option 9: Extract Frames as Images
                elif choice == '9':
                    video = self.select_single_video()
                    if video:
                        output_dir = input("Enter custom directory for screencaps or press Enter for './screencaps/': ").strip()
                        if not output_dir:
                            output_dir = os.path.expanduser('./screencaps/')
                        self.processor.extract_frames(video, output_dir)

                # Option 10: Concatenate Videos
                elif choice == '10':
                    videos = self.select_multiple_videos()
                    if videos:
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"concatenated_{self.generate_timestamp()}.mp4"
                        self.processor.concatenate_videos(videos, output_file)

                # Option 11: Extract Audio from Video
                elif choice == '11':
                    video = self.select_single_video()
                    if video:
                        format_choice = input("Select audio format (opus/mp3/aac): ").strip().lower()
                        if format_choice not in ['opus', 'mp3', 'aac']:
                            print_warning("Unsupported audio format selected.")
                            continue
                        output_file = input("Enter the base name for the output audio file (without extension): ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_audio.{format_choice}"
                        else:
                            output_file += f".{format_choice}"
                        self.processor.extract_audio(video, output_file, format_choice)

                # Option 12: Merge Audio with Video
                elif choice == '12':
                    video = self.select_single_video()
                    if video:
                        audio_file = input("Enter the path to the audio file to merge: ").strip()
                        if not audio_file:
                            print_warning("No audio file path entered.")
                            continue
                        if not os.path.isfile(audio_file):
                            print_warning("The specified audio file does not exist.")
                            continue
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"merged_{self.generate_timestamp()}.mp4"
                        self.processor.merge_audio_with_video(video, audio_file, output_file)

                # Option 13: Handle Metadata
                elif choice == '13':
                    video = self.select_single_video()
                    if video:
                        output_file = input("Enter output file name: ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_metadata.mp4"
                        keep_metadata_input = input("Keep the metadata? (y/n): ").strip().lower()
                        keep_metadata = keep_metadata_input == 'y'
                        self.processor.handle_metadata(video, output_file, keep_metadata)

                # Option 14: Generate Video Report
                elif choice == '14':
                    video = self.select_single_video()
                    if video:
                        output_file = input("Enter output file name (e.g., video_report.json): ").strip()
                        if not output_file:
                            output_file = f"{os.path.splitext(video.basename)[0]}_report.json"
                        self.processor.generate_video_report(video, output_file)

                # Option 15: Apply VapourSynth Transformation
                elif choice == '15':
                    video = self.select_single_video()
                    if video:
                        self.vapoursynth_menu(video)

                # Quit the program
                elif choice == 'q':
                    print("Exiting DMX!")
                    break

                # Invalid option
                else:
                    print_warning(f"Unrecognized option: {choice}")

            except Exception as e:
                logging.error(f"Error in main menu: {e}")
                print_warning(f"An error occurred: {e}")

    def generate_timestamp(self):
            """Generate a simple timestamp string for use in filenames."""
            return datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def select_single_video(self) -> VideoFile:
            """Select a single video file."""
            files = self.use_fzf_to_select_files()
            if files:
                return VideoFile(files[0])
            print_warning("No file selected.")
            return None
    
    def select_multiple_videos(self) -> List[VideoFile]:
            """Select multiple video files."""
            files = self.use_fzf_to_select_files(multiple=True)
            if files:
                return [VideoFile(f) for f in files]
            print_warning("No files selected.")
            return []
    
    @staticmethod
    def use_fzf_to_select_files(multiple=False) -> List[str]:
            """Use fzf to select files."""
            fzf_command = ['fzf']
            if multiple:
                fzf_command.append('--multi')
            try:
                result = subprocess.run(fzf_command, capture_output=True, text=True, check=True)
                selected_files = [line for line in result.stdout.strip().split('\n') if line]
                return selected_files
            except subprocess.CalledProcessError:
                print_warning("No files selected or error with fzf.")
                return []
    
    @staticmethod
    def print_help():
        """Display help information."""
        help_message = f"""
    {GREEN}Available Commands:{NC}
    1. Analyze the Video with MediaInfo
    2. Detect and Auto-fix Video Issues
    3. Normalize Videos for Concatenation
    4. Change Video Speed (Fast/Slow) w/ Interpolation
    5. Adjust Video Resolution
    6. Convert Video into another format
    7. Apply Video Filters
    8. Help
    9. Extract Frames as Screencaps
    10. Concatenate Videos Into Single Video
    11. Extract Audio from Video
    12. Merge New Audio with Video
    13. Edit or Remove Metadata
    14. Generate Video Report
    15. Apply Advanced Transformations (VapourSynth)
    Q. Quit

    Instructions:
    - Use the number keys to select an option.
    - Use 'Q' to quit the program.
    """
        print(help_message)

    def vapoursynth_menu(self, video: VideoFile):
        """Display the VapourSynth transformations menu."""
        options = [
            "Frame Rate Conversion",
            "Inverse Telecine (IVTC)",
            "Deflicker",
            "Dedot",
            "Dehalo",
            "Grain Generation",
            "RemoveGrain",
            "Debanding",
            "Sharpening & Edge Enhancement",
            "Color Correction",
            "Super Resolution",
            "Deshake",
            "Edge Detection",
            "Zooming",
            "Stabilization",
            "Slo-mo",
            "Exit"
        ]
        for idx, opt in enumerate(options, 1):
            print(f"{idx}. {opt}")

        while True:
            choice = input("Select a transformation (or type 'Exit' to return to main menu): ").strip()
            if choice.lower() == 'exit':
                break
            try:
                choice_idx = int(choice) - 1
                if 0 <= choice_idx < len(options):
                    transformation = options[choice_idx]
                    if transformation == "Exit":
                        break
                    self.apply_vapoursynth_transformation(video, transformation)
                else:
                    print_warning("Invalid option selected.")
            except ValueError:
                print_warning("Invalid input. Please enter a number corresponding to the options or 'Exit'.")

    def apply_vapoursynth_transformation(self, video: VideoFile, transformation: str):
        """Apply the selected VapourSynth transformation."""
        output_file = input("Enter output file name: ").strip()
        if not output_file:
            safe_transformation = transformation.lower().replace(' ', '_')
            output_file = f"{os.path.splitext(video.basename)[0]}_{safe_transformation}.mp4"

        ffms2_plugin = find_ffms2_plugin()

        script_content = ""

        if transformation == "Frame Rate Conversion":
            target_fps = input("Enter target FPS (e.g., 60): ").strip()
            if not target_fps.isdigit():
                print_warning("Invalid FPS value.")
                return
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.std.AssumeFPS(clip, fpsnum={target_fps}, fpsden=1)
            clip.set_output()
            """)

        elif transformation == "Inverse Telecine (IVTC)":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.vivtc.VDecimate(clip)
            clip.set_output()
            """)

        elif transformation == "Deflicker":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.deflicker.Deflicker(clip)
            clip.set_output()
            """)

        elif transformation == "Dedot":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.dedot.Dedot(clip)
            clip.set_output()
            """)

        elif transformation == "Dehalo":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.dehalo.Alpha(clip)
            clip.set_output()
            """)

        elif transformation == "Grain Generation":
            grain_amount = input("Enter grain amount (e.g., 0.3): ").strip()
            try:
                grain_amount = float(grain_amount)
            except ValueError:
                print_warning("Invalid grain amount. Using default 0.3.")
                grain_amount = 0.3
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.grain.Add(clip, var={grain_amount})
            clip.set_output()
            """)

        elif transformation == "RemoveGrain":
            mode = input("Enter removal mode (1-17, default 17): ").strip()
            mode = mode if mode.isdigit() and 1 <= int(mode) <= 17 else '17'
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.rgvs.RemoveGrain(clip, mode={mode})
            clip.set_output()
            """)

        elif transformation == "Debanding":
            y = input("Enter Y deband strength (default 64): ").strip() or "64"
            cb = input("Enter Cb deband strength (default 64): ").strip() or "64"
            cr = input("Enter Cr deband strength (default 64): ").strip() or "64"
            grainy = input("Enter grainy (default 64): ").strip() or "64"
            grainc = input("Enter grainc (default 64): ").strip() or "64"
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.f3kdb.Deband(clip, y={y}, cb={cb}, cr={cr}, grainy={grainy}, grainc={grainc})
            clip.set_output()
            """)

        elif transformation == "Sharpening & Edge Enhancement":
            depth = input("Enter sharpening depth (default 2): ").strip() or "2"
            try:
                depth = int(depth)
            except ValueError:
                print_warning("Invalid sharpening depth. Using default value of 2.")
                depth = 2
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.warp.AWarpSharp2(clip, depth={depth})
            clip.set_output()
            """)

        elif transformation == "Color Correction":
            brightness = input("Enter brightness adjustment (default 0.0): ").strip() or "0.0"
            contrast = input("Enter contrast adjustment (default 1.0): ").strip() or "1.0"
            saturation = input("Enter saturation adjustment (default 1.0): ").strip() or "1.0"
            try:
                brightness = float(brightness)
                contrast = float(contrast)
                saturation = float(saturation)
            except ValueError:
                print_warning("Invalid input values. Using default settings.")
                brightness, contrast, saturation = 0.0, 1.0, 1.0
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            # Apply brightness, contrast, and saturation adjustments
            clip = core.std.Expr(clip, expr=["x {brightness} +", "x {contrast} *", "x {saturation} *"])
            clip.set_output()
            """)

        elif transformation == "Super Resolution":
            upscale_factor = input("Enter upscale factor (e.g., 2): ").strip()
            try:
                upscale_factor = int(upscale_factor)
                if upscale_factor <= 0:
                    raise ValueError
            except ValueError:
                print_warning("Invalid upscale factor. Using default factor of 2.")
                upscale_factor = 2
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            # Upscale using Spline36 for high-quality resizing
            clip = core.resize.Spline36(clip, width=clip.width * {upscale_factor}, height=clip.height * {upscale_factor})
            clip.set_output()
            """)

        elif transformation == "Deshake":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            from vapoursynth import core
            core.std.LoadPlugin(r"{self.processor.svp_plugins['lib1']}")
            core.std.LoadPlugin(r"{self.processor.svp_plugins['lib2']}")
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.deshake.Deshake(clip)
            clip.set_output()
            """)

        elif transformation == "Edge Detection":
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            edges = core.std.Prewitt(clip)
            clip = core.std.Expr([clip, edges], expr="x y -")
            clip.set_output()
            """)

        elif transformation == "Zooming":
            x = input("Enter x coordinate for cropping (default 0): ").strip() or "0"
            y = input("Enter y coordinate for cropping (default 0): ").strip() or "0"
            width = input("Enter width for cropping (e.g., 640): ").strip()
            height = input("Enter height for cropping (e.g., 480): ").strip()
            try:
                x = int(x)
                y = int(y)
                width = int(width)
                height = int(height)
            except ValueError:
                print_warning("Invalid cropping parameters.")
                return
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.std.CropRel(clip, left={x}, top={y}, right=clip.width - ({x} + {width}), bottom=clip.height - ({y} + {height}))
            clip = core.resize.Bicubic(clip, width={width}, height={height})
            clip.set_output()
            """)

        elif transformation == "Stabilization":
            # FFmpeg stabilization using deshake
            command = [
                'ffmpeg', '-y', '-i', os.path.abspath(video.filepath),
                '-vf', 'deshake',  # Apply the deshake filter
                '-c:v', DEFAULT_VIDEO_CODEC,  # Default video codec
                '-preset', 'fast',  # Use fast encoding
                '-b:v', '1M',  # Set video bitrate
            ]
            if video.has_audio:
                command += ['-c:a', DEFAULT_AUDIO_CODECS[0], '-b:a', '256k']  # Audio settings
            else:
                command += ['-an']  # Disable audio if not present
            command += [os.path.abspath(output_file)]
        
            # Run the FFmpeg command to apply stabilization
            try:
                run_command(command, description=f"Stabilizing {video.basename}")
                print_status(f"Stabilization applied to {video.basename}. Saved as {output_file}")
            except Exception as e:
                logging.error(f"Error stabilizing video {video.filepath}: {e}")
                print_warning(f"Failed to apply stabilization to {video.basename}")

        elif transformation == "Slo-mo":
            speed_factor = input("Enter slow-motion factor (e.g., 0.5 for half speed): ").strip()
            try:
                speed_factor = float(speed_factor)
                if speed_factor <= 0:
                    raise ValueError
            except ValueError:
                print_warning("Invalid slow-motion factor. Using default factor of 0.5.")
                speed_factor = 0.5
            script_content = textwrap.dedent(f"""
            import vapoursynth as vs
            core = vs.core
            core.std.LoadPlugin(r'{ffms2_plugin}')
            clip = core.ffms2.Source(r"{os.path.abspath(video.filepath)}")
            clip = core.std.AssumeFPS(clip, fpsnum=int(clip.fps_num * {speed_factor}), fpsden=clip.fps_den)
            clip.set_output()
            """)

        else:
            print_warning("Transformation not implemented yet.")
            return

        self.processor.apply_vapoursynth_script(video, output_file, script_content)

# Entry point
if __name__ == "__main__":
    check_dependencies()
    ui = UserInterface()
    ui.main_menu()
