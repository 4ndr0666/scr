#!/usr/bin/env bash
# Author: 4ndr0666
set -euo pipefail
IFS=$'\n\t'
# ======================= // FFXD-BETA //
## Description: A wrapper script for ffmpeg/ffprobe
#               with common video processing tasks.
# -----------------------------------------------------

declare -r XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
declare -r XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
declare -r XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/tmp}" # Note: /tmp is a common fallback, but XDG_RUNTIME_DIR is preferred and often points elsewhere like /run/user/$UID
declare -r FFxd_RUNTIME_DIR="$XDG_RUNTIME_DIR/ffxd"

mkdir -p "$FFxd_RUNTIME_DIR" || {
	echo "ERROR: Could not create runtime directory $FFxd_RUNTIME_DIR" >&2
	exit 1
}

declare TEMP_DIR # Declare first, assign on next line to check mktemp exit status

if ! TEMP_DIR="$(mktemp -d "$FFxd_RUNTIME_DIR/ffxd.XXXXXX")"; then
	echo "ERROR: Could not create temporary directory" >&2
	exit 1
fi

declare -r TEMP_DIR # Make it read-only after successful creation

trap 'rm -rf -- "$TEMP_DIR"' EXIT

command -v ffmpeg >/dev/null 2>&1 || {
	echo "ERROR: ffmpeg not found. Please install it." >&2
	exit 1
}
command -v ffprobe >/dev/null 2>&1 || {
	echo "ERROR: ffprobe not found. Please install it." >&2
	exit 1
}
command -v awk >/dev/null 2>&1 || {
	echo "ERROR: awk not found. Please install it." >&2
	exit 1
}
command -v bc >/dev/null 2>&1 || {
	echo "ERROR: bc not found. Please install it." >&2
	exit 1
}

declare ADVANCED=false     # Interactive advanced prompt (config saving)
declare VERBOSE=false      # Verbose output
declare BULK=false         # Process multiple inputs sequentially (for 'process')
declare NOAUDIO=false      # Remove audio streams from output
declare MAX1080=false      # Enforce 1080p maximum height for video
declare OUTPUT_DIR         # Declare first, assign below
OUTPUT_DIR="$(pwd)"        # Default to current directory
declare FPS=""             # Target frame rate (string to allow empty)
declare PTS=""             # Playback speed factor (string to allow empty)
declare INTERPOLATE=false  # Enable motion interpolation
declare -a COMMAND_ARGS=() # Array to hold command name and its arguments

log_verbose() {
	if "$VERBOSE"; then
		echo "VERBOSE: $*" >&2
	fi
}

log_error() {
	echo "ERROR: $*" >&2
}

ensure_unique_file() {
	local target="$1"
	local base ext count=1
	# Extract base name and extension safely
	base="${target%.*}"
	ext="${target##*.}"
	# Handle cases where there's no extension (e.g., just "output")
	if [[ "$base" == "$target" ]]; then
		ext=""
	else
		ext=".${ext}" # Prepend dot for easier concatenation
	fi

	while [[ -e "$target" ]]; do
		target="${base}_${count}${ext}"
		count=$((count + 1))
	done
	printf '%s' "$target"
}

advanced_prompt() {
	local cfg_dir="$XDG_CONFIG_HOME/ffxd"
	mkdir -p "$cfg_dir" || {
		log_error "Could not create config directory: $cfg_dir"
		return 1
	}
	local cfg_file="$cfg_dir/ffxd.conf"

	echo "--- Advanced Settings Prompt ---"
	echo "These settings will be saved to $cfg_file."
	echo "Note: Applying these settings to commands requires manual integration or sourcing this file."

	local ADV_CODEC ADV_CONTAINER ADV_CRF ADV_RES ADV_FPS ADV_MULTIPASS

	read -rp "Codec [libx264]: " ADV_CODEC
	ADV_CODEC=${ADV_CODEC:-libx264}

	read -rp "Container [mp4]: " ADV_CONTAINER
	ADV_CONTAINER=${ADV_CONTAINER:-mp4}

	read -rp "CRF [23]: " ADV_CRF
	ADV_CRF=${ADV_CRF:-23}
	# Basic validation for CRF
	if ! [[ "$ADV_CRF" =~ ^[0-9]+$ ]]; then
		log_error "Invalid CRF value: '$ADV_CRF'. Must be an integer. Using default 23."
		ADV_CRF=23
	fi

	read -rp "Resolution [1920x1080]: " ADV_RES
	ADV_RES=${ADV_RES:-1920x1080}
	# Basic validation for Resolution (simple format check)
	if ! [[ "$ADV_RES" =~ ^[0-9]+x[0-9]+$ ]]; then
		log_error "Invalid Resolution value: '$ADV_RES'. Must be in format WxH (e.g., 1920x1080). Using default 1920x1080."
		ADV_RES=1920x1080
	fi

	read -rp "FPS [60]: " ADV_FPS
	ADV_FPS=${ADV_FPS:-60}
	# Basic validation for FPS
	if ! [[ "$ADV_FPS" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
		log_error "Invalid FPS value: '$ADV_FPS'. Must be a number. Using default 60."
		ADV_FPS=60
	fi

	read -rp "Multipass? (y/N): " ans
	ADV_MULTIPASS=false
	[[ "$ans" =~ ^[Yy]$ ]] && ADV_MULTIPASS=true

	cat >"$cfg_file" <<EOF
ffxd Advanced Configuration

Automatically generated by ffxd advanced_prompt


ADV_CODEC="$ADV_CODEC"
ADV_CONTAINER="$ADV_CONTAINER"
ADV_CRF="$ADV_CRF"
ADV_RES="$ADV_RES"
ADV_FPS="$ADV_FPS"
ADV_MULTIPASS="$ADV_MULTIPASS"
EOF
	log_verbose "Advanced options saved to $cfg_file"
}

build_ffmpeg_stream_opts() {
	local -a opts=()

	if "$NOAUDIO"; then
		opts+=("-an") # Disable audio
	fi

	if "$VERBOSE"; then
		opts+=("-v" "info") # Set ffmpeg logging level
	fi

	# Add other stream-level options here if needed later (e.g., -c:v, -c:a, -preset)
	# For now, codec/preset is handled per command or via advanced config (if integrated).

	# Print options separated by null bytes for safe reading into an array
	printf '%s\0' "${opts[@]}"
}

build_ffmpeg_filters() {
	local stream_type="$1" # 'v' or 'a'
	local -a filters=()

	if [[ "$stream_type" == "v" ]]; then
		if "$MAX1080"; then
			# Scale video to max 1920x1080 while maintaining aspect ratio.
			# Use 'scale' filter. 'min(iw,1920)' and 'min(ih,1080)' ensures we don't upscale.
			# 'force_original_aspect_ratio=decrease' handles cases where one dimension is already over limit.
			filters+=("scale='min(iw,1920):min(ih,1080):force_original_aspect_ratio=decrease'")
		fi

		if [[ -n "$PTS" ]]; then
			# Adjust video playback speed using setpts.
			filters+=("setpts=$PTS*PTS")
		fi

		if "$INTERPOLATE"; then
			# Enable motion interpolation. Requires a target FPS.
			if [[ -z "$FPS" ]]; then
				# This error should ideally be caught earlier during option parsing,
				# but adding here as a safeguard.
				log_error "Motion interpolation requires a target frame rate. Please specify with -f/--fps."
				return 1 # Indicate failure
			fi
			# minterpolate filter example: mi_mode=mci:mc_mode=aobmc:vsbmc=1:fps=60
			# Note: minterpolate is CPU intensive and requires specific ffmpeg builds.
			filters+=("minterpolate='mi_mode=mci:mc_mode=aobmc:vsbmc=1:fps=$FPS'")
		fi
		# Add other video filters here
	elif [[ "$stream_type" == "a" ]]; then
		if [[ -n "$PTS" && ! "$NOAUDIO" ]]; then
			# Adjust audio playback speed using atempo.
			# atempo filter only supports factors between 0.5 and 2.0.
			# For factors outside this range, multiple atempo filters are needed.
			local inv_pts # Inverse of PTS factor for atempo
			local awk_result

			# Calculate inverse PTS using awk. Check for errors (e.g., PTS=0).
			if ! awk_result=$(awk "BEGIN { if ($PTS == 0) exit 1; printf \"%%s\", 1/$PTS }" 2>/dev/null); then
				log_error "Invalid PTS value for audio speed adjustment: $PTS (cannot be zero)"
				return 1 # Indicate failure
			fi
			inv_pts="$awk_result"

			# Check if awk result is a valid number before comparison
			if ! [[ "$inv_pts" =~ ^[0-9]*(\.[0-9]+)?$ ]]; then
				log_error "Invalid PTS calculation result: $inv_pts"
				return 1 # Indicate failure
			fi

			local remain="$inv_pts"
			# Use bc for floating-point comparisons
			# Chain atempo filters for factors > 2.0
			if (($(echo "$remain > 2.0" | bc -l))); then
				while (($(echo "$remain > 2.0" | bc -l))); do
					filters+=("atempo=2.0")
					# Recalculate remaining factor
					if ! remain=$(awk "BEGIN { printf \"%%s\", $remain/2.0 }" 2>/dev/null); then
						log_error "awk error during atempo calculation"
						return 1
					fi
				done
			fi
			# Chain atempo filters for factors < 0.5
			if (($(echo "$remain < 0.5" | bc -l))); then
				while (($(echo "$remain < 0.5" | bc -l))); do
					filters+=("atempo=0.5")
					# Recalculate remaining factor
					if ! remain=$(awk "BEGIN { printf \"%%s\", $remain/0.5 }" 2>/dev/null); then
						log_error "awk error during atempo calculation"
						return 1
					fi
				done
			fi
			# Add the remaining factor if it's not exactly 1.0 (or very close)
			# Use a small tolerance for float comparison
			if (($(echo "$remain > 1.000001 || $remain < 0.999999" | bc -l))); then
				filters+=("atempo=$remain")
			fi
		fi
		# Add other audio filters here
	fi

	# Return the filter string joined by commas.
	# If no filters, print nothing (empty string).
	if [[ ${#filters[@]} -gt 0 ]]; then
		local old_ifs="$IFS"
		IFS=,
		printf "%s" "${filters[*]}"
		IFS="$old_ifs"
	fi
}

parse_global_options() {
	log_verbose "Parsing global options: $*"
	local -a remaining_args=()
	local arg

	while [[ $# -gt 0 ]]; do
		arg="$1"
		case "$arg" in
		-a | --advanced)
			ADVANCED=true
			log_verbose "Flag set: ADVANCED"
			;;
		-v | --verbose)
			VERBOSE=true
			# log_verbose will now work
			log_verbose "Flag set: VERBOSE"
			;;
		-b | --bulk)
			BULK=true
			log_verbose "Flag set: BULK"
			;;
		-n | --noaudio)
			NOAUDIO=true
			log_verbose "Flag set: NOAUDIO"
			;;
		-m | --max1080)
			MAX1080=true
			log_verbose "Flag set: MAX1080"
			;;
		-o | --output-dir)
			if [[ $# -lt 2 || "$2" =~ ^- ]]; then
				log_error "Option '$arg' requires a directory argument."
				show_help
				exit 1
			fi
			OUTPUT_DIR="$2"
			log_verbose "Option set: OUTPUT_DIR=$OUTPUT_DIR"
			shift # Consume the argument
			;;
		-f | --fps)
			if [[ $# -lt 2 || "$2" =~ ^- ]]; then
				log_error "Option '$arg' requires a frame rate value."
				show_help
				exit 1
			fi
			# Basic validation: check if it looks like a number (integer or float)
			if ! [[ "$2" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
				log_error "Invalid value for '$arg': '$2'. Must be a number."
				show_help
				exit 1
			fi
			FPS="$2"
			log_verbose "Option set: FPS=$FPS"
			shift # Consume the argument
			;;
		-p | --pts)
			if [[ $# -lt 2 || "$2" =~ ^- ]]; then
				log_error "Option '$arg' requires a playback speed factor."
				show_help
				exit 1
			fi
			# Basic validation: check if it looks like a number (integer or float) and is positive
			if ! [[ "$2" =~ ^[0-9]+(\.[0-9]+)?$ ]] || (($(echo "$2 <= 0" | bc -l))); then
				log_error "Invalid value for '$arg': '$2'. Must be a positive number."
				show_help
				exit 1
			fi
			PTS="$2"
			log_verbose "Option set: PTS=$PTS"
			shift # Consume the argument
			;;
		-i | --interpolate)
			INTERPOLATE=true
			log_verbose "Flag set: INTERPOLATE"
			;;
		--)
			# End of options marker
			shift                  # Consume '--'
			remaining_args+=("$@") # Add all remaining arguments
			break                  # Stop parsing options
			;;
		-*)
			# Unknown option
			log_error "Unknown global option: $arg"
			show_help
			exit 1
			;;
		*)
			# First non-option argument is the command
			remaining_args+=("$@")
			break # Stop parsing options
			;;
		esac
		shift # Consume the current option
	done

	# Store the remaining arguments (command and its args)
	COMMAND_ARGS=("${remaining_args[@]}")
	log_verbose "Remaining arguments (command and args): ${COMMAND_ARGS[*]}"
}

show_help() {
	cat <<EOH
Usage: ffxd [global options] <command> [args]

Commands:
  process <input(s)>   Process video file(s) with global options.
  merge <input(s)>     Merge multiple video files into one (stream copy, limited global options).
  composite <input(s)> Composite multiple video files into a grid.
  looperang <input>    Create a boomerang effect video.
  slowmo <input>       Create a slow-motion video (requires -p/--pts).
  fix <input>          Fix common video issues (e.g., VFR to CFR).
  clean [options]      Clean up ffxd temporary/cache/config files.
  probe <input>        Show media information using ffprobe.
  help                 Show this help message.

Global options:
  -a, --advanced        Interactive advanced prompt (saves config, not auto-applied).
  -v, --verbose         Verbose output.
  -b, --bulk            Process multiple inputs sequentially (for 'process').
  -n, --noaudio         Remove audio streams from output.
  -m, --max1080         Enforce 1080p maximum height for video.
  -o, --output-dir DIR  Output directory (defaults to current directory).
  -f, --fps FPS         Force constant frame rate (e.g., 30, 60). Required for interpolation.
  -p, --pts FACTOR      Adjust playback speed (e.g., 0.5 for half speed, 2.0 for double speed).
  -i, --interpolate     Enable motion interpolation (requires -f/--fps).

Note: Not all global options are applicable to all commands.
      'merge' only supports -v and -n when using stream copy.
EOH
}

cmd_process() {
	log_verbose "Executing command: process with args: $*"
	local -a inputs=("$@")
	local input_file output_file base_name ext
	local -a stream_opts=()
	local video_filters_str=""
	local audio_filters_str=""
	local stream_opts_output

	if [[ ${#inputs[@]} -eq 0 ]]; then
		log_error "Command 'process' requires at least one input file."
		echo "Usage: ffxd process [global options] <input(s)>" >&2
		exit 1
	fi

	# Ensure output directory exists
	mkdir -p "$OUTPUT_DIR" || {
		log_error "Could not create output directory: $OUTPUT_DIR"
		exit 1
	}

	# Build common ffmpeg stream options from global flags
	# Capture null-separated output into array
	if ! stream_opts_output="$(build_ffmpeg_stream_opts)"; then
		log_error "Failed to build stream options."
		exit 1
	fi
	IFS=$'\0' read -r -d '' -a stream_opts <<<"$stream_opts_output"

	# Build filter strings from global flags
	if ! video_filters_str="$(build_ffmpeg_filters v)"; then
		log_error "Failed to build video filters."
		exit 1 # build_ffmpeg_filters returns 1 if interpolation needs FPS
	fi
	if ! audio_filters_str="$(build_ffmpeg_filters a)"; then
		log_error "Failed to build audio filters."
		exit 1 # build_ffmpeg_filters returns 1 on awk errors
	fi

	local -a process_files=()
	if "$BULK"; then
		process_files=("${inputs[@]}")
		log_verbose "Bulk mode enabled. Processing ${#process_files[@]} files sequentially."
	else
		# Non-bulk mode: Process only the first input file provided.
		if [[ ${#inputs[@]} -gt 1 ]]; then
			log_error "Non-bulk mode expects only one input file. Received ${#inputs[@]}. Processing only the first."
		fi
		process_files+=("${inputs[0]}")
	fi

	for input_file in "${process_files[@]}"; do
		if [[ ! -f "$input_file" ]]; then
			log_error "Input file not found: $input_file. Skipping."
			continue # Skip to next file in bulk mode, or exit if not bulk (handled by loop structure)
		fi

		base_name=$(basename "$input_file")
		ext="${base_name##*.}"
		base_name="${base_name%.*}"
		output_file="$OUTPUT_DIR/${base_name}_processed.$ext"
		output_file="$(ensure_unique_file "$output_file")"

		log_verbose "Processing '$input_file' -> '$output_file'"

		# Construct the ffmpeg command
		local -a ffmpeg_cmd=(
			ffmpeg -y # Overwrite output files without asking
			-i "$input_file"
		)

		# Add stream options
		ffmpeg_cmd+=("${stream_opts[@]}")

		# Add filters if they exist
		if [[ -n "$video_filters_str" ]]; then
			ffmpeg_cmd+=("-vf" "$video_filters_str")
		fi
		if [[ -n "$audio_filters_str" ]]; then
			ffmpeg_cmd+=("-af" "$audio_filters_str")
		fi

		# Add output file
		ffmpeg_cmd+=("$output_file")

		log_verbose "Executing: ${ffmpeg_cmd[*]}"
		# Execute the command. set -e will handle errors.
		if ! "${ffmpeg_cmd[@]}"; then
			log_error "FFmpeg failed for input '$input_file'."
			# In bulk mode, continue to next file. In non-bulk, set -e will exit.
			if "$BULK"; then continue; else exit 1; fi
		fi

		log_verbose "Finished processing '$input_file'."
	done
}

cmd_merge() {
	log_verbose "Executing command: merge with args: $*"
	local -a inputs=("$@")
	local output_file="$OUTPUT_DIR/merged_output.mp4"
	output_file="$(ensure_unique_file "$output_file")"
	local concat_list="$TEMP_DIR/concat_list.txt"
	local -a stream_opts=()
	local stream_opts_output

	if [[ ${#inputs[@]} -lt 2 ]]; then
		log_error "Command 'merge' requires at least two input files."
		echo "Usage: ffxd merge [global options] <input1> <input2> [input...]" >&2
		exit 1
	fi

	# Ensure all input files exist
	for input_file in "${inputs[@]}"; do
		if [[ ! -f "$input_file" ]]; then
			log_error "Input file not found: $input_file."
			exit 1
		fi
	done

	# Ensure output directory exists
	mkdir -p "$OUTPUT_DIR" || {
		log_error "Could not create output directory: $OUTPUT_DIR"
		exit 1
	}

	# Create a file list for the concat demuxer
	# Use printf to handle potential special characters in filenames safely
	printf "file '%s'\n" "${inputs[@]}" >"$concat_list" || {
		log_error "Could not create concat list file: $concat_list"
		exit 1
	}
	log_verbose "Created concat list: $concat_list"

	# Build common ffmpeg stream options (only relevant ones like -v, -an apply with -c copy)
	if ! stream_opts_output="$(build_ffmpeg_stream_opts)"; then
		log_error "Failed to build stream options."
		exit 1
	fi
	IFS=$'\0' read -r -d '' -a stream_opts <<<"$stream_opts_output"

	# Note: Filters like scale, fps, pts, interpolate are NOT applied with -c copy.
	# If these filters were requested, we would need to re-encode using filter_complex concat,
	# which is significantly more complex. For this script's scope, merge uses stream copy.
	# Check if any incompatible filters were requested.
	if "$MAX1080" || [[ -n "$FPS" ]] || [[ -n "$PTS" ]] || "$INTERPOLATE"; then
		log_error "Global options -m/--max1080, -f/--fps, -p/--pts, -i/--interpolate are not supported with 'merge' command (stream copy)."
		log_error "Merge uses stream copy for speed. Re-encoding with filters requires a different approach."
		exit 1
	fi

	# Construct the ffmpeg command using the concat demuxer
	local -a ffmpeg_cmd=(
		ffmpeg -y # Overwrite output files without asking
		-f concat
		-safe 0 # Required for file paths that are not relative or in current dir
		-i "$concat_list"
		-c copy             # Stream copy without re-encoding (fastest)
		"${stream_opts[@]}" # Add relevant common options like -an, -v info
		"$output_file"
	)

	log_verbose "Executing: ${ffmpeg_cmd[*]}"
	if ! "${ffmpeg_cmd[@]}"; then
		log_error "FFmpeg failed during merge."
		exit 1
	fi

	log_verbose "Finished merging files to '$output_file'."
}

cmd_composite() {
	log_verbose "Executing command: composite with args: $*"
	local -a inputs=("$@")
	local output_file="$OUTPUT_DIR/composite_output.mp4"
	output_file="$(ensure_unique_file "$output_file")"
	local num_inputs=${#inputs[@]}
	local filter_complex=""
	local final_v_stream="outputv"
	local final_a_stream="outputa"
	local -a stream_opts=()
	local video_filters_str=""
	local audio_filters_str=""
	local stream_opts_output

	if [[ "$num_inputs" -eq 0 ]]; then
		log_error "Command 'composite' requires at least one input file."
		echo "Usage: ffxd composite [global options] <input(s)>" >&2
		exit 1
	fi

	# Ensure all input files exist
	for input_file in "${inputs[@]}"; do
		if [[ ! -f "$input_file" ]]; then
			log_error "Input file not found: $input_file."
			exit 1
		fi
	done

	# Ensure output directory exists
	mkdir -p "$OUTPUT_DIR" || {
		log_error "Could not create output directory: $OUTPUT_DIR"
		exit 1
	}

	# Build common ffmpeg stream options
	if ! stream_opts_output="$(build_ffmpeg_stream_opts)"; then
		log_error "Failed to build stream options."
		exit 1
	fi
	IFS=$'\0' read -r -d '' -a stream_opts <<<"$stream_opts_output"

	# Build filter strings from global flags
	if ! video_filters_str="$(build_ffmpeg_filters v)"; then
		log_error "Failed to build video filters."
		exit 1 # build_ffmpeg_filters returns 1 if interpolation needs FPS
	fi
	if ! audio_filters_str="$(build_ffmpeg_filters a)"; then
		log_error "Failed to build audio filters."
		exit 1 # build_ffmpeg_filters returns 1 on awk errors
	fi

	# Construct the base filter_complex for compositing (stacking)
	local video_inputs_str=""
	local audio_inputs_str=""
	local layout=""
	local cols=0
	local rows=0

	for ((i = 0; i < num_inputs; i++)); do
		video_inputs_str+="[${i}:v]"
		audio_inputs_str+="[${i}:a]"
	done

	# Determine grid layout based on number of inputs
	case "$num_inputs" in
	1)
		# No stacking needed, just pass through
		filter_complex="${video_inputs_str}null[stacked_v];"
		if ! "$NOAUDIO"; then filter_complex+="${audio_inputs_str}anull[merged_a]"; fi
		final_v_stream="stacked_v"
		final_a_stream="merged_a"
		;;
	2)
		# Horizontal stack
		filter_complex="${video_inputs_str}hstack=inputs=2[stacked_v];"
		if ! "$NOAUDIO"; then filter_complex+="${audio_inputs_str}amerge=inputs=2[merged_a]"; fi
		final_v_stream="stacked_v"
		final_a_stream="merged_a"
		;;
	3)
		# Vertical stack
		filter_complex="${video_inputs_str}vstack=inputs=3[stacked_v];"
		if ! "$NOAUDIO"; then filter_complex+="${audio_inputs_str}amerge=inputs=3[merged_a]"; fi
		final_v_stream="stacked_v"
		final_a_stream="merged_a"
		;;
	4)
		# 2x2 grid
		cols=2
		rows=2
		layout="0_0|w0_0|0_h0|w0_h0"
		filter_complex="${video_inputs_str}xstack=inputs=${num_inputs}:layout=${layout}[stacked_v];"
		if ! "$NOAUDIO"; then filter_complex+="${audio_inputs_str}amerge=inputs=${num_inputs}[merged_a]"; fi
		final_v_stream="stacked_v"
		final_a_stream="merged_a"
		;;
	5 | 6 | 7 | 8 | 9)
		# Generalized grid up to 3x3 using xstack
		cols=3
		rows=$(((num_inputs + cols - 1) / cols))
		local i=0
		layout=""
		for ((r = 0; r < rows; r++)); do
			for ((c = 0; c < cols && i < num_inputs; c++)); do
				local x="${c}*w0"
				local y="${r}*h0"
				layout+="${x}_${y}|"
				i=$((i + 1))
			done
		done
		layout=${layout%|} # Remove trailing pipe
		filter_complex="${video_inputs_str}xstack=inputs=${num_inputs}:layout=${layout}[stacked_v];"
		if ! "$NOAUDIO"; then filter_complex+="${audio_inputs_str}amerge=inputs=${num_inputs}[merged_a]"; fi
		final_v_stream="stacked_v"
		final_a_stream="merged_a"
		;;
	*)
		log_error "Composite command currently supports 1 to 9 input files for automatic layout."
		exit 1
		;;
	esac

	# Append global filters to the stacked/merged streams if they exist
	local current_v_stream="$final_v_stream"
	local current_a_stream="$final_a_stream"

	if [[ -n "$video_filters_str" ]]; then
		filter_complex+="${current_v_stream}${video_filters_str}[final_v];"
		final_v_stream="final_v"
	fi

	if [[ -n "$audio_filters_str" && ! "$NOAUDIO" ]]; then
		# If video filters were added, the previous filter_complex ended with ';'.
		# If not, it ended with the audio merge filter.
		# Need to append correctly.
		if [[ "$filter_complex" == *";" ]]; then
			filter_complex+="${current_a_stream}${audio_filters_str}[final_a]"
		else
			filter_complex+=";${current_a_stream}${audio_filters_str}[final_a]"
		fi
		final_a_stream="final_a"
	fi

	# Construct the ffmpeg command
	local -a ffmpeg_cmd=(
		ffmpeg -y # Overwrite output files without asking
	)
	# Add input files
	for input_file in "${inputs[@]}"; do
		ffmpeg_cmd+=("-i" "$input_file")
	done

	ffmpeg_cmd+=(
		-filter_complex "$filter_complex"
		-map "$final_v_stream" # Map the final video output stream
	)
	if ! "$NOAUDIO"; then
		ffmpeg_cmd+=("-map" "$final_a_stream") # Map the final audio output stream
	fi

	# Add stream options (like -v info, potentially codecs/presets if not in filter_complex)
	ffmpeg_cmd+=("${stream_opts[@]}")

	# Add default codecs/presets if not specified by advanced options (which aren't auto-applied here)
	# This ensures output file creation works.
	ffmpeg_cmd+=("-c:v" "libx264" "-preset" "medium")
	if ! "$NOAUDIO"; then
		ffmpeg_cmd+=("-c:a" "aac")
	fi

	ffmpeg_cmd+=("$output_file")

	log_verbose "Executing: ${ffmpeg_cmd[*]}"
	if ! "${ffmpeg_cmd[@]}"; then
		log_error "FFmpeg failed during composite."
		exit 1
	fi

	log_verbose "Finished compositing files to '$output_file'."
}

cmd_looperang() {
	log_verbose "Executing command: looperang with args: $*"
	local input_file="$1"
	local output_file="$OUTPUT_DIR/looperang_output.mp4"
	output_file="$(ensure_unique_file "$output_file")"
	local reversed_temp="$TEMP_DIR/reversed_temp.mp4"
	local -a stream_opts=()
	local video_filters_str=""
	local audio_filters_str=""
	local stream_opts_output

	if [[ $# -ne 1 ]]; then
		log_error "Command 'looperang' requires exactly one input file."
		echo "Usage: ffxd looperang [global options] <input>" >&2
		exit 1
	fi

	if [[ ! -f "$input_file" ]]; then
		log_error "Input file not found: $input_file."
		exit 1
	fi

	# Ensure output directory exists
	mkdir -p "$OUTPUT_DIR" || {
		log_error "Could not create output directory: $OUTPUT_DIR"
		exit 1
	}

	# Build common ffmpeg stream options
	if ! stream_opts_output="$(build_ffmpeg_stream_opts)"; then
		log_error "Failed to build stream options."
		exit 1
	fi
	IFS=$'\0' read -r -d '' -a stream_opts <<<"$stream_opts_output"

	# Build filter strings from global flags
	if ! video_filters_str="$(build_ffmpeg_filters v)"; then
		log_error "Failed to build video filters."
		exit 1 # build_ffmpeg_filters returns 1 if interpolation needs FPS
	fi
	if ! audio_filters_str="$(build_ffmpeg_filters a)"; then
		log_error "Failed to build audio filters."
		exit 1 # build_ffmpeg_filters returns 1 on awk errors
	fi

	# Step 1: Create reversed video (to a temporary file)
	log_verbose "Creating reversed video: '$input_file' -> '$reversed_temp'"
	local -a reverse_cmd=(
		ffmpeg -y # Overwrite temp file
		-i "$input_file"
		-vf reverse # Reverse video
	)
	if ! "$NOAUDIO"; then
		reverse_cmd+=("-af" "areverse") # Reverse audio
	else
		reverse_cmd+=("-an") # Ensure no audio in reversed temp if NOAUDIO is set
	fi
	# Use fast re-encoding for the temporary file
	reverse_cmd+=("-c:v" "libx264" "-preset" "fast")
	if ! "$NOAUDIO"; then reverse_cmd+=("-c:a" "aac"); fi
	reverse_cmd+=("$reversed_temp")

	log_verbose "Executing: ${reverse_cmd[*]}"
	if ! "${reverse_cmd[@]}"; then
		log_error "FFmpeg failed during reverse step."
		exit 1
	fi

	# Step 2: Concatenate original and reversed videos using filter_complex
	log_verbose "Concatenating '$input_file' and '$reversed_temp' -> '$output_file'"

	local filter_complex_concat=""
	local final_v_stream="concat_v"
	local final_a_stream="concat_a"

	if ! "$NOAUDIO"; then
		# Concat video and audio streams
		filter_complex_concat="[0:v][0:a][1:v][1:a]concat=n=2:v=1:a=1[${final_v_stream}][${final_a_stream}]"
	else
		# Concat video streams only
		filter_complex_concat="[0:v][1:v]concat=n=2:v=1:a=0[${final_v_stream}]"
	fi

	# Append global filters to the concatenated streams if they exist
	local current_v_stream="$final_v_stream"
	local current_a_stream="$final_a_stream"

	if [[ -n "$video_filters_str" ]]; then
		filter_complex_concat+=";${current_v_stream}${video_filters_str}[final_v]"
		final_v_stream="final_v"
	fi

	if [[ -n "$audio_filters_str" && ! "$NOAUDIO" ]]; then
		# If video filters were added, the previous filter_complex ended with '[final_v]'.
		# If not, it ended with '[concat_a]'.
		# Need to append correctly.
		if [[ "$filter_complex_concat" == *"]" ]]; then # Check if it ends with a stream label
			filter_complex_concat+=";${current_a_stream}${audio_filters_str}[final_a]"
		else # Should not happen with current logic, but as a safeguard
			filter_complex_concat+=";${current_a_stream}${audio_filters_str}[final_a]"
		fi
		final_a_stream="final_a"
	fi

	local -a concat_cmd=(
		ffmpeg -y           # Overwrite output file
		-i "$input_file"    # Input 0 (original)
		-i "$reversed_temp" # Input 1 (reversed)
		-filter_complex "$filter_complex_concat"
		-map "$final_v_stream" # Map concatenated video stream
	)
	if ! "$NOAUDIO"; then
		concat_cmd+=("-map" "$final_a_stream") # Map concatenated audio stream
	fi

	# Add stream options
	concat_cmd+=("${stream_opts[@]}")

	# Add default codecs/presets if not specified by advanced options
	concat_cmd+=("-c:v" "libx264" "-preset" "medium")
	if ! "$NOAUDIO"; then
		concat_cmd+=("-c:a" "aac")
	fi

	concat_cmd+=("$output_file")

	log_verbose "Executing: ${concat_cmd[*]}"
	if ! "${concat_cmd[@]}"; then
		log_error "FFmpeg failed during concat step."
		exit 1
	fi

	log_verbose "Finished creating looperang video '$output_file'."
	# Temp file is cleaned by trap on exit
}

cmd_slowmo() {
	log_verbose "Executing command: slowmo with args: $*"
	local input_file="$1"

	if [[ $# -ne 1 ]]; then
		log_error "Command 'slowmo' requires exactly one input file."
		echo "Usage: ffxd slowmo [global options] <input>" >&2
		exit 1
	fi

	if [[ ! -f "$input_file" ]]; then
		log_error "Input file not found: $input_file."
		exit 1
	fi

	# slowmo implies a PTS factor < 1.0. Require -p.
	if [[ -z "$PTS" ]]; then
		log_error "Slow motion requires a playback speed factor. Please specify with -p/--pts (e.g., -p 0.5)."
		exit 1
	fi

	# Check if INTERPOLATE is requested but FPS is missing.
	# This check is also in build_ffmpeg_filters, but better to fail early here.
	if "$INTERPOLATE" && [[ -z "$FPS" ]]; then
		log_error "Motion interpolation requires a target frame rate. Please specify with -f/--fps."
		exit 1
	fi

	log_verbose "Calling cmd_process with input '$input_file' and current global options."
	# cmd_process will apply the PTS filter and potentially interpolation/FPS if set.
	cmd_process "$input_file"

	log_verbose "Finished creating slow-motion video."
}

cmd_fix() {
	log_verbose "Executing command: fix with args: $*"
	local input_file="$1"
	local output_file="$OUTPUT_DIR/fixed_output.mp4"
	output_file="$(ensure_unique_file "$output_file")"
	local -a stream_opts=()
	local video_filters_str=""
	local audio_filters_str=""
	local stream_opts_output

	if [[ $# -ne 1 ]]; then
		log_error "Command 'fix' requires exactly one input file."
		echo "Usage: ffxd fix [global options] <input>" >&2
		exit 1
	fi

	if [[ ! -f "$input_file" ]]; then
		log_error "Input file not found: $input_file."
		exit 1
	fi

	# Ensure output directory exists
	mkdir -p "$OUTPUT_DIR" || {
		log_error "Could not create output directory: $OUTPUT_DIR"
		exit 1
	}

	# Build common ffmpeg stream options
	if ! stream_opts_output="$(build_ffmpeg_stream_opts)"; then
		log_error "Failed to build stream options."
		exit 1
	fi
	IFS=$'\0' read -r -d '' -a stream_opts <<<"$stream_opts_output"

	# Build filter strings from global flags
	# Note: Interpolation (-i) doesn't make sense with a simple VFR->CFR fix using -r.
	# Disallow it here.
	if "$INTERPOLATE"; then
		log_error "Global option -i/--interpolate is not supported with 'fix' command."
		exit 1
	fi

	# Temporarily unset INTERPOLATE and FPS/PTS to get only compatible filters
	local temp_interpolate="$INTERPOLATE"
	local temp_fps="$FPS"
	local temp_pts="$PTS"
	INTERPOLATE=false
	FPS="" # Temporarily unset so build_ffmpeg_filters doesn't include minterpolate or specific FPS logic
	PTS="" # Temporarily unset so build_ffmpeg_filters doesn't include setpts/atempo

	if ! video_filters_str="$(build_ffmpeg_filters v)"; then
		log_error "Failed to build video filters."
		exit 1
	fi
	if ! audio_filters_str="$(build_ffmpeg_filters a)"; then
		log_error "Failed to build audio filters."
		exit 1
	fi

	# Restore original values
	INTERPOLATE="$temp_interpolate"
	FPS="$temp_fps"
	PTS="$temp_pts"

	# Determine target FPS. Use -f if provided, otherwise default to 30.
	local target_fps="$FPS"
	if [[ -z "$target_fps" ]]; then
		log_verbose "No target FPS specified for fix command, defaulting to 30."
		target_fps="30"
	fi

	# Construct the ffmpeg command to fix VFR to CFR and apply other filters
	local -a ffmpeg_cmd=(
		ffmpeg -y # Overwrite output file
		-i "$input_file"
		-r "$target_fps" # Force constant frame rate
	)

	# Add stream options
	ffmpeg_cmd+=("${stream_opts[@]}")

	# Add filters if they exist
	if [[ -n "$video_filters_str" ]]; then
		ffmpeg_cmd+=("-vf" "$video_filters_str")
	fi
	if [[ -n "$audio_filters_str" ]]; then
		ffmpeg_cmd+=("-af" "$audio_filters_str")
	fi

	# Add codecs/presets for re-encoding
	ffmpeg_cmd+=("-c:v" "libx264" "-preset" "medium")
	if ! "$NOAUDIO"; then
		ffmpeg_cmd+=("-c:a" "aac")
	else
		ffmpeg_cmd+=("-an") # Ensure -an is present if NOAUDIO was set
	fi

	ffmpeg_cmd+=("$output_file")

	log_verbose "Executing: ${ffmpeg_cmd[*]}"
	if ! "${ffmpeg_cmd[@]}"; then
		log_error "FFmpeg failed during fix command."
		exit 1
	fi

	log_verbose "Finished fixing video '$input_file' to '$output_file'."
}

cmd_clean() {
	log_verbose "Executing command: clean with args: $*"
	local do_cache=false do_config=false
	local arg

	# Parse clean command specific options
	while [[ $# -gt 0 ]]; do
		arg="$1"
		case "$arg" in
		--cache) do_cache=true ;;
		--config) do_config=true ;;
		# Removing --metadata as its implementation was complex and potentially confusing/destructive
		*)
			log_error "Unknown option for clean command: $arg"
			echo "Usage: ffxd clean [--cache] [--config]" >&2
			exit 1
			;;
		esac
		shift
	done

	local ffxd_cache_dir="$XDG_CACHE_HOME/ffxd"
	local ffxd_config_dir="$XDG_CONFIG_HOME/ffxd"

	log_verbose "Attempting to clean directories as requested"

	# Always clean the current run's temporary directory (handled by trap EXIT)
	# Clean the general runtime directory
	if [[ -d "$FFxd_RUNTIME_DIR" ]]; then
		log_verbose "Removing runtime directory: $FFxd_RUNTIME_DIR"
		rm -rf -- "$FFxd_RUNTIME_DIR" || log_error "Failed to remove runtime directory: $FFxd_RUNTIME_DIR"
	else
		log_verbose "Runtime directory not found: $FFxd_RUNTIME_DIR"
	fi

	# Clean cache directory if requested
	if "$do_cache"; then
		if [[ -d "$ffxd_cache_dir" ]]; then
			log_verbose "Removing cache directory: $ffxd_cache_dir"
			rm -rf -- "$ffxd_cache_dir" || log_error "Failed to remove cache directory: $ffxd_cache_dir"
		else
			log_verbose "Cache directory not found: $ffxd_cache_dir"
		fi
	fi

	# Clean config directory if requested
	if "$do_config"; then
		if [[ -d "$ffxd_config_dir" ]]; then
			log_verbose "Removing config directory: $ffxd_config_dir"
			rm -rf -- "$ffxd_config_dir" || log_error "Failed to remove config directory: $ffxd_config_dir"
		else
			log_verbose "Config directory not found: $ffxd_config_dir"
		fi
	fi

	log_verbose "Clean command finished."
}

cmd_probe() {
	log_verbose "Executing command: probe with args: $*"
	local input_file="$1"

	if [[ $# -ne 1 ]]; then
		log_error "Command 'probe' requires exactly one input file."
		echo "Usage: ffxd probe <input>" >&2
		exit 1
	fi

	if [[ ! -f "$input_file" ]]; then
		log_error "Input file not found: $input_file."
		exit 1
	fi

	log_verbose "Probing file: '$input_file'"

	# Construct the ffprobe command
	local -a ffprobe_cmd=(
		ffprobe
		-hide_banner  # Hide ffprobe version info
		-show_streams # Show stream information
		-show_format  # Show format information
		"$input_file"
	)

	log_verbose "Executing: ${ffprobe_cmd[*]}"
	# Execute the command. Output goes to stdout by default.
	if ! "${ffprobe_cmd[@]}"; then
		log_error "ffprobe failed for input '$input_file'."
		exit 1
	fi

	log_verbose "Probe command finished."
}

main() {
	# Parse global options from the initial arguments.
	# This populates global flags and COMMAND_ARGS.
	parse_global_options "$@"

	# Check if advanced prompt was requested.
	if "$ADVANCED"; then
		advanced_prompt
		# Exit after advanced prompt unless a command was also specified?
		# Current behavior is to run the command after the prompt.
		# If no command was given, COMMAND_ARGS[0] will be empty, defaulting to 'help'.
		# This seems reasonable.
	fi

	# The command name is the first element in COMMAND_ARGS.
	# Default to 'help' if no command is provided.
	local cmd="${COMMAND_ARGS[0]:-help}"

	# The arguments for the command are the rest of the elements in COMMAND_ARGS.
	local -a cmd_args=("${COMMAND_ARGS[@]:1}")

	log_verbose "Dispatching command: '$cmd' with arguments: ${cmd_args[*]}"

	# Dispatch to the appropriate command function.
	case "$cmd" in
	process) cmd_process "${cmd_args[@]}" ;;
	merge) cmd_merge "${cmd_args[@]}" ;;
	composite) cmd_composite "${cmd_args[@]}" ;;
	looperang) cmd_looperang "${cmd_args[@]}" ;;
	slowmo) cmd_slowmo "${cmd_args[@]}" ;;
	fix) cmd_fix "${cmd_args[@]}" ;;
	clean) cmd_clean "${cmd_args[@]}" ;;
	probe) cmd_probe "${cmd_args[@]}" ;;
	help | -h | --help) show_help ;;
	*)
		log_error "Unknown command: $cmd"
		show_help
		exit 1
		;;
	esac
}

main "$@"
